
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Ammpair
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Ammpair = $Result.DefaultSelection<Prisma.$AmmpairPayload>
/**
 * Model EventTracking
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type EventTracking = $Result.DefaultSelection<Prisma.$EventTrackingPayload>
/**
 * Model GameResult
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type GameResult = $Result.DefaultSelection<Prisma.$GameResultPayload>
/**
 * Model PoolsDB
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type PoolsDB = $Result.DefaultSelection<Prisma.$PoolsDBPayload>
/**
 * Model TradeEvent
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type TradeEvent = $Result.DefaultSelection<Prisma.$TradeEventPayload>
/**
 * Model VRFCallback
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type VRFCallback = $Result.DefaultSelection<Prisma.$VRFCallbackPayload>
/**
 * Model block_progress
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type block_progress = $Result.DefaultSelection<Prisma.$block_progressPayload>
/**
 * Model comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type comments = $Result.DefaultSelection<Prisma.$commentsPayload>
/**
 * Model images
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type images = $Result.DefaultSelection<Prisma.$imagesPayload>
/**
 * Model likes
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type likes = $Result.DefaultSelection<Prisma.$likesPayload>
/**
 * Model migration_events
 * 
 */
export type migration_events = $Result.DefaultSelection<Prisma.$migration_eventsPayload>
/**
 * Model protocol_stats
 * 
 */
export type protocol_stats = $Result.DefaultSelection<Prisma.$protocol_statsPayload>
/**
 * Model staking_pools
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type staking_pools = $Result.DefaultSelection<Prisma.$staking_poolsPayload>
/**
 * Model token_price_history
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type token_price_history = $Result.DefaultSelection<Prisma.$token_price_historyPayload>
/**
 * Model token_prices
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type token_prices = $Result.DefaultSelection<Prisma.$token_pricesPayload>
/**
 * Model tokens
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type tokens = $Result.DefaultSelection<Prisma.$tokensPayload>
/**
 * Model trust_pools
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type trust_pools = $Result.DefaultSelection<Prisma.$trust_poolsPayload>
/**
 * Model user_stakes
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type user_stakes = $Result.DefaultSelection<Prisma.$user_stakesPayload>
/**
 * Model users
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model token_holders
 * 
 */
export type token_holders = $Result.DefaultSelection<Prisma.$token_holdersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AmmVersion: {
  V1: 'V1',
  V2: 'V2',
  V3: 'V3',
  V4: 'V4'
};

export type AmmVersion = (typeof AmmVersion)[keyof typeof AmmVersion]


export const PoolType: {
  MEME: 'MEME',
  LP: 'LP',
  DAO: 'DAO',
  BIG_DAO: 'BIG_DAO',
  GENERAL: 'GENERAL'
};

export type PoolType = (typeof PoolType)[keyof typeof PoolType]

}

export type AmmVersion = $Enums.AmmVersion

export const AmmVersion: typeof $Enums.AmmVersion

export type PoolType = $Enums.PoolType

export const PoolType: typeof $Enums.PoolType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ammpairs
 * const ammpairs = await prisma.ammpair.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ammpairs
   * const ammpairs = await prisma.ammpair.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.ammpair`: Exposes CRUD operations for the **Ammpair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ammpairs
    * const ammpairs = await prisma.ammpair.findMany()
    * ```
    */
  get ammpair(): Prisma.AmmpairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventTracking`: Exposes CRUD operations for the **EventTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventTrackings
    * const eventTrackings = await prisma.eventTracking.findMany()
    * ```
    */
  get eventTracking(): Prisma.EventTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameResult`: Exposes CRUD operations for the **GameResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameResults
    * const gameResults = await prisma.gameResult.findMany()
    * ```
    */
  get gameResult(): Prisma.GameResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poolsDB`: Exposes CRUD operations for the **PoolsDB** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PoolsDBS
    * const poolsDBS = await prisma.poolsDB.findMany()
    * ```
    */
  get poolsDB(): Prisma.PoolsDBDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tradeEvent`: Exposes CRUD operations for the **TradeEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeEvents
    * const tradeEvents = await prisma.tradeEvent.findMany()
    * ```
    */
  get tradeEvent(): Prisma.TradeEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vRFCallback`: Exposes CRUD operations for the **VRFCallback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VRFCallbacks
    * const vRFCallbacks = await prisma.vRFCallback.findMany()
    * ```
    */
  get vRFCallback(): Prisma.VRFCallbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.block_progress`: Exposes CRUD operations for the **block_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Block_progresses
    * const block_progresses = await prisma.block_progress.findMany()
    * ```
    */
  get block_progress(): Prisma.block_progressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.commentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.images`: Exposes CRUD operations for the **images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.images.findMany()
    * ```
    */
  get images(): Prisma.imagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.likes`: Exposes CRUD operations for the **likes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.likes.findMany()
    * ```
    */
  get likes(): Prisma.likesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migration_events`: Exposes CRUD operations for the **migration_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migration_events
    * const migration_events = await prisma.migration_events.findMany()
    * ```
    */
  get migration_events(): Prisma.migration_eventsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.protocol_stats`: Exposes CRUD operations for the **protocol_stats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Protocol_stats
    * const protocol_stats = await prisma.protocol_stats.findMany()
    * ```
    */
  get protocol_stats(): Prisma.protocol_statsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staking_pools`: Exposes CRUD operations for the **staking_pools** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staking_pools
    * const staking_pools = await prisma.staking_pools.findMany()
    * ```
    */
  get staking_pools(): Prisma.staking_poolsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token_price_history`: Exposes CRUD operations for the **token_price_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Token_price_histories
    * const token_price_histories = await prisma.token_price_history.findMany()
    * ```
    */
  get token_price_history(): Prisma.token_price_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token_prices`: Exposes CRUD operations for the **token_prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Token_prices
    * const token_prices = await prisma.token_prices.findMany()
    * ```
    */
  get token_prices(): Prisma.token_pricesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokens`: Exposes CRUD operations for the **tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.tokens.findMany()
    * ```
    */
  get tokens(): Prisma.tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trust_pools`: Exposes CRUD operations for the **trust_pools** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trust_pools
    * const trust_pools = await prisma.trust_pools.findMany()
    * ```
    */
  get trust_pools(): Prisma.trust_poolsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_stakes`: Exposes CRUD operations for the **user_stakes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_stakes
    * const user_stakes = await prisma.user_stakes.findMany()
    * ```
    */
  get user_stakes(): Prisma.user_stakesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token_holders`: Exposes CRUD operations for the **token_holders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Token_holders
    * const token_holders = await prisma.token_holders.findMany()
    * ```
    */
  get token_holders(): Prisma.token_holdersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Ammpair: 'Ammpair',
    EventTracking: 'EventTracking',
    GameResult: 'GameResult',
    PoolsDB: 'PoolsDB',
    TradeEvent: 'TradeEvent',
    VRFCallback: 'VRFCallback',
    block_progress: 'block_progress',
    comments: 'comments',
    images: 'images',
    likes: 'likes',
    migration_events: 'migration_events',
    protocol_stats: 'protocol_stats',
    staking_pools: 'staking_pools',
    token_price_history: 'token_price_history',
    token_prices: 'token_prices',
    tokens: 'tokens',
    trust_pools: 'trust_pools',
    user_stakes: 'user_stakes',
    users: 'users',
    token_holders: 'token_holders'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "ammpair" | "eventTracking" | "gameResult" | "poolsDB" | "tradeEvent" | "vRFCallback" | "block_progress" | "comments" | "images" | "likes" | "migration_events" | "protocol_stats" | "staking_pools" | "token_price_history" | "token_prices" | "tokens" | "trust_pools" | "user_stakes" | "users" | "token_holders"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Ammpair: {
        payload: Prisma.$AmmpairPayload<ExtArgs>
        fields: Prisma.AmmpairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmmpairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmmpairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>
          }
          findFirst: {
            args: Prisma.AmmpairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmmpairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>
          }
          findMany: {
            args: Prisma.AmmpairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>[]
          }
          create: {
            args: Prisma.AmmpairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>
          }
          createMany: {
            args: Prisma.AmmpairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmmpairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>[]
          }
          delete: {
            args: Prisma.AmmpairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>
          }
          update: {
            args: Prisma.AmmpairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>
          }
          deleteMany: {
            args: Prisma.AmmpairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmmpairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmmpairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>[]
          }
          upsert: {
            args: Prisma.AmmpairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmpairPayload>
          }
          aggregate: {
            args: Prisma.AmmpairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmmpair>
          }
          groupBy: {
            args: Prisma.AmmpairGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmmpairGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmmpairCountArgs<ExtArgs>
            result: $Utils.Optional<AmmpairCountAggregateOutputType> | number
          }
        }
      }
      EventTracking: {
        payload: Prisma.$EventTrackingPayload<ExtArgs>
        fields: Prisma.EventTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>
          }
          findFirst: {
            args: Prisma.EventTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>
          }
          findMany: {
            args: Prisma.EventTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>[]
          }
          create: {
            args: Prisma.EventTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>
          }
          createMany: {
            args: Prisma.EventTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>[]
          }
          delete: {
            args: Prisma.EventTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>
          }
          update: {
            args: Prisma.EventTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>
          }
          deleteMany: {
            args: Prisma.EventTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>[]
          }
          upsert: {
            args: Prisma.EventTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTrackingPayload>
          }
          aggregate: {
            args: Prisma.EventTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventTracking>
          }
          groupBy: {
            args: Prisma.EventTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<EventTrackingCountAggregateOutputType> | number
          }
        }
      }
      GameResult: {
        payload: Prisma.$GameResultPayload<ExtArgs>
        fields: Prisma.GameResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>
          }
          findFirst: {
            args: Prisma.GameResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>
          }
          findMany: {
            args: Prisma.GameResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>[]
          }
          create: {
            args: Prisma.GameResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>
          }
          createMany: {
            args: Prisma.GameResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>[]
          }
          delete: {
            args: Prisma.GameResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>
          }
          update: {
            args: Prisma.GameResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>
          }
          deleteMany: {
            args: Prisma.GameResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>[]
          }
          upsert: {
            args: Prisma.GameResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameResultPayload>
          }
          aggregate: {
            args: Prisma.GameResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameResult>
          }
          groupBy: {
            args: Prisma.GameResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameResultCountArgs<ExtArgs>
            result: $Utils.Optional<GameResultCountAggregateOutputType> | number
          }
        }
      }
      PoolsDB: {
        payload: Prisma.$PoolsDBPayload<ExtArgs>
        fields: Prisma.PoolsDBFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PoolsDBFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PoolsDBFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>
          }
          findFirst: {
            args: Prisma.PoolsDBFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PoolsDBFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>
          }
          findMany: {
            args: Prisma.PoolsDBFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>[]
          }
          create: {
            args: Prisma.PoolsDBCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>
          }
          createMany: {
            args: Prisma.PoolsDBCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PoolsDBCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>[]
          }
          delete: {
            args: Prisma.PoolsDBDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>
          }
          update: {
            args: Prisma.PoolsDBUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>
          }
          deleteMany: {
            args: Prisma.PoolsDBDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PoolsDBUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PoolsDBUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>[]
          }
          upsert: {
            args: Prisma.PoolsDBUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoolsDBPayload>
          }
          aggregate: {
            args: Prisma.PoolsDBAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoolsDB>
          }
          groupBy: {
            args: Prisma.PoolsDBGroupByArgs<ExtArgs>
            result: $Utils.Optional<PoolsDBGroupByOutputType>[]
          }
          count: {
            args: Prisma.PoolsDBCountArgs<ExtArgs>
            result: $Utils.Optional<PoolsDBCountAggregateOutputType> | number
          }
        }
      }
      TradeEvent: {
        payload: Prisma.$TradeEventPayload<ExtArgs>
        fields: Prisma.TradeEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>
          }
          findFirst: {
            args: Prisma.TradeEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>
          }
          findMany: {
            args: Prisma.TradeEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>[]
          }
          create: {
            args: Prisma.TradeEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>
          }
          createMany: {
            args: Prisma.TradeEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>[]
          }
          delete: {
            args: Prisma.TradeEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>
          }
          update: {
            args: Prisma.TradeEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>
          }
          deleteMany: {
            args: Prisma.TradeEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TradeEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>[]
          }
          upsert: {
            args: Prisma.TradeEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeEventPayload>
          }
          aggregate: {
            args: Prisma.TradeEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeEvent>
          }
          groupBy: {
            args: Prisma.TradeEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeEventCountArgs<ExtArgs>
            result: $Utils.Optional<TradeEventCountAggregateOutputType> | number
          }
        }
      }
      VRFCallback: {
        payload: Prisma.$VRFCallbackPayload<ExtArgs>
        fields: Prisma.VRFCallbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VRFCallbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VRFCallbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>
          }
          findFirst: {
            args: Prisma.VRFCallbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VRFCallbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>
          }
          findMany: {
            args: Prisma.VRFCallbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>[]
          }
          create: {
            args: Prisma.VRFCallbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>
          }
          createMany: {
            args: Prisma.VRFCallbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VRFCallbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>[]
          }
          delete: {
            args: Prisma.VRFCallbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>
          }
          update: {
            args: Prisma.VRFCallbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>
          }
          deleteMany: {
            args: Prisma.VRFCallbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VRFCallbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VRFCallbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>[]
          }
          upsert: {
            args: Prisma.VRFCallbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VRFCallbackPayload>
          }
          aggregate: {
            args: Prisma.VRFCallbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVRFCallback>
          }
          groupBy: {
            args: Prisma.VRFCallbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<VRFCallbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.VRFCallbackCountArgs<ExtArgs>
            result: $Utils.Optional<VRFCallbackCountAggregateOutputType> | number
          }
        }
      }
      block_progress: {
        payload: Prisma.$block_progressPayload<ExtArgs>
        fields: Prisma.block_progressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.block_progressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.block_progressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>
          }
          findFirst: {
            args: Prisma.block_progressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.block_progressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>
          }
          findMany: {
            args: Prisma.block_progressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>[]
          }
          create: {
            args: Prisma.block_progressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>
          }
          createMany: {
            args: Prisma.block_progressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.block_progressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>[]
          }
          delete: {
            args: Prisma.block_progressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>
          }
          update: {
            args: Prisma.block_progressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>
          }
          deleteMany: {
            args: Prisma.block_progressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.block_progressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.block_progressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>[]
          }
          upsert: {
            args: Prisma.block_progressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_progressPayload>
          }
          aggregate: {
            args: Prisma.Block_progressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock_progress>
          }
          groupBy: {
            args: Prisma.block_progressGroupByArgs<ExtArgs>
            result: $Utils.Optional<Block_progressGroupByOutputType>[]
          }
          count: {
            args: Prisma.block_progressCountArgs<ExtArgs>
            result: $Utils.Optional<Block_progressCountAggregateOutputType> | number
          }
        }
      }
      comments: {
        payload: Prisma.$commentsPayload<ExtArgs>
        fields: Prisma.commentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.commentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.commentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.commentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      images: {
        payload: Prisma.$imagesPayload<ExtArgs>
        fields: Prisma.imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          findFirst: {
            args: Prisma.imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          findMany: {
            args: Prisma.imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>[]
          }
          create: {
            args: Prisma.imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          createMany: {
            args: Prisma.imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.imagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>[]
          }
          delete: {
            args: Prisma.imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          update: {
            args: Prisma.imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          deleteMany: {
            args: Prisma.imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.imagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>[]
          }
          upsert: {
            args: Prisma.imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          aggregate: {
            args: Prisma.ImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImages>
          }
          groupBy: {
            args: Prisma.imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.imagesCountArgs<ExtArgs>
            result: $Utils.Optional<ImagesCountAggregateOutputType> | number
          }
        }
      }
      likes: {
        payload: Prisma.$likesPayload<ExtArgs>
        fields: Prisma.likesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.likesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.likesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          findFirst: {
            args: Prisma.likesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.likesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          findMany: {
            args: Prisma.likesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>[]
          }
          create: {
            args: Prisma.likesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          createMany: {
            args: Prisma.likesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.likesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>[]
          }
          delete: {
            args: Prisma.likesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          update: {
            args: Prisma.likesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          deleteMany: {
            args: Prisma.likesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.likesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.likesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>[]
          }
          upsert: {
            args: Prisma.likesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          aggregate: {
            args: Prisma.LikesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikes>
          }
          groupBy: {
            args: Prisma.likesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.likesCountArgs<ExtArgs>
            result: $Utils.Optional<LikesCountAggregateOutputType> | number
          }
        }
      }
      migration_events: {
        payload: Prisma.$migration_eventsPayload<ExtArgs>
        fields: Prisma.migration_eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migration_eventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migration_eventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>
          }
          findFirst: {
            args: Prisma.migration_eventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migration_eventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>
          }
          findMany: {
            args: Prisma.migration_eventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>[]
          }
          create: {
            args: Prisma.migration_eventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>
          }
          createMany: {
            args: Prisma.migration_eventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.migration_eventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>[]
          }
          delete: {
            args: Prisma.migration_eventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>
          }
          update: {
            args: Prisma.migration_eventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>
          }
          deleteMany: {
            args: Prisma.migration_eventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migration_eventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.migration_eventsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>[]
          }
          upsert: {
            args: Prisma.migration_eventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migration_eventsPayload>
          }
          aggregate: {
            args: Prisma.Migration_eventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigration_events>
          }
          groupBy: {
            args: Prisma.migration_eventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Migration_eventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migration_eventsCountArgs<ExtArgs>
            result: $Utils.Optional<Migration_eventsCountAggregateOutputType> | number
          }
        }
      }
      protocol_stats: {
        payload: Prisma.$protocol_statsPayload<ExtArgs>
        fields: Prisma.protocol_statsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.protocol_statsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.protocol_statsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>
          }
          findFirst: {
            args: Prisma.protocol_statsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.protocol_statsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>
          }
          findMany: {
            args: Prisma.protocol_statsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>[]
          }
          create: {
            args: Prisma.protocol_statsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>
          }
          createMany: {
            args: Prisma.protocol_statsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.protocol_statsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>[]
          }
          delete: {
            args: Prisma.protocol_statsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>
          }
          update: {
            args: Prisma.protocol_statsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>
          }
          deleteMany: {
            args: Prisma.protocol_statsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.protocol_statsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.protocol_statsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>[]
          }
          upsert: {
            args: Prisma.protocol_statsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$protocol_statsPayload>
          }
          aggregate: {
            args: Prisma.Protocol_statsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocol_stats>
          }
          groupBy: {
            args: Prisma.protocol_statsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Protocol_statsGroupByOutputType>[]
          }
          count: {
            args: Prisma.protocol_statsCountArgs<ExtArgs>
            result: $Utils.Optional<Protocol_statsCountAggregateOutputType> | number
          }
        }
      }
      staking_pools: {
        payload: Prisma.$staking_poolsPayload<ExtArgs>
        fields: Prisma.staking_poolsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.staking_poolsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.staking_poolsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>
          }
          findFirst: {
            args: Prisma.staking_poolsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.staking_poolsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>
          }
          findMany: {
            args: Prisma.staking_poolsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>[]
          }
          create: {
            args: Prisma.staking_poolsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>
          }
          createMany: {
            args: Prisma.staking_poolsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.staking_poolsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>[]
          }
          delete: {
            args: Prisma.staking_poolsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>
          }
          update: {
            args: Prisma.staking_poolsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>
          }
          deleteMany: {
            args: Prisma.staking_poolsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.staking_poolsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.staking_poolsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>[]
          }
          upsert: {
            args: Prisma.staking_poolsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staking_poolsPayload>
          }
          aggregate: {
            args: Prisma.Staking_poolsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaking_pools>
          }
          groupBy: {
            args: Prisma.staking_poolsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Staking_poolsGroupByOutputType>[]
          }
          count: {
            args: Prisma.staking_poolsCountArgs<ExtArgs>
            result: $Utils.Optional<Staking_poolsCountAggregateOutputType> | number
          }
        }
      }
      token_price_history: {
        payload: Prisma.$token_price_historyPayload<ExtArgs>
        fields: Prisma.token_price_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.token_price_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.token_price_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>
          }
          findFirst: {
            args: Prisma.token_price_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.token_price_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>
          }
          findMany: {
            args: Prisma.token_price_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>[]
          }
          create: {
            args: Prisma.token_price_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>
          }
          createMany: {
            args: Prisma.token_price_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.token_price_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>[]
          }
          delete: {
            args: Prisma.token_price_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>
          }
          update: {
            args: Prisma.token_price_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>
          }
          deleteMany: {
            args: Prisma.token_price_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.token_price_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.token_price_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>[]
          }
          upsert: {
            args: Prisma.token_price_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_price_historyPayload>
          }
          aggregate: {
            args: Prisma.Token_price_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken_price_history>
          }
          groupBy: {
            args: Prisma.token_price_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Token_price_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.token_price_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Token_price_historyCountAggregateOutputType> | number
          }
        }
      }
      token_prices: {
        payload: Prisma.$token_pricesPayload<ExtArgs>
        fields: Prisma.token_pricesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.token_pricesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.token_pricesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>
          }
          findFirst: {
            args: Prisma.token_pricesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.token_pricesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>
          }
          findMany: {
            args: Prisma.token_pricesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>[]
          }
          create: {
            args: Prisma.token_pricesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>
          }
          createMany: {
            args: Prisma.token_pricesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.token_pricesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>[]
          }
          delete: {
            args: Prisma.token_pricesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>
          }
          update: {
            args: Prisma.token_pricesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>
          }
          deleteMany: {
            args: Prisma.token_pricesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.token_pricesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.token_pricesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>[]
          }
          upsert: {
            args: Prisma.token_pricesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_pricesPayload>
          }
          aggregate: {
            args: Prisma.Token_pricesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken_prices>
          }
          groupBy: {
            args: Prisma.token_pricesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Token_pricesGroupByOutputType>[]
          }
          count: {
            args: Prisma.token_pricesCountArgs<ExtArgs>
            result: $Utils.Optional<Token_pricesCountAggregateOutputType> | number
          }
        }
      }
      tokens: {
        payload: Prisma.$tokensPayload<ExtArgs>
        fields: Prisma.tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          findFirst: {
            args: Prisma.tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          findMany: {
            args: Prisma.tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          create: {
            args: Prisma.tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          createMany: {
            args: Prisma.tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          delete: {
            args: Prisma.tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          update: {
            args: Prisma.tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          deleteMany: {
            args: Prisma.tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          upsert: {
            args: Prisma.tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          aggregate: {
            args: Prisma.TokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokens>
          }
          groupBy: {
            args: Prisma.tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.tokensCountArgs<ExtArgs>
            result: $Utils.Optional<TokensCountAggregateOutputType> | number
          }
        }
      }
      trust_pools: {
        payload: Prisma.$trust_poolsPayload<ExtArgs>
        fields: Prisma.trust_poolsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trust_poolsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trust_poolsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>
          }
          findFirst: {
            args: Prisma.trust_poolsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trust_poolsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>
          }
          findMany: {
            args: Prisma.trust_poolsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>[]
          }
          create: {
            args: Prisma.trust_poolsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>
          }
          createMany: {
            args: Prisma.trust_poolsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.trust_poolsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>[]
          }
          delete: {
            args: Prisma.trust_poolsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>
          }
          update: {
            args: Prisma.trust_poolsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>
          }
          deleteMany: {
            args: Prisma.trust_poolsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trust_poolsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.trust_poolsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>[]
          }
          upsert: {
            args: Prisma.trust_poolsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trust_poolsPayload>
          }
          aggregate: {
            args: Prisma.Trust_poolsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrust_pools>
          }
          groupBy: {
            args: Prisma.trust_poolsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trust_poolsGroupByOutputType>[]
          }
          count: {
            args: Prisma.trust_poolsCountArgs<ExtArgs>
            result: $Utils.Optional<Trust_poolsCountAggregateOutputType> | number
          }
        }
      }
      user_stakes: {
        payload: Prisma.$user_stakesPayload<ExtArgs>
        fields: Prisma.user_stakesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_stakesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_stakesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>
          }
          findFirst: {
            args: Prisma.user_stakesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_stakesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>
          }
          findMany: {
            args: Prisma.user_stakesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>[]
          }
          create: {
            args: Prisma.user_stakesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>
          }
          createMany: {
            args: Prisma.user_stakesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_stakesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>[]
          }
          delete: {
            args: Prisma.user_stakesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>
          }
          update: {
            args: Prisma.user_stakesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>
          }
          deleteMany: {
            args: Prisma.user_stakesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_stakesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_stakesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>[]
          }
          upsert: {
            args: Prisma.user_stakesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_stakesPayload>
          }
          aggregate: {
            args: Prisma.User_stakesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_stakes>
          }
          groupBy: {
            args: Prisma.user_stakesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_stakesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_stakesCountArgs<ExtArgs>
            result: $Utils.Optional<User_stakesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      token_holders: {
        payload: Prisma.$token_holdersPayload<ExtArgs>
        fields: Prisma.token_holdersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.token_holdersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.token_holdersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>
          }
          findFirst: {
            args: Prisma.token_holdersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.token_holdersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>
          }
          findMany: {
            args: Prisma.token_holdersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>[]
          }
          create: {
            args: Prisma.token_holdersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>
          }
          createMany: {
            args: Prisma.token_holdersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.token_holdersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>[]
          }
          delete: {
            args: Prisma.token_holdersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>
          }
          update: {
            args: Prisma.token_holdersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>
          }
          deleteMany: {
            args: Prisma.token_holdersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.token_holdersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.token_holdersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>[]
          }
          upsert: {
            args: Prisma.token_holdersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$token_holdersPayload>
          }
          aggregate: {
            args: Prisma.Token_holdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken_holders>
          }
          groupBy: {
            args: Prisma.token_holdersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Token_holdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.token_holdersCountArgs<ExtArgs>
            result: $Utils.Optional<Token_holdersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    ammpair?: AmmpairOmit
    eventTracking?: EventTrackingOmit
    gameResult?: GameResultOmit
    poolsDB?: PoolsDBOmit
    tradeEvent?: TradeEventOmit
    vRFCallback?: VRFCallbackOmit
    block_progress?: block_progressOmit
    comments?: commentsOmit
    images?: imagesOmit
    likes?: likesOmit
    migration_events?: migration_eventsOmit
    protocol_stats?: protocol_statsOmit
    staking_pools?: staking_poolsOmit
    token_price_history?: token_price_historyOmit
    token_prices?: token_pricesOmit
    tokens?: tokensOmit
    trust_pools?: trust_poolsOmit
    user_stakes?: user_stakesOmit
    users?: usersOmit
    token_holders?: token_holdersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PoolsDBCountOutputType
   */

  export type PoolsDBCountOutputType = {
    comments: number
    holders: number
  }

  export type PoolsDBCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PoolsDBCountOutputTypeCountCommentsArgs
    holders?: boolean | PoolsDBCountOutputTypeCountHoldersArgs
  }

  // Custom InputTypes
  /**
   * PoolsDBCountOutputType without action
   */
  export type PoolsDBCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDBCountOutputType
     */
    select?: PoolsDBCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PoolsDBCountOutputType without action
   */
  export type PoolsDBCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * PoolsDBCountOutputType without action
   */
  export type PoolsDBCountOutputTypeCountHoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: token_holdersWhereInput
  }


  /**
   * Count Type CommentsCountOutputType
   */

  export type CommentsCountOutputType = {
    images: number
    likes: number
  }

  export type CommentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | CommentsCountOutputTypeCountImagesArgs
    likes?: boolean | CommentsCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentsCountOutputType
     */
    select?: CommentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
  }

  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: likesWhereInput
  }


  /**
   * Count Type Staking_poolsCountOutputType
   */

  export type Staking_poolsCountOutputType = {
    user_stakes: number
  }

  export type Staking_poolsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_stakes?: boolean | Staking_poolsCountOutputTypeCountUser_stakesArgs
  }

  // Custom InputTypes
  /**
   * Staking_poolsCountOutputType without action
   */
  export type Staking_poolsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staking_poolsCountOutputType
     */
    select?: Staking_poolsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Staking_poolsCountOutputType without action
   */
  export type Staking_poolsCountOutputTypeCountUser_stakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_stakesWhereInput
  }


  /**
   * Count Type TokensCountOutputType
   */

  export type TokensCountOutputType = {
    ammpairsAsToken0: number
    ammpairsAsToken1: number
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens: number
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens: number
  }

  export type TokensCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ammpairsAsToken0?: boolean | TokensCountOutputTypeCountAmmpairsAsToken0Args
    ammpairsAsToken1?: boolean | TokensCountOutputTypeCountAmmpairsAsToken1Args
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | TokensCountOutputTypeCountStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensArgs
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | TokensCountOutputTypeCountStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensArgs
  }

  // Custom InputTypes
  /**
   * TokensCountOutputType without action
   */
  export type TokensCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensCountOutputType
     */
    select?: TokensCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TokensCountOutputType without action
   */
  export type TokensCountOutputTypeCountAmmpairsAsToken0Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmmpairWhereInput
  }

  /**
   * TokensCountOutputType without action
   */
  export type TokensCountOutputTypeCountAmmpairsAsToken1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmmpairWhereInput
  }

  /**
   * TokensCountOutputType without action
   */
  export type TokensCountOutputTypeCountStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: staking_poolsWhereInput
  }

  /**
   * TokensCountOutputType without action
   */
  export type TokensCountOutputTypeCountStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: staking_poolsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    comments: number
    likes: number
    staking_pools: number
    user_stakes: number
    token_balances: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | UsersCountOutputTypeCountCommentsArgs
    likes?: boolean | UsersCountOutputTypeCountLikesArgs
    staking_pools?: boolean | UsersCountOutputTypeCountStaking_poolsArgs
    user_stakes?: boolean | UsersCountOutputTypeCountUser_stakesArgs
    token_balances?: boolean | UsersCountOutputTypeCountToken_balancesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: likesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStaking_poolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: staking_poolsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_stakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_stakesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountToken_balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: token_holdersWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Ammpair
   */

  export type AggregateAmmpair = {
    _count: AmmpairCountAggregateOutputType | null
    _avg: AmmpairAvgAggregateOutputType | null
    _sum: AmmpairSumAggregateOutputType | null
    _min: AmmpairMinAggregateOutputType | null
    _max: AmmpairMaxAggregateOutputType | null
  }

  export type AmmpairAvgAggregateOutputType = {
    id: number | null
    displayOrder: number | null
  }

  export type AmmpairSumAggregateOutputType = {
    id: number | null
    displayOrder: number | null
  }

  export type AmmpairMinAggregateOutputType = {
    id: number | null
    pair: string | null
    creator: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: $Enums.AmmVersion | null
    token0Address: string | null
    token1Address: string | null
    network: string | null
    token0Network: string | null
    token1Network: string | null
    verified: boolean | null
    displayOrder: number | null
    apr24h: string | null
    apr7d: string | null
    apyCalculated: string | null
    lastStatsUpdate: Date | null
    lpFeePercent: string | null
    reserve0: string | null
    reserve1: string | null
    tvlUsd: string | null
    volumeToken0_24h: string | null
    volumeToken1_24h: string | null
    volumeUsd24h: string | null
    volumeUsd7d: string | null
    volumeUsd30d: string | null
    feesUsd24h: string | null
    feesUsd7d: string | null
    feesUsd30d: string | null
  }

  export type AmmpairMaxAggregateOutputType = {
    id: number | null
    pair: string | null
    creator: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: $Enums.AmmVersion | null
    token0Address: string | null
    token1Address: string | null
    network: string | null
    token0Network: string | null
    token1Network: string | null
    verified: boolean | null
    displayOrder: number | null
    apr24h: string | null
    apr7d: string | null
    apyCalculated: string | null
    lastStatsUpdate: Date | null
    lpFeePercent: string | null
    reserve0: string | null
    reserve1: string | null
    tvlUsd: string | null
    volumeToken0_24h: string | null
    volumeToken1_24h: string | null
    volumeUsd24h: string | null
    volumeUsd7d: string | null
    volumeUsd30d: string | null
    feesUsd24h: string | null
    feesUsd7d: string | null
    feesUsd30d: string | null
  }

  export type AmmpairCountAggregateOutputType = {
    id: number
    pair: number
    creator: number
    createdAt: number
    updatedAt: number
    version: number
    token0Address: number
    token1Address: number
    network: number
    token0Network: number
    token1Network: number
    verified: number
    displayOrder: number
    apr24h: number
    apr7d: number
    apyCalculated: number
    lastStatsUpdate: number
    lpFeePercent: number
    reserve0: number
    reserve1: number
    tvlUsd: number
    volumeToken0_24h: number
    volumeToken1_24h: number
    volumeUsd24h: number
    volumeUsd7d: number
    volumeUsd30d: number
    feesUsd24h: number
    feesUsd7d: number
    feesUsd30d: number
    _all: number
  }


  export type AmmpairAvgAggregateInputType = {
    id?: true
    displayOrder?: true
  }

  export type AmmpairSumAggregateInputType = {
    id?: true
    displayOrder?: true
  }

  export type AmmpairMinAggregateInputType = {
    id?: true
    pair?: true
    creator?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    token0Address?: true
    token1Address?: true
    network?: true
    token0Network?: true
    token1Network?: true
    verified?: true
    displayOrder?: true
    apr24h?: true
    apr7d?: true
    apyCalculated?: true
    lastStatsUpdate?: true
    lpFeePercent?: true
    reserve0?: true
    reserve1?: true
    tvlUsd?: true
    volumeToken0_24h?: true
    volumeToken1_24h?: true
    volumeUsd24h?: true
    volumeUsd7d?: true
    volumeUsd30d?: true
    feesUsd24h?: true
    feesUsd7d?: true
    feesUsd30d?: true
  }

  export type AmmpairMaxAggregateInputType = {
    id?: true
    pair?: true
    creator?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    token0Address?: true
    token1Address?: true
    network?: true
    token0Network?: true
    token1Network?: true
    verified?: true
    displayOrder?: true
    apr24h?: true
    apr7d?: true
    apyCalculated?: true
    lastStatsUpdate?: true
    lpFeePercent?: true
    reserve0?: true
    reserve1?: true
    tvlUsd?: true
    volumeToken0_24h?: true
    volumeToken1_24h?: true
    volumeUsd24h?: true
    volumeUsd7d?: true
    volumeUsd30d?: true
    feesUsd24h?: true
    feesUsd7d?: true
    feesUsd30d?: true
  }

  export type AmmpairCountAggregateInputType = {
    id?: true
    pair?: true
    creator?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    token0Address?: true
    token1Address?: true
    network?: true
    token0Network?: true
    token1Network?: true
    verified?: true
    displayOrder?: true
    apr24h?: true
    apr7d?: true
    apyCalculated?: true
    lastStatsUpdate?: true
    lpFeePercent?: true
    reserve0?: true
    reserve1?: true
    tvlUsd?: true
    volumeToken0_24h?: true
    volumeToken1_24h?: true
    volumeUsd24h?: true
    volumeUsd7d?: true
    volumeUsd30d?: true
    feesUsd24h?: true
    feesUsd7d?: true
    feesUsd30d?: true
    _all?: true
  }

  export type AmmpairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ammpair to aggregate.
     */
    where?: AmmpairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ammpairs to fetch.
     */
    orderBy?: AmmpairOrderByWithRelationInput | AmmpairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmmpairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ammpairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ammpairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ammpairs
    **/
    _count?: true | AmmpairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmmpairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmmpairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmmpairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmmpairMaxAggregateInputType
  }

  export type GetAmmpairAggregateType<T extends AmmpairAggregateArgs> = {
        [P in keyof T & keyof AggregateAmmpair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmmpair[P]>
      : GetScalarType<T[P], AggregateAmmpair[P]>
  }




  export type AmmpairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmmpairWhereInput
    orderBy?: AmmpairOrderByWithAggregationInput | AmmpairOrderByWithAggregationInput[]
    by: AmmpairScalarFieldEnum[] | AmmpairScalarFieldEnum
    having?: AmmpairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmmpairCountAggregateInputType | true
    _avg?: AmmpairAvgAggregateInputType
    _sum?: AmmpairSumAggregateInputType
    _min?: AmmpairMinAggregateInputType
    _max?: AmmpairMaxAggregateInputType
  }

  export type AmmpairGroupByOutputType = {
    id: number
    pair: string
    creator: string
    createdAt: Date
    updatedAt: Date
    version: $Enums.AmmVersion
    token0Address: string
    token1Address: string
    network: string
    token0Network: string
    token1Network: string
    verified: boolean
    displayOrder: number | null
    apr24h: string | null
    apr7d: string | null
    apyCalculated: string | null
    lastStatsUpdate: Date | null
    lpFeePercent: string | null
    reserve0: string | null
    reserve1: string | null
    tvlUsd: string | null
    volumeToken0_24h: string | null
    volumeToken1_24h: string | null
    volumeUsd24h: string | null
    volumeUsd7d: string | null
    volumeUsd30d: string | null
    feesUsd24h: string | null
    feesUsd7d: string | null
    feesUsd30d: string | null
    _count: AmmpairCountAggregateOutputType | null
    _avg: AmmpairAvgAggregateOutputType | null
    _sum: AmmpairSumAggregateOutputType | null
    _min: AmmpairMinAggregateOutputType | null
    _max: AmmpairMaxAggregateOutputType | null
  }

  type GetAmmpairGroupByPayload<T extends AmmpairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmmpairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmmpairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmmpairGroupByOutputType[P]>
            : GetScalarType<T[P], AmmpairGroupByOutputType[P]>
        }
      >
    >


  export type AmmpairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pair?: boolean
    creator?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    token0Address?: boolean
    token1Address?: boolean
    network?: boolean
    token0Network?: boolean
    token1Network?: boolean
    verified?: boolean
    displayOrder?: boolean
    apr24h?: boolean
    apr7d?: boolean
    apyCalculated?: boolean
    lastStatsUpdate?: boolean
    lpFeePercent?: boolean
    reserve0?: boolean
    reserve1?: boolean
    tvlUsd?: boolean
    volumeToken0_24h?: boolean
    volumeToken1_24h?: boolean
    volumeUsd24h?: boolean
    volumeUsd7d?: boolean
    volumeUsd30d?: boolean
    feesUsd24h?: boolean
    feesUsd7d?: boolean
    feesUsd30d?: boolean
    token0?: boolean | tokensDefaultArgs<ExtArgs>
    token1?: boolean | tokensDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ammpair"]>

  export type AmmpairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pair?: boolean
    creator?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    token0Address?: boolean
    token1Address?: boolean
    network?: boolean
    token0Network?: boolean
    token1Network?: boolean
    verified?: boolean
    displayOrder?: boolean
    apr24h?: boolean
    apr7d?: boolean
    apyCalculated?: boolean
    lastStatsUpdate?: boolean
    lpFeePercent?: boolean
    reserve0?: boolean
    reserve1?: boolean
    tvlUsd?: boolean
    volumeToken0_24h?: boolean
    volumeToken1_24h?: boolean
    volumeUsd24h?: boolean
    volumeUsd7d?: boolean
    volumeUsd30d?: boolean
    feesUsd24h?: boolean
    feesUsd7d?: boolean
    feesUsd30d?: boolean
    token0?: boolean | tokensDefaultArgs<ExtArgs>
    token1?: boolean | tokensDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ammpair"]>

  export type AmmpairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pair?: boolean
    creator?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    token0Address?: boolean
    token1Address?: boolean
    network?: boolean
    token0Network?: boolean
    token1Network?: boolean
    verified?: boolean
    displayOrder?: boolean
    apr24h?: boolean
    apr7d?: boolean
    apyCalculated?: boolean
    lastStatsUpdate?: boolean
    lpFeePercent?: boolean
    reserve0?: boolean
    reserve1?: boolean
    tvlUsd?: boolean
    volumeToken0_24h?: boolean
    volumeToken1_24h?: boolean
    volumeUsd24h?: boolean
    volumeUsd7d?: boolean
    volumeUsd30d?: boolean
    feesUsd24h?: boolean
    feesUsd7d?: boolean
    feesUsd30d?: boolean
    token0?: boolean | tokensDefaultArgs<ExtArgs>
    token1?: boolean | tokensDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ammpair"]>

  export type AmmpairSelectScalar = {
    id?: boolean
    pair?: boolean
    creator?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    token0Address?: boolean
    token1Address?: boolean
    network?: boolean
    token0Network?: boolean
    token1Network?: boolean
    verified?: boolean
    displayOrder?: boolean
    apr24h?: boolean
    apr7d?: boolean
    apyCalculated?: boolean
    lastStatsUpdate?: boolean
    lpFeePercent?: boolean
    reserve0?: boolean
    reserve1?: boolean
    tvlUsd?: boolean
    volumeToken0_24h?: boolean
    volumeToken1_24h?: boolean
    volumeUsd24h?: boolean
    volumeUsd7d?: boolean
    volumeUsd30d?: boolean
    feesUsd24h?: boolean
    feesUsd7d?: boolean
    feesUsd30d?: boolean
  }

  export type AmmpairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pair" | "creator" | "createdAt" | "updatedAt" | "version" | "token0Address" | "token1Address" | "network" | "token0Network" | "token1Network" | "verified" | "displayOrder" | "apr24h" | "apr7d" | "apyCalculated" | "lastStatsUpdate" | "lpFeePercent" | "reserve0" | "reserve1" | "tvlUsd" | "volumeToken0_24h" | "volumeToken1_24h" | "volumeUsd24h" | "volumeUsd7d" | "volumeUsd30d" | "feesUsd24h" | "feesUsd7d" | "feesUsd30d", ExtArgs["result"]["ammpair"]>
  export type AmmpairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token0?: boolean | tokensDefaultArgs<ExtArgs>
    token1?: boolean | tokensDefaultArgs<ExtArgs>
  }
  export type AmmpairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token0?: boolean | tokensDefaultArgs<ExtArgs>
    token1?: boolean | tokensDefaultArgs<ExtArgs>
  }
  export type AmmpairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token0?: boolean | tokensDefaultArgs<ExtArgs>
    token1?: boolean | tokensDefaultArgs<ExtArgs>
  }

  export type $AmmpairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ammpair"
    objects: {
      token0: Prisma.$tokensPayload<ExtArgs>
      token1: Prisma.$tokensPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pair: string
      creator: string
      createdAt: Date
      updatedAt: Date
      version: $Enums.AmmVersion
      token0Address: string
      token1Address: string
      network: string
      token0Network: string
      token1Network: string
      verified: boolean
      displayOrder: number | null
      apr24h: string | null
      apr7d: string | null
      apyCalculated: string | null
      lastStatsUpdate: Date | null
      lpFeePercent: string | null
      reserve0: string | null
      reserve1: string | null
      tvlUsd: string | null
      volumeToken0_24h: string | null
      volumeToken1_24h: string | null
      volumeUsd24h: string | null
      volumeUsd7d: string | null
      volumeUsd30d: string | null
      feesUsd24h: string | null
      feesUsd7d: string | null
      feesUsd30d: string | null
    }, ExtArgs["result"]["ammpair"]>
    composites: {}
  }

  type AmmpairGetPayload<S extends boolean | null | undefined | AmmpairDefaultArgs> = $Result.GetResult<Prisma.$AmmpairPayload, S>

  type AmmpairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmmpairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmmpairCountAggregateInputType | true
    }

  export interface AmmpairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ammpair'], meta: { name: 'Ammpair' } }
    /**
     * Find zero or one Ammpair that matches the filter.
     * @param {AmmpairFindUniqueArgs} args - Arguments to find a Ammpair
     * @example
     * // Get one Ammpair
     * const ammpair = await prisma.ammpair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmmpairFindUniqueArgs>(args: SelectSubset<T, AmmpairFindUniqueArgs<ExtArgs>>): Prisma__AmmpairClient<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ammpair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmmpairFindUniqueOrThrowArgs} args - Arguments to find a Ammpair
     * @example
     * // Get one Ammpair
     * const ammpair = await prisma.ammpair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmmpairFindUniqueOrThrowArgs>(args: SelectSubset<T, AmmpairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmmpairClient<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ammpair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmpairFindFirstArgs} args - Arguments to find a Ammpair
     * @example
     * // Get one Ammpair
     * const ammpair = await prisma.ammpair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmmpairFindFirstArgs>(args?: SelectSubset<T, AmmpairFindFirstArgs<ExtArgs>>): Prisma__AmmpairClient<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ammpair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmpairFindFirstOrThrowArgs} args - Arguments to find a Ammpair
     * @example
     * // Get one Ammpair
     * const ammpair = await prisma.ammpair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmmpairFindFirstOrThrowArgs>(args?: SelectSubset<T, AmmpairFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmmpairClient<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ammpairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmpairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ammpairs
     * const ammpairs = await prisma.ammpair.findMany()
     * 
     * // Get first 10 Ammpairs
     * const ammpairs = await prisma.ammpair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ammpairWithIdOnly = await prisma.ammpair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmmpairFindManyArgs>(args?: SelectSubset<T, AmmpairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ammpair.
     * @param {AmmpairCreateArgs} args - Arguments to create a Ammpair.
     * @example
     * // Create one Ammpair
     * const Ammpair = await prisma.ammpair.create({
     *   data: {
     *     // ... data to create a Ammpair
     *   }
     * })
     * 
     */
    create<T extends AmmpairCreateArgs>(args: SelectSubset<T, AmmpairCreateArgs<ExtArgs>>): Prisma__AmmpairClient<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ammpairs.
     * @param {AmmpairCreateManyArgs} args - Arguments to create many Ammpairs.
     * @example
     * // Create many Ammpairs
     * const ammpair = await prisma.ammpair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmmpairCreateManyArgs>(args?: SelectSubset<T, AmmpairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ammpairs and returns the data saved in the database.
     * @param {AmmpairCreateManyAndReturnArgs} args - Arguments to create many Ammpairs.
     * @example
     * // Create many Ammpairs
     * const ammpair = await prisma.ammpair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ammpairs and only return the `id`
     * const ammpairWithIdOnly = await prisma.ammpair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmmpairCreateManyAndReturnArgs>(args?: SelectSubset<T, AmmpairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ammpair.
     * @param {AmmpairDeleteArgs} args - Arguments to delete one Ammpair.
     * @example
     * // Delete one Ammpair
     * const Ammpair = await prisma.ammpair.delete({
     *   where: {
     *     // ... filter to delete one Ammpair
     *   }
     * })
     * 
     */
    delete<T extends AmmpairDeleteArgs>(args: SelectSubset<T, AmmpairDeleteArgs<ExtArgs>>): Prisma__AmmpairClient<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ammpair.
     * @param {AmmpairUpdateArgs} args - Arguments to update one Ammpair.
     * @example
     * // Update one Ammpair
     * const ammpair = await prisma.ammpair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmmpairUpdateArgs>(args: SelectSubset<T, AmmpairUpdateArgs<ExtArgs>>): Prisma__AmmpairClient<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ammpairs.
     * @param {AmmpairDeleteManyArgs} args - Arguments to filter Ammpairs to delete.
     * @example
     * // Delete a few Ammpairs
     * const { count } = await prisma.ammpair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmmpairDeleteManyArgs>(args?: SelectSubset<T, AmmpairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ammpairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmpairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ammpairs
     * const ammpair = await prisma.ammpair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmmpairUpdateManyArgs>(args: SelectSubset<T, AmmpairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ammpairs and returns the data updated in the database.
     * @param {AmmpairUpdateManyAndReturnArgs} args - Arguments to update many Ammpairs.
     * @example
     * // Update many Ammpairs
     * const ammpair = await prisma.ammpair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ammpairs and only return the `id`
     * const ammpairWithIdOnly = await prisma.ammpair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmmpairUpdateManyAndReturnArgs>(args: SelectSubset<T, AmmpairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ammpair.
     * @param {AmmpairUpsertArgs} args - Arguments to update or create a Ammpair.
     * @example
     * // Update or create a Ammpair
     * const ammpair = await prisma.ammpair.upsert({
     *   create: {
     *     // ... data to create a Ammpair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ammpair we want to update
     *   }
     * })
     */
    upsert<T extends AmmpairUpsertArgs>(args: SelectSubset<T, AmmpairUpsertArgs<ExtArgs>>): Prisma__AmmpairClient<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ammpairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmpairCountArgs} args - Arguments to filter Ammpairs to count.
     * @example
     * // Count the number of Ammpairs
     * const count = await prisma.ammpair.count({
     *   where: {
     *     // ... the filter for the Ammpairs we want to count
     *   }
     * })
    **/
    count<T extends AmmpairCountArgs>(
      args?: Subset<T, AmmpairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmmpairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ammpair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmpairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmmpairAggregateArgs>(args: Subset<T, AmmpairAggregateArgs>): Prisma.PrismaPromise<GetAmmpairAggregateType<T>>

    /**
     * Group by Ammpair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmpairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmmpairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmmpairGroupByArgs['orderBy'] }
        : { orderBy?: AmmpairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmmpairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmmpairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ammpair model
   */
  readonly fields: AmmpairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ammpair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmmpairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token0<T extends tokensDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tokensDefaultArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    token1<T extends tokensDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tokensDefaultArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ammpair model
   */
  interface AmmpairFieldRefs {
    readonly id: FieldRef<"Ammpair", 'Int'>
    readonly pair: FieldRef<"Ammpair", 'String'>
    readonly creator: FieldRef<"Ammpair", 'String'>
    readonly createdAt: FieldRef<"Ammpair", 'DateTime'>
    readonly updatedAt: FieldRef<"Ammpair", 'DateTime'>
    readonly version: FieldRef<"Ammpair", 'AmmVersion'>
    readonly token0Address: FieldRef<"Ammpair", 'String'>
    readonly token1Address: FieldRef<"Ammpair", 'String'>
    readonly network: FieldRef<"Ammpair", 'String'>
    readonly token0Network: FieldRef<"Ammpair", 'String'>
    readonly token1Network: FieldRef<"Ammpair", 'String'>
    readonly verified: FieldRef<"Ammpair", 'Boolean'>
    readonly displayOrder: FieldRef<"Ammpair", 'Int'>
    readonly apr24h: FieldRef<"Ammpair", 'String'>
    readonly apr7d: FieldRef<"Ammpair", 'String'>
    readonly apyCalculated: FieldRef<"Ammpair", 'String'>
    readonly lastStatsUpdate: FieldRef<"Ammpair", 'DateTime'>
    readonly lpFeePercent: FieldRef<"Ammpair", 'String'>
    readonly reserve0: FieldRef<"Ammpair", 'String'>
    readonly reserve1: FieldRef<"Ammpair", 'String'>
    readonly tvlUsd: FieldRef<"Ammpair", 'String'>
    readonly volumeToken0_24h: FieldRef<"Ammpair", 'String'>
    readonly volumeToken1_24h: FieldRef<"Ammpair", 'String'>
    readonly volumeUsd24h: FieldRef<"Ammpair", 'String'>
    readonly volumeUsd7d: FieldRef<"Ammpair", 'String'>
    readonly volumeUsd30d: FieldRef<"Ammpair", 'String'>
    readonly feesUsd24h: FieldRef<"Ammpair", 'String'>
    readonly feesUsd7d: FieldRef<"Ammpair", 'String'>
    readonly feesUsd30d: FieldRef<"Ammpair", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ammpair findUnique
   */
  export type AmmpairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * Filter, which Ammpair to fetch.
     */
    where: AmmpairWhereUniqueInput
  }

  /**
   * Ammpair findUniqueOrThrow
   */
  export type AmmpairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * Filter, which Ammpair to fetch.
     */
    where: AmmpairWhereUniqueInput
  }

  /**
   * Ammpair findFirst
   */
  export type AmmpairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * Filter, which Ammpair to fetch.
     */
    where?: AmmpairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ammpairs to fetch.
     */
    orderBy?: AmmpairOrderByWithRelationInput | AmmpairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ammpairs.
     */
    cursor?: AmmpairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ammpairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ammpairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ammpairs.
     */
    distinct?: AmmpairScalarFieldEnum | AmmpairScalarFieldEnum[]
  }

  /**
   * Ammpair findFirstOrThrow
   */
  export type AmmpairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * Filter, which Ammpair to fetch.
     */
    where?: AmmpairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ammpairs to fetch.
     */
    orderBy?: AmmpairOrderByWithRelationInput | AmmpairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ammpairs.
     */
    cursor?: AmmpairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ammpairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ammpairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ammpairs.
     */
    distinct?: AmmpairScalarFieldEnum | AmmpairScalarFieldEnum[]
  }

  /**
   * Ammpair findMany
   */
  export type AmmpairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * Filter, which Ammpairs to fetch.
     */
    where?: AmmpairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ammpairs to fetch.
     */
    orderBy?: AmmpairOrderByWithRelationInput | AmmpairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ammpairs.
     */
    cursor?: AmmpairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ammpairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ammpairs.
     */
    skip?: number
    distinct?: AmmpairScalarFieldEnum | AmmpairScalarFieldEnum[]
  }

  /**
   * Ammpair create
   */
  export type AmmpairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * The data needed to create a Ammpair.
     */
    data: XOR<AmmpairCreateInput, AmmpairUncheckedCreateInput>
  }

  /**
   * Ammpair createMany
   */
  export type AmmpairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ammpairs.
     */
    data: AmmpairCreateManyInput | AmmpairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ammpair createManyAndReturn
   */
  export type AmmpairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * The data used to create many Ammpairs.
     */
    data: AmmpairCreateManyInput | AmmpairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ammpair update
   */
  export type AmmpairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * The data needed to update a Ammpair.
     */
    data: XOR<AmmpairUpdateInput, AmmpairUncheckedUpdateInput>
    /**
     * Choose, which Ammpair to update.
     */
    where: AmmpairWhereUniqueInput
  }

  /**
   * Ammpair updateMany
   */
  export type AmmpairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ammpairs.
     */
    data: XOR<AmmpairUpdateManyMutationInput, AmmpairUncheckedUpdateManyInput>
    /**
     * Filter which Ammpairs to update
     */
    where?: AmmpairWhereInput
    /**
     * Limit how many Ammpairs to update.
     */
    limit?: number
  }

  /**
   * Ammpair updateManyAndReturn
   */
  export type AmmpairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * The data used to update Ammpairs.
     */
    data: XOR<AmmpairUpdateManyMutationInput, AmmpairUncheckedUpdateManyInput>
    /**
     * Filter which Ammpairs to update
     */
    where?: AmmpairWhereInput
    /**
     * Limit how many Ammpairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ammpair upsert
   */
  export type AmmpairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * The filter to search for the Ammpair to update in case it exists.
     */
    where: AmmpairWhereUniqueInput
    /**
     * In case the Ammpair found by the `where` argument doesn't exist, create a new Ammpair with this data.
     */
    create: XOR<AmmpairCreateInput, AmmpairUncheckedCreateInput>
    /**
     * In case the Ammpair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmmpairUpdateInput, AmmpairUncheckedUpdateInput>
  }

  /**
   * Ammpair delete
   */
  export type AmmpairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    /**
     * Filter which Ammpair to delete.
     */
    where: AmmpairWhereUniqueInput
  }

  /**
   * Ammpair deleteMany
   */
  export type AmmpairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ammpairs to delete
     */
    where?: AmmpairWhereInput
    /**
     * Limit how many Ammpairs to delete.
     */
    limit?: number
  }

  /**
   * Ammpair without action
   */
  export type AmmpairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
  }


  /**
   * Model EventTracking
   */

  export type AggregateEventTracking = {
    _count: EventTrackingCountAggregateOutputType | null
    _avg: EventTrackingAvgAggregateOutputType | null
    _sum: EventTrackingSumAggregateOutputType | null
    _min: EventTrackingMinAggregateOutputType | null
    _max: EventTrackingMaxAggregateOutputType | null
  }

  export type EventTrackingAvgAggregateOutputType = {
    id: number | null
    blockHeight: number | null
  }

  export type EventTrackingSumAggregateOutputType = {
    id: number | null
    blockHeight: bigint | null
  }

  export type EventTrackingMinAggregateOutputType = {
    id: number | null
    eventType: string | null
    blockHeight: bigint | null
    transactionHash: string | null
    processed: boolean | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
    sequenceNumber: string | null
  }

  export type EventTrackingMaxAggregateOutputType = {
    id: number | null
    eventType: string | null
    blockHeight: bigint | null
    transactionHash: string | null
    processed: boolean | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
    sequenceNumber: string | null
  }

  export type EventTrackingCountAggregateOutputType = {
    id: number
    eventType: number
    blockHeight: number
    transactionHash: number
    processed: number
    error: number
    createdAt: number
    updatedAt: number
    network: number
    sequenceNumber: number
    _all: number
  }


  export type EventTrackingAvgAggregateInputType = {
    id?: true
    blockHeight?: true
  }

  export type EventTrackingSumAggregateInputType = {
    id?: true
    blockHeight?: true
  }

  export type EventTrackingMinAggregateInputType = {
    id?: true
    eventType?: true
    blockHeight?: true
    transactionHash?: true
    processed?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    sequenceNumber?: true
  }

  export type EventTrackingMaxAggregateInputType = {
    id?: true
    eventType?: true
    blockHeight?: true
    transactionHash?: true
    processed?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    sequenceNumber?: true
  }

  export type EventTrackingCountAggregateInputType = {
    id?: true
    eventType?: true
    blockHeight?: true
    transactionHash?: true
    processed?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    sequenceNumber?: true
    _all?: true
  }

  export type EventTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTracking to aggregate.
     */
    where?: EventTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTrackings to fetch.
     */
    orderBy?: EventTrackingOrderByWithRelationInput | EventTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventTrackings
    **/
    _count?: true | EventTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventTrackingMaxAggregateInputType
  }

  export type GetEventTrackingAggregateType<T extends EventTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateEventTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventTracking[P]>
      : GetScalarType<T[P], AggregateEventTracking[P]>
  }




  export type EventTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTrackingWhereInput
    orderBy?: EventTrackingOrderByWithAggregationInput | EventTrackingOrderByWithAggregationInput[]
    by: EventTrackingScalarFieldEnum[] | EventTrackingScalarFieldEnum
    having?: EventTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventTrackingCountAggregateInputType | true
    _avg?: EventTrackingAvgAggregateInputType
    _sum?: EventTrackingSumAggregateInputType
    _min?: EventTrackingMinAggregateInputType
    _max?: EventTrackingMaxAggregateInputType
  }

  export type EventTrackingGroupByOutputType = {
    id: number
    eventType: string
    blockHeight: bigint
    transactionHash: string
    processed: boolean
    error: string | null
    createdAt: Date
    updatedAt: Date
    network: string
    sequenceNumber: string | null
    _count: EventTrackingCountAggregateOutputType | null
    _avg: EventTrackingAvgAggregateOutputType | null
    _sum: EventTrackingSumAggregateOutputType | null
    _min: EventTrackingMinAggregateOutputType | null
    _max: EventTrackingMaxAggregateOutputType | null
  }

  type GetEventTrackingGroupByPayload<T extends EventTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], EventTrackingGroupByOutputType[P]>
        }
      >
    >


  export type EventTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    blockHeight?: boolean
    transactionHash?: boolean
    processed?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    sequenceNumber?: boolean
  }, ExtArgs["result"]["eventTracking"]>

  export type EventTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    blockHeight?: boolean
    transactionHash?: boolean
    processed?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    sequenceNumber?: boolean
  }, ExtArgs["result"]["eventTracking"]>

  export type EventTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    blockHeight?: boolean
    transactionHash?: boolean
    processed?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    sequenceNumber?: boolean
  }, ExtArgs["result"]["eventTracking"]>

  export type EventTrackingSelectScalar = {
    id?: boolean
    eventType?: boolean
    blockHeight?: boolean
    transactionHash?: boolean
    processed?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    sequenceNumber?: boolean
  }

  export type EventTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "blockHeight" | "transactionHash" | "processed" | "error" | "createdAt" | "updatedAt" | "network" | "sequenceNumber", ExtArgs["result"]["eventTracking"]>

  export type $EventTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventTracking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      eventType: string
      blockHeight: bigint
      transactionHash: string
      processed: boolean
      error: string | null
      createdAt: Date
      updatedAt: Date
      network: string
      sequenceNumber: string | null
    }, ExtArgs["result"]["eventTracking"]>
    composites: {}
  }

  type EventTrackingGetPayload<S extends boolean | null | undefined | EventTrackingDefaultArgs> = $Result.GetResult<Prisma.$EventTrackingPayload, S>

  type EventTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventTrackingCountAggregateInputType | true
    }

  export interface EventTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventTracking'], meta: { name: 'EventTracking' } }
    /**
     * Find zero or one EventTracking that matches the filter.
     * @param {EventTrackingFindUniqueArgs} args - Arguments to find a EventTracking
     * @example
     * // Get one EventTracking
     * const eventTracking = await prisma.eventTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventTrackingFindUniqueArgs>(args: SelectSubset<T, EventTrackingFindUniqueArgs<ExtArgs>>): Prisma__EventTrackingClient<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventTrackingFindUniqueOrThrowArgs} args - Arguments to find a EventTracking
     * @example
     * // Get one EventTracking
     * const eventTracking = await prisma.eventTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, EventTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventTrackingClient<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTrackingFindFirstArgs} args - Arguments to find a EventTracking
     * @example
     * // Get one EventTracking
     * const eventTracking = await prisma.eventTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventTrackingFindFirstArgs>(args?: SelectSubset<T, EventTrackingFindFirstArgs<ExtArgs>>): Prisma__EventTrackingClient<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTrackingFindFirstOrThrowArgs} args - Arguments to find a EventTracking
     * @example
     * // Get one EventTracking
     * const eventTracking = await prisma.eventTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, EventTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventTrackingClient<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventTrackings
     * const eventTrackings = await prisma.eventTracking.findMany()
     * 
     * // Get first 10 EventTrackings
     * const eventTrackings = await prisma.eventTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventTrackingWithIdOnly = await prisma.eventTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventTrackingFindManyArgs>(args?: SelectSubset<T, EventTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventTracking.
     * @param {EventTrackingCreateArgs} args - Arguments to create a EventTracking.
     * @example
     * // Create one EventTracking
     * const EventTracking = await prisma.eventTracking.create({
     *   data: {
     *     // ... data to create a EventTracking
     *   }
     * })
     * 
     */
    create<T extends EventTrackingCreateArgs>(args: SelectSubset<T, EventTrackingCreateArgs<ExtArgs>>): Prisma__EventTrackingClient<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventTrackings.
     * @param {EventTrackingCreateManyArgs} args - Arguments to create many EventTrackings.
     * @example
     * // Create many EventTrackings
     * const eventTracking = await prisma.eventTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventTrackingCreateManyArgs>(args?: SelectSubset<T, EventTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventTrackings and returns the data saved in the database.
     * @param {EventTrackingCreateManyAndReturnArgs} args - Arguments to create many EventTrackings.
     * @example
     * // Create many EventTrackings
     * const eventTracking = await prisma.eventTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventTrackings and only return the `id`
     * const eventTrackingWithIdOnly = await prisma.eventTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, EventTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventTracking.
     * @param {EventTrackingDeleteArgs} args - Arguments to delete one EventTracking.
     * @example
     * // Delete one EventTracking
     * const EventTracking = await prisma.eventTracking.delete({
     *   where: {
     *     // ... filter to delete one EventTracking
     *   }
     * })
     * 
     */
    delete<T extends EventTrackingDeleteArgs>(args: SelectSubset<T, EventTrackingDeleteArgs<ExtArgs>>): Prisma__EventTrackingClient<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventTracking.
     * @param {EventTrackingUpdateArgs} args - Arguments to update one EventTracking.
     * @example
     * // Update one EventTracking
     * const eventTracking = await prisma.eventTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventTrackingUpdateArgs>(args: SelectSubset<T, EventTrackingUpdateArgs<ExtArgs>>): Prisma__EventTrackingClient<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventTrackings.
     * @param {EventTrackingDeleteManyArgs} args - Arguments to filter EventTrackings to delete.
     * @example
     * // Delete a few EventTrackings
     * const { count } = await prisma.eventTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventTrackingDeleteManyArgs>(args?: SelectSubset<T, EventTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventTrackings
     * const eventTracking = await prisma.eventTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventTrackingUpdateManyArgs>(args: SelectSubset<T, EventTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTrackings and returns the data updated in the database.
     * @param {EventTrackingUpdateManyAndReturnArgs} args - Arguments to update many EventTrackings.
     * @example
     * // Update many EventTrackings
     * const eventTracking = await prisma.eventTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventTrackings and only return the `id`
     * const eventTrackingWithIdOnly = await prisma.eventTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, EventTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventTracking.
     * @param {EventTrackingUpsertArgs} args - Arguments to update or create a EventTracking.
     * @example
     * // Update or create a EventTracking
     * const eventTracking = await prisma.eventTracking.upsert({
     *   create: {
     *     // ... data to create a EventTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventTracking we want to update
     *   }
     * })
     */
    upsert<T extends EventTrackingUpsertArgs>(args: SelectSubset<T, EventTrackingUpsertArgs<ExtArgs>>): Prisma__EventTrackingClient<$Result.GetResult<Prisma.$EventTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTrackingCountArgs} args - Arguments to filter EventTrackings to count.
     * @example
     * // Count the number of EventTrackings
     * const count = await prisma.eventTracking.count({
     *   where: {
     *     // ... the filter for the EventTrackings we want to count
     *   }
     * })
    **/
    count<T extends EventTrackingCountArgs>(
      args?: Subset<T, EventTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventTrackingAggregateArgs>(args: Subset<T, EventTrackingAggregateArgs>): Prisma.PrismaPromise<GetEventTrackingAggregateType<T>>

    /**
     * Group by EventTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventTrackingGroupByArgs['orderBy'] }
        : { orderBy?: EventTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventTracking model
   */
  readonly fields: EventTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventTracking model
   */
  interface EventTrackingFieldRefs {
    readonly id: FieldRef<"EventTracking", 'Int'>
    readonly eventType: FieldRef<"EventTracking", 'String'>
    readonly blockHeight: FieldRef<"EventTracking", 'BigInt'>
    readonly transactionHash: FieldRef<"EventTracking", 'String'>
    readonly processed: FieldRef<"EventTracking", 'Boolean'>
    readonly error: FieldRef<"EventTracking", 'String'>
    readonly createdAt: FieldRef<"EventTracking", 'DateTime'>
    readonly updatedAt: FieldRef<"EventTracking", 'DateTime'>
    readonly network: FieldRef<"EventTracking", 'String'>
    readonly sequenceNumber: FieldRef<"EventTracking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EventTracking findUnique
   */
  export type EventTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * Filter, which EventTracking to fetch.
     */
    where: EventTrackingWhereUniqueInput
  }

  /**
   * EventTracking findUniqueOrThrow
   */
  export type EventTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * Filter, which EventTracking to fetch.
     */
    where: EventTrackingWhereUniqueInput
  }

  /**
   * EventTracking findFirst
   */
  export type EventTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * Filter, which EventTracking to fetch.
     */
    where?: EventTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTrackings to fetch.
     */
    orderBy?: EventTrackingOrderByWithRelationInput | EventTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTrackings.
     */
    cursor?: EventTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTrackings.
     */
    distinct?: EventTrackingScalarFieldEnum | EventTrackingScalarFieldEnum[]
  }

  /**
   * EventTracking findFirstOrThrow
   */
  export type EventTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * Filter, which EventTracking to fetch.
     */
    where?: EventTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTrackings to fetch.
     */
    orderBy?: EventTrackingOrderByWithRelationInput | EventTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTrackings.
     */
    cursor?: EventTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTrackings.
     */
    distinct?: EventTrackingScalarFieldEnum | EventTrackingScalarFieldEnum[]
  }

  /**
   * EventTracking findMany
   */
  export type EventTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * Filter, which EventTrackings to fetch.
     */
    where?: EventTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTrackings to fetch.
     */
    orderBy?: EventTrackingOrderByWithRelationInput | EventTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventTrackings.
     */
    cursor?: EventTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTrackings.
     */
    skip?: number
    distinct?: EventTrackingScalarFieldEnum | EventTrackingScalarFieldEnum[]
  }

  /**
   * EventTracking create
   */
  export type EventTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * The data needed to create a EventTracking.
     */
    data: XOR<EventTrackingCreateInput, EventTrackingUncheckedCreateInput>
  }

  /**
   * EventTracking createMany
   */
  export type EventTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventTrackings.
     */
    data: EventTrackingCreateManyInput | EventTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventTracking createManyAndReturn
   */
  export type EventTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many EventTrackings.
     */
    data: EventTrackingCreateManyInput | EventTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventTracking update
   */
  export type EventTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * The data needed to update a EventTracking.
     */
    data: XOR<EventTrackingUpdateInput, EventTrackingUncheckedUpdateInput>
    /**
     * Choose, which EventTracking to update.
     */
    where: EventTrackingWhereUniqueInput
  }

  /**
   * EventTracking updateMany
   */
  export type EventTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventTrackings.
     */
    data: XOR<EventTrackingUpdateManyMutationInput, EventTrackingUncheckedUpdateManyInput>
    /**
     * Filter which EventTrackings to update
     */
    where?: EventTrackingWhereInput
    /**
     * Limit how many EventTrackings to update.
     */
    limit?: number
  }

  /**
   * EventTracking updateManyAndReturn
   */
  export type EventTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * The data used to update EventTrackings.
     */
    data: XOR<EventTrackingUpdateManyMutationInput, EventTrackingUncheckedUpdateManyInput>
    /**
     * Filter which EventTrackings to update
     */
    where?: EventTrackingWhereInput
    /**
     * Limit how many EventTrackings to update.
     */
    limit?: number
  }

  /**
   * EventTracking upsert
   */
  export type EventTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * The filter to search for the EventTracking to update in case it exists.
     */
    where: EventTrackingWhereUniqueInput
    /**
     * In case the EventTracking found by the `where` argument doesn't exist, create a new EventTracking with this data.
     */
    create: XOR<EventTrackingCreateInput, EventTrackingUncheckedCreateInput>
    /**
     * In case the EventTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventTrackingUpdateInput, EventTrackingUncheckedUpdateInput>
  }

  /**
   * EventTracking delete
   */
  export type EventTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
    /**
     * Filter which EventTracking to delete.
     */
    where: EventTrackingWhereUniqueInput
  }

  /**
   * EventTracking deleteMany
   */
  export type EventTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTrackings to delete
     */
    where?: EventTrackingWhereInput
    /**
     * Limit how many EventTrackings to delete.
     */
    limit?: number
  }

  /**
   * EventTracking without action
   */
  export type EventTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTracking
     */
    select?: EventTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTracking
     */
    omit?: EventTrackingOmit<ExtArgs> | null
  }


  /**
   * Model GameResult
   */

  export type AggregateGameResult = {
    _count: GameResultCountAggregateOutputType | null
    _avg: GameResultAvgAggregateOutputType | null
    _sum: GameResultSumAggregateOutputType | null
    _min: GameResultMinAggregateOutputType | null
    _max: GameResultMaxAggregateOutputType | null
  }

  export type GameResultAvgAggregateOutputType = {
    id: number | null
    nonce: number | null
    playerMove: number | null
    houseMove: number | null
    betAmount: number | null
    outcome: number | null
    payoutAmount: number | null
    season: number | null
    timestamp: number | null
  }

  export type GameResultSumAggregateOutputType = {
    id: number | null
    nonce: bigint | null
    playerMove: number | null
    houseMove: number | null
    betAmount: bigint | null
    outcome: number | null
    payoutAmount: bigint | null
    season: bigint | null
    timestamp: bigint | null
  }

  export type GameResultMinAggregateOutputType = {
    id: number | null
    nonce: bigint | null
    player: string | null
    playerMove: number | null
    houseMove: number | null
    betAmount: bigint | null
    outcome: number | null
    payoutAmount: bigint | null
    coinTypeName: string | null
    season: bigint | null
    timestamp: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
  }

  export type GameResultMaxAggregateOutputType = {
    id: number | null
    nonce: bigint | null
    player: string | null
    playerMove: number | null
    houseMove: number | null
    betAmount: bigint | null
    outcome: number | null
    payoutAmount: bigint | null
    coinTypeName: string | null
    season: bigint | null
    timestamp: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
  }

  export type GameResultCountAggregateOutputType = {
    id: number
    nonce: number
    player: number
    playerMove: number
    houseMove: number
    betAmount: number
    outcome: number
    payoutAmount: number
    coinTypeName: number
    season: number
    timestamp: number
    createdAt: number
    updatedAt: number
    network: number
    _all: number
  }


  export type GameResultAvgAggregateInputType = {
    id?: true
    nonce?: true
    playerMove?: true
    houseMove?: true
    betAmount?: true
    outcome?: true
    payoutAmount?: true
    season?: true
    timestamp?: true
  }

  export type GameResultSumAggregateInputType = {
    id?: true
    nonce?: true
    playerMove?: true
    houseMove?: true
    betAmount?: true
    outcome?: true
    payoutAmount?: true
    season?: true
    timestamp?: true
  }

  export type GameResultMinAggregateInputType = {
    id?: true
    nonce?: true
    player?: true
    playerMove?: true
    houseMove?: true
    betAmount?: true
    outcome?: true
    payoutAmount?: true
    coinTypeName?: true
    season?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    network?: true
  }

  export type GameResultMaxAggregateInputType = {
    id?: true
    nonce?: true
    player?: true
    playerMove?: true
    houseMove?: true
    betAmount?: true
    outcome?: true
    payoutAmount?: true
    coinTypeName?: true
    season?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    network?: true
  }

  export type GameResultCountAggregateInputType = {
    id?: true
    nonce?: true
    player?: true
    playerMove?: true
    houseMove?: true
    betAmount?: true
    outcome?: true
    payoutAmount?: true
    coinTypeName?: true
    season?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    _all?: true
  }

  export type GameResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameResult to aggregate.
     */
    where?: GameResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameResults to fetch.
     */
    orderBy?: GameResultOrderByWithRelationInput | GameResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameResults
    **/
    _count?: true | GameResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameResultMaxAggregateInputType
  }

  export type GetGameResultAggregateType<T extends GameResultAggregateArgs> = {
        [P in keyof T & keyof AggregateGameResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameResult[P]>
      : GetScalarType<T[P], AggregateGameResult[P]>
  }




  export type GameResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameResultWhereInput
    orderBy?: GameResultOrderByWithAggregationInput | GameResultOrderByWithAggregationInput[]
    by: GameResultScalarFieldEnum[] | GameResultScalarFieldEnum
    having?: GameResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameResultCountAggregateInputType | true
    _avg?: GameResultAvgAggregateInputType
    _sum?: GameResultSumAggregateInputType
    _min?: GameResultMinAggregateInputType
    _max?: GameResultMaxAggregateInputType
  }

  export type GameResultGroupByOutputType = {
    id: number
    nonce: bigint
    player: string
    playerMove: number
    houseMove: number
    betAmount: bigint
    outcome: number
    payoutAmount: bigint
    coinTypeName: string
    season: bigint
    timestamp: bigint
    createdAt: Date
    updatedAt: Date
    network: string
    _count: GameResultCountAggregateOutputType | null
    _avg: GameResultAvgAggregateOutputType | null
    _sum: GameResultSumAggregateOutputType | null
    _min: GameResultMinAggregateOutputType | null
    _max: GameResultMaxAggregateOutputType | null
  }

  type GetGameResultGroupByPayload<T extends GameResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameResultGroupByOutputType[P]>
            : GetScalarType<T[P], GameResultGroupByOutputType[P]>
        }
      >
    >


  export type GameResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nonce?: boolean
    player?: boolean
    playerMove?: boolean
    houseMove?: boolean
    betAmount?: boolean
    outcome?: boolean
    payoutAmount?: boolean
    coinTypeName?: boolean
    season?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
  }, ExtArgs["result"]["gameResult"]>

  export type GameResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nonce?: boolean
    player?: boolean
    playerMove?: boolean
    houseMove?: boolean
    betAmount?: boolean
    outcome?: boolean
    payoutAmount?: boolean
    coinTypeName?: boolean
    season?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
  }, ExtArgs["result"]["gameResult"]>

  export type GameResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nonce?: boolean
    player?: boolean
    playerMove?: boolean
    houseMove?: boolean
    betAmount?: boolean
    outcome?: boolean
    payoutAmount?: boolean
    coinTypeName?: boolean
    season?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
  }, ExtArgs["result"]["gameResult"]>

  export type GameResultSelectScalar = {
    id?: boolean
    nonce?: boolean
    player?: boolean
    playerMove?: boolean
    houseMove?: boolean
    betAmount?: boolean
    outcome?: boolean
    payoutAmount?: boolean
    coinTypeName?: boolean
    season?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
  }

  export type GameResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nonce" | "player" | "playerMove" | "houseMove" | "betAmount" | "outcome" | "payoutAmount" | "coinTypeName" | "season" | "timestamp" | "createdAt" | "updatedAt" | "network", ExtArgs["result"]["gameResult"]>

  export type $GameResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameResult"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nonce: bigint
      player: string
      playerMove: number
      houseMove: number
      betAmount: bigint
      outcome: number
      payoutAmount: bigint
      coinTypeName: string
      season: bigint
      timestamp: bigint
      createdAt: Date
      updatedAt: Date
      network: string
    }, ExtArgs["result"]["gameResult"]>
    composites: {}
  }

  type GameResultGetPayload<S extends boolean | null | undefined | GameResultDefaultArgs> = $Result.GetResult<Prisma.$GameResultPayload, S>

  type GameResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameResultCountAggregateInputType | true
    }

  export interface GameResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameResult'], meta: { name: 'GameResult' } }
    /**
     * Find zero or one GameResult that matches the filter.
     * @param {GameResultFindUniqueArgs} args - Arguments to find a GameResult
     * @example
     * // Get one GameResult
     * const gameResult = await prisma.gameResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameResultFindUniqueArgs>(args: SelectSubset<T, GameResultFindUniqueArgs<ExtArgs>>): Prisma__GameResultClient<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameResultFindUniqueOrThrowArgs} args - Arguments to find a GameResult
     * @example
     * // Get one GameResult
     * const gameResult = await prisma.gameResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameResultFindUniqueOrThrowArgs>(args: SelectSubset<T, GameResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameResultClient<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameResultFindFirstArgs} args - Arguments to find a GameResult
     * @example
     * // Get one GameResult
     * const gameResult = await prisma.gameResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameResultFindFirstArgs>(args?: SelectSubset<T, GameResultFindFirstArgs<ExtArgs>>): Prisma__GameResultClient<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameResultFindFirstOrThrowArgs} args - Arguments to find a GameResult
     * @example
     * // Get one GameResult
     * const gameResult = await prisma.gameResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameResultFindFirstOrThrowArgs>(args?: SelectSubset<T, GameResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameResultClient<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameResults
     * const gameResults = await prisma.gameResult.findMany()
     * 
     * // Get first 10 GameResults
     * const gameResults = await prisma.gameResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameResultWithIdOnly = await prisma.gameResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameResultFindManyArgs>(args?: SelectSubset<T, GameResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameResult.
     * @param {GameResultCreateArgs} args - Arguments to create a GameResult.
     * @example
     * // Create one GameResult
     * const GameResult = await prisma.gameResult.create({
     *   data: {
     *     // ... data to create a GameResult
     *   }
     * })
     * 
     */
    create<T extends GameResultCreateArgs>(args: SelectSubset<T, GameResultCreateArgs<ExtArgs>>): Prisma__GameResultClient<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameResults.
     * @param {GameResultCreateManyArgs} args - Arguments to create many GameResults.
     * @example
     * // Create many GameResults
     * const gameResult = await prisma.gameResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameResultCreateManyArgs>(args?: SelectSubset<T, GameResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameResults and returns the data saved in the database.
     * @param {GameResultCreateManyAndReturnArgs} args - Arguments to create many GameResults.
     * @example
     * // Create many GameResults
     * const gameResult = await prisma.gameResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameResults and only return the `id`
     * const gameResultWithIdOnly = await prisma.gameResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameResultCreateManyAndReturnArgs>(args?: SelectSubset<T, GameResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameResult.
     * @param {GameResultDeleteArgs} args - Arguments to delete one GameResult.
     * @example
     * // Delete one GameResult
     * const GameResult = await prisma.gameResult.delete({
     *   where: {
     *     // ... filter to delete one GameResult
     *   }
     * })
     * 
     */
    delete<T extends GameResultDeleteArgs>(args: SelectSubset<T, GameResultDeleteArgs<ExtArgs>>): Prisma__GameResultClient<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameResult.
     * @param {GameResultUpdateArgs} args - Arguments to update one GameResult.
     * @example
     * // Update one GameResult
     * const gameResult = await prisma.gameResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameResultUpdateArgs>(args: SelectSubset<T, GameResultUpdateArgs<ExtArgs>>): Prisma__GameResultClient<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameResults.
     * @param {GameResultDeleteManyArgs} args - Arguments to filter GameResults to delete.
     * @example
     * // Delete a few GameResults
     * const { count } = await prisma.gameResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameResultDeleteManyArgs>(args?: SelectSubset<T, GameResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameResults
     * const gameResult = await prisma.gameResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameResultUpdateManyArgs>(args: SelectSubset<T, GameResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameResults and returns the data updated in the database.
     * @param {GameResultUpdateManyAndReturnArgs} args - Arguments to update many GameResults.
     * @example
     * // Update many GameResults
     * const gameResult = await prisma.gameResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameResults and only return the `id`
     * const gameResultWithIdOnly = await prisma.gameResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameResultUpdateManyAndReturnArgs>(args: SelectSubset<T, GameResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameResult.
     * @param {GameResultUpsertArgs} args - Arguments to update or create a GameResult.
     * @example
     * // Update or create a GameResult
     * const gameResult = await prisma.gameResult.upsert({
     *   create: {
     *     // ... data to create a GameResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameResult we want to update
     *   }
     * })
     */
    upsert<T extends GameResultUpsertArgs>(args: SelectSubset<T, GameResultUpsertArgs<ExtArgs>>): Prisma__GameResultClient<$Result.GetResult<Prisma.$GameResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameResultCountArgs} args - Arguments to filter GameResults to count.
     * @example
     * // Count the number of GameResults
     * const count = await prisma.gameResult.count({
     *   where: {
     *     // ... the filter for the GameResults we want to count
     *   }
     * })
    **/
    count<T extends GameResultCountArgs>(
      args?: Subset<T, GameResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameResultAggregateArgs>(args: Subset<T, GameResultAggregateArgs>): Prisma.PrismaPromise<GetGameResultAggregateType<T>>

    /**
     * Group by GameResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameResultGroupByArgs['orderBy'] }
        : { orderBy?: GameResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameResult model
   */
  readonly fields: GameResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameResult model
   */
  interface GameResultFieldRefs {
    readonly id: FieldRef<"GameResult", 'Int'>
    readonly nonce: FieldRef<"GameResult", 'BigInt'>
    readonly player: FieldRef<"GameResult", 'String'>
    readonly playerMove: FieldRef<"GameResult", 'Int'>
    readonly houseMove: FieldRef<"GameResult", 'Int'>
    readonly betAmount: FieldRef<"GameResult", 'BigInt'>
    readonly outcome: FieldRef<"GameResult", 'Int'>
    readonly payoutAmount: FieldRef<"GameResult", 'BigInt'>
    readonly coinTypeName: FieldRef<"GameResult", 'String'>
    readonly season: FieldRef<"GameResult", 'BigInt'>
    readonly timestamp: FieldRef<"GameResult", 'BigInt'>
    readonly createdAt: FieldRef<"GameResult", 'DateTime'>
    readonly updatedAt: FieldRef<"GameResult", 'DateTime'>
    readonly network: FieldRef<"GameResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GameResult findUnique
   */
  export type GameResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * Filter, which GameResult to fetch.
     */
    where: GameResultWhereUniqueInput
  }

  /**
   * GameResult findUniqueOrThrow
   */
  export type GameResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * Filter, which GameResult to fetch.
     */
    where: GameResultWhereUniqueInput
  }

  /**
   * GameResult findFirst
   */
  export type GameResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * Filter, which GameResult to fetch.
     */
    where?: GameResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameResults to fetch.
     */
    orderBy?: GameResultOrderByWithRelationInput | GameResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameResults.
     */
    cursor?: GameResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameResults.
     */
    distinct?: GameResultScalarFieldEnum | GameResultScalarFieldEnum[]
  }

  /**
   * GameResult findFirstOrThrow
   */
  export type GameResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * Filter, which GameResult to fetch.
     */
    where?: GameResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameResults to fetch.
     */
    orderBy?: GameResultOrderByWithRelationInput | GameResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameResults.
     */
    cursor?: GameResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameResults.
     */
    distinct?: GameResultScalarFieldEnum | GameResultScalarFieldEnum[]
  }

  /**
   * GameResult findMany
   */
  export type GameResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * Filter, which GameResults to fetch.
     */
    where?: GameResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameResults to fetch.
     */
    orderBy?: GameResultOrderByWithRelationInput | GameResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameResults.
     */
    cursor?: GameResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameResults.
     */
    skip?: number
    distinct?: GameResultScalarFieldEnum | GameResultScalarFieldEnum[]
  }

  /**
   * GameResult create
   */
  export type GameResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * The data needed to create a GameResult.
     */
    data: XOR<GameResultCreateInput, GameResultUncheckedCreateInput>
  }

  /**
   * GameResult createMany
   */
  export type GameResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameResults.
     */
    data: GameResultCreateManyInput | GameResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameResult createManyAndReturn
   */
  export type GameResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * The data used to create many GameResults.
     */
    data: GameResultCreateManyInput | GameResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameResult update
   */
  export type GameResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * The data needed to update a GameResult.
     */
    data: XOR<GameResultUpdateInput, GameResultUncheckedUpdateInput>
    /**
     * Choose, which GameResult to update.
     */
    where: GameResultWhereUniqueInput
  }

  /**
   * GameResult updateMany
   */
  export type GameResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameResults.
     */
    data: XOR<GameResultUpdateManyMutationInput, GameResultUncheckedUpdateManyInput>
    /**
     * Filter which GameResults to update
     */
    where?: GameResultWhereInput
    /**
     * Limit how many GameResults to update.
     */
    limit?: number
  }

  /**
   * GameResult updateManyAndReturn
   */
  export type GameResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * The data used to update GameResults.
     */
    data: XOR<GameResultUpdateManyMutationInput, GameResultUncheckedUpdateManyInput>
    /**
     * Filter which GameResults to update
     */
    where?: GameResultWhereInput
    /**
     * Limit how many GameResults to update.
     */
    limit?: number
  }

  /**
   * GameResult upsert
   */
  export type GameResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * The filter to search for the GameResult to update in case it exists.
     */
    where: GameResultWhereUniqueInput
    /**
     * In case the GameResult found by the `where` argument doesn't exist, create a new GameResult with this data.
     */
    create: XOR<GameResultCreateInput, GameResultUncheckedCreateInput>
    /**
     * In case the GameResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameResultUpdateInput, GameResultUncheckedUpdateInput>
  }

  /**
   * GameResult delete
   */
  export type GameResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
    /**
     * Filter which GameResult to delete.
     */
    where: GameResultWhereUniqueInput
  }

  /**
   * GameResult deleteMany
   */
  export type GameResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameResults to delete
     */
    where?: GameResultWhereInput
    /**
     * Limit how many GameResults to delete.
     */
    limit?: number
  }

  /**
   * GameResult without action
   */
  export type GameResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameResult
     */
    select?: GameResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameResult
     */
    omit?: GameResultOmit<ExtArgs> | null
  }


  /**
   * Model PoolsDB
   */

  export type AggregatePoolsDB = {
    _count: PoolsDBCountAggregateOutputType | null
    _avg: PoolsDBAvgAggregateOutputType | null
    _sum: PoolsDBSumAggregateOutputType | null
    _min: PoolsDBMinAggregateOutputType | null
    _max: PoolsDBMaxAggregateOutputType | null
  }

  export type PoolsDBAvgAggregateOutputType = {
    id: number | null
    initialVirtualSupraReserves: number | null
    initialVirtualTokenReserves: number | null
    platformFee: number | null
    tokenDecimals: number | null
    displayOrder: number | null
    unstakePeriodSeconds: number | null
  }

  export type PoolsDBSumAggregateOutputType = {
    id: number | null
    initialVirtualSupraReserves: bigint | null
    initialVirtualTokenReserves: bigint | null
    platformFee: number | null
    tokenDecimals: number | null
    displayOrder: number | null
    unstakePeriodSeconds: bigint | null
  }

  export type PoolsDBMinAggregateOutputType = {
    id: number | null
    description: string | null
    dev: string | null
    initialVirtualSupraReserves: bigint | null
    initialVirtualTokenReserves: bigint | null
    name: string | null
    platformFee: number | null
    pool: string | null
    symbol: string | null
    telegram: string | null
    tokenAddress: string | null
    tokenDecimals: number | null
    twitter: string | null
    uri: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
    displayOrder: number | null
    github: string | null
    stream: string | null
    unstakePeriodSeconds: bigint | null
    project_type: string | null
  }

  export type PoolsDBMaxAggregateOutputType = {
    id: number | null
    description: string | null
    dev: string | null
    initialVirtualSupraReserves: bigint | null
    initialVirtualTokenReserves: bigint | null
    name: string | null
    platformFee: number | null
    pool: string | null
    symbol: string | null
    telegram: string | null
    tokenAddress: string | null
    tokenDecimals: number | null
    twitter: string | null
    uri: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
    displayOrder: number | null
    github: string | null
    stream: string | null
    unstakePeriodSeconds: bigint | null
    project_type: string | null
  }

  export type PoolsDBCountAggregateOutputType = {
    id: number
    description: number
    dev: number
    initialVirtualSupraReserves: number
    initialVirtualTokenReserves: number
    name: number
    platformFee: number
    pool: number
    symbol: number
    telegram: number
    tokenAddress: number
    tokenDecimals: number
    twitter: number
    uri: number
    website: number
    createdAt: number
    updatedAt: number
    network: number
    displayOrder: number
    github: number
    stream: number
    unstakePeriodSeconds: number
    project_type: number
    _all: number
  }


  export type PoolsDBAvgAggregateInputType = {
    id?: true
    initialVirtualSupraReserves?: true
    initialVirtualTokenReserves?: true
    platformFee?: true
    tokenDecimals?: true
    displayOrder?: true
    unstakePeriodSeconds?: true
  }

  export type PoolsDBSumAggregateInputType = {
    id?: true
    initialVirtualSupraReserves?: true
    initialVirtualTokenReserves?: true
    platformFee?: true
    tokenDecimals?: true
    displayOrder?: true
    unstakePeriodSeconds?: true
  }

  export type PoolsDBMinAggregateInputType = {
    id?: true
    description?: true
    dev?: true
    initialVirtualSupraReserves?: true
    initialVirtualTokenReserves?: true
    name?: true
    platformFee?: true
    pool?: true
    symbol?: true
    telegram?: true
    tokenAddress?: true
    tokenDecimals?: true
    twitter?: true
    uri?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    displayOrder?: true
    github?: true
    stream?: true
    unstakePeriodSeconds?: true
    project_type?: true
  }

  export type PoolsDBMaxAggregateInputType = {
    id?: true
    description?: true
    dev?: true
    initialVirtualSupraReserves?: true
    initialVirtualTokenReserves?: true
    name?: true
    platformFee?: true
    pool?: true
    symbol?: true
    telegram?: true
    tokenAddress?: true
    tokenDecimals?: true
    twitter?: true
    uri?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    displayOrder?: true
    github?: true
    stream?: true
    unstakePeriodSeconds?: true
    project_type?: true
  }

  export type PoolsDBCountAggregateInputType = {
    id?: true
    description?: true
    dev?: true
    initialVirtualSupraReserves?: true
    initialVirtualTokenReserves?: true
    name?: true
    platformFee?: true
    pool?: true
    symbol?: true
    telegram?: true
    tokenAddress?: true
    tokenDecimals?: true
    twitter?: true
    uri?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    displayOrder?: true
    github?: true
    stream?: true
    unstakePeriodSeconds?: true
    project_type?: true
    _all?: true
  }

  export type PoolsDBAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoolsDB to aggregate.
     */
    where?: PoolsDBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoolsDBS to fetch.
     */
    orderBy?: PoolsDBOrderByWithRelationInput | PoolsDBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PoolsDBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoolsDBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoolsDBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PoolsDBS
    **/
    _count?: true | PoolsDBCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PoolsDBAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PoolsDBSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoolsDBMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoolsDBMaxAggregateInputType
  }

  export type GetPoolsDBAggregateType<T extends PoolsDBAggregateArgs> = {
        [P in keyof T & keyof AggregatePoolsDB]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoolsDB[P]>
      : GetScalarType<T[P], AggregatePoolsDB[P]>
  }




  export type PoolsDBGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoolsDBWhereInput
    orderBy?: PoolsDBOrderByWithAggregationInput | PoolsDBOrderByWithAggregationInput[]
    by: PoolsDBScalarFieldEnum[] | PoolsDBScalarFieldEnum
    having?: PoolsDBScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoolsDBCountAggregateInputType | true
    _avg?: PoolsDBAvgAggregateInputType
    _sum?: PoolsDBSumAggregateInputType
    _min?: PoolsDBMinAggregateInputType
    _max?: PoolsDBMaxAggregateInputType
  }

  export type PoolsDBGroupByOutputType = {
    id: number
    description: string
    dev: string
    initialVirtualSupraReserves: bigint
    initialVirtualTokenReserves: bigint
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt: Date
    updatedAt: Date
    network: string
    displayOrder: number | null
    github: string | null
    stream: string | null
    unstakePeriodSeconds: bigint | null
    project_type: string | null
    _count: PoolsDBCountAggregateOutputType | null
    _avg: PoolsDBAvgAggregateOutputType | null
    _sum: PoolsDBSumAggregateOutputType | null
    _min: PoolsDBMinAggregateOutputType | null
    _max: PoolsDBMaxAggregateOutputType | null
  }

  type GetPoolsDBGroupByPayload<T extends PoolsDBGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PoolsDBGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoolsDBGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoolsDBGroupByOutputType[P]>
            : GetScalarType<T[P], PoolsDBGroupByOutputType[P]>
        }
      >
    >


  export type PoolsDBSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    dev?: boolean
    initialVirtualSupraReserves?: boolean
    initialVirtualTokenReserves?: boolean
    name?: boolean
    platformFee?: boolean
    pool?: boolean
    symbol?: boolean
    telegram?: boolean
    tokenAddress?: boolean
    tokenDecimals?: boolean
    twitter?: boolean
    uri?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    displayOrder?: boolean
    github?: boolean
    stream?: boolean
    unstakePeriodSeconds?: boolean
    project_type?: boolean
    comments?: boolean | PoolsDB$commentsArgs<ExtArgs>
    trust_pools?: boolean | PoolsDB$trust_poolsArgs<ExtArgs>
    holders?: boolean | PoolsDB$holdersArgs<ExtArgs>
    _count?: boolean | PoolsDBCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poolsDB"]>

  export type PoolsDBSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    dev?: boolean
    initialVirtualSupraReserves?: boolean
    initialVirtualTokenReserves?: boolean
    name?: boolean
    platformFee?: boolean
    pool?: boolean
    symbol?: boolean
    telegram?: boolean
    tokenAddress?: boolean
    tokenDecimals?: boolean
    twitter?: boolean
    uri?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    displayOrder?: boolean
    github?: boolean
    stream?: boolean
    unstakePeriodSeconds?: boolean
    project_type?: boolean
  }, ExtArgs["result"]["poolsDB"]>

  export type PoolsDBSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    dev?: boolean
    initialVirtualSupraReserves?: boolean
    initialVirtualTokenReserves?: boolean
    name?: boolean
    platformFee?: boolean
    pool?: boolean
    symbol?: boolean
    telegram?: boolean
    tokenAddress?: boolean
    tokenDecimals?: boolean
    twitter?: boolean
    uri?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    displayOrder?: boolean
    github?: boolean
    stream?: boolean
    unstakePeriodSeconds?: boolean
    project_type?: boolean
  }, ExtArgs["result"]["poolsDB"]>

  export type PoolsDBSelectScalar = {
    id?: boolean
    description?: boolean
    dev?: boolean
    initialVirtualSupraReserves?: boolean
    initialVirtualTokenReserves?: boolean
    name?: boolean
    platformFee?: boolean
    pool?: boolean
    symbol?: boolean
    telegram?: boolean
    tokenAddress?: boolean
    tokenDecimals?: boolean
    twitter?: boolean
    uri?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    displayOrder?: boolean
    github?: boolean
    stream?: boolean
    unstakePeriodSeconds?: boolean
    project_type?: boolean
  }

  export type PoolsDBOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "dev" | "initialVirtualSupraReserves" | "initialVirtualTokenReserves" | "name" | "platformFee" | "pool" | "symbol" | "telegram" | "tokenAddress" | "tokenDecimals" | "twitter" | "uri" | "website" | "createdAt" | "updatedAt" | "network" | "displayOrder" | "github" | "stream" | "unstakePeriodSeconds" | "project_type", ExtArgs["result"]["poolsDB"]>
  export type PoolsDBInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PoolsDB$commentsArgs<ExtArgs>
    trust_pools?: boolean | PoolsDB$trust_poolsArgs<ExtArgs>
    holders?: boolean | PoolsDB$holdersArgs<ExtArgs>
    _count?: boolean | PoolsDBCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PoolsDBIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PoolsDBIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PoolsDBPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PoolsDB"
    objects: {
      comments: Prisma.$commentsPayload<ExtArgs>[]
      trust_pools: Prisma.$trust_poolsPayload<ExtArgs> | null
      holders: Prisma.$token_holdersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      dev: string
      initialVirtualSupraReserves: bigint
      initialVirtualTokenReserves: bigint
      name: string
      platformFee: number
      pool: string
      symbol: string
      telegram: string
      tokenAddress: string
      tokenDecimals: number
      twitter: string
      uri: string
      website: string
      createdAt: Date
      updatedAt: Date
      network: string
      displayOrder: number | null
      github: string | null
      stream: string | null
      unstakePeriodSeconds: bigint | null
      project_type: string | null
    }, ExtArgs["result"]["poolsDB"]>
    composites: {}
  }

  type PoolsDBGetPayload<S extends boolean | null | undefined | PoolsDBDefaultArgs> = $Result.GetResult<Prisma.$PoolsDBPayload, S>

  type PoolsDBCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PoolsDBFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PoolsDBCountAggregateInputType | true
    }

  export interface PoolsDBDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PoolsDB'], meta: { name: 'PoolsDB' } }
    /**
     * Find zero or one PoolsDB that matches the filter.
     * @param {PoolsDBFindUniqueArgs} args - Arguments to find a PoolsDB
     * @example
     * // Get one PoolsDB
     * const poolsDB = await prisma.poolsDB.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PoolsDBFindUniqueArgs>(args: SelectSubset<T, PoolsDBFindUniqueArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PoolsDB that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PoolsDBFindUniqueOrThrowArgs} args - Arguments to find a PoolsDB
     * @example
     * // Get one PoolsDB
     * const poolsDB = await prisma.poolsDB.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PoolsDBFindUniqueOrThrowArgs>(args: SelectSubset<T, PoolsDBFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoolsDB that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoolsDBFindFirstArgs} args - Arguments to find a PoolsDB
     * @example
     * // Get one PoolsDB
     * const poolsDB = await prisma.poolsDB.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PoolsDBFindFirstArgs>(args?: SelectSubset<T, PoolsDBFindFirstArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoolsDB that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoolsDBFindFirstOrThrowArgs} args - Arguments to find a PoolsDB
     * @example
     * // Get one PoolsDB
     * const poolsDB = await prisma.poolsDB.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PoolsDBFindFirstOrThrowArgs>(args?: SelectSubset<T, PoolsDBFindFirstOrThrowArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PoolsDBS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoolsDBFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PoolsDBS
     * const poolsDBS = await prisma.poolsDB.findMany()
     * 
     * // Get first 10 PoolsDBS
     * const poolsDBS = await prisma.poolsDB.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poolsDBWithIdOnly = await prisma.poolsDB.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PoolsDBFindManyArgs>(args?: SelectSubset<T, PoolsDBFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PoolsDB.
     * @param {PoolsDBCreateArgs} args - Arguments to create a PoolsDB.
     * @example
     * // Create one PoolsDB
     * const PoolsDB = await prisma.poolsDB.create({
     *   data: {
     *     // ... data to create a PoolsDB
     *   }
     * })
     * 
     */
    create<T extends PoolsDBCreateArgs>(args: SelectSubset<T, PoolsDBCreateArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PoolsDBS.
     * @param {PoolsDBCreateManyArgs} args - Arguments to create many PoolsDBS.
     * @example
     * // Create many PoolsDBS
     * const poolsDB = await prisma.poolsDB.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PoolsDBCreateManyArgs>(args?: SelectSubset<T, PoolsDBCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PoolsDBS and returns the data saved in the database.
     * @param {PoolsDBCreateManyAndReturnArgs} args - Arguments to create many PoolsDBS.
     * @example
     * // Create many PoolsDBS
     * const poolsDB = await prisma.poolsDB.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PoolsDBS and only return the `id`
     * const poolsDBWithIdOnly = await prisma.poolsDB.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PoolsDBCreateManyAndReturnArgs>(args?: SelectSubset<T, PoolsDBCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PoolsDB.
     * @param {PoolsDBDeleteArgs} args - Arguments to delete one PoolsDB.
     * @example
     * // Delete one PoolsDB
     * const PoolsDB = await prisma.poolsDB.delete({
     *   where: {
     *     // ... filter to delete one PoolsDB
     *   }
     * })
     * 
     */
    delete<T extends PoolsDBDeleteArgs>(args: SelectSubset<T, PoolsDBDeleteArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PoolsDB.
     * @param {PoolsDBUpdateArgs} args - Arguments to update one PoolsDB.
     * @example
     * // Update one PoolsDB
     * const poolsDB = await prisma.poolsDB.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PoolsDBUpdateArgs>(args: SelectSubset<T, PoolsDBUpdateArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PoolsDBS.
     * @param {PoolsDBDeleteManyArgs} args - Arguments to filter PoolsDBS to delete.
     * @example
     * // Delete a few PoolsDBS
     * const { count } = await prisma.poolsDB.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PoolsDBDeleteManyArgs>(args?: SelectSubset<T, PoolsDBDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoolsDBS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoolsDBUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PoolsDBS
     * const poolsDB = await prisma.poolsDB.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PoolsDBUpdateManyArgs>(args: SelectSubset<T, PoolsDBUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoolsDBS and returns the data updated in the database.
     * @param {PoolsDBUpdateManyAndReturnArgs} args - Arguments to update many PoolsDBS.
     * @example
     * // Update many PoolsDBS
     * const poolsDB = await prisma.poolsDB.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PoolsDBS and only return the `id`
     * const poolsDBWithIdOnly = await prisma.poolsDB.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PoolsDBUpdateManyAndReturnArgs>(args: SelectSubset<T, PoolsDBUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PoolsDB.
     * @param {PoolsDBUpsertArgs} args - Arguments to update or create a PoolsDB.
     * @example
     * // Update or create a PoolsDB
     * const poolsDB = await prisma.poolsDB.upsert({
     *   create: {
     *     // ... data to create a PoolsDB
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PoolsDB we want to update
     *   }
     * })
     */
    upsert<T extends PoolsDBUpsertArgs>(args: SelectSubset<T, PoolsDBUpsertArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PoolsDBS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoolsDBCountArgs} args - Arguments to filter PoolsDBS to count.
     * @example
     * // Count the number of PoolsDBS
     * const count = await prisma.poolsDB.count({
     *   where: {
     *     // ... the filter for the PoolsDBS we want to count
     *   }
     * })
    **/
    count<T extends PoolsDBCountArgs>(
      args?: Subset<T, PoolsDBCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoolsDBCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PoolsDB.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoolsDBAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoolsDBAggregateArgs>(args: Subset<T, PoolsDBAggregateArgs>): Prisma.PrismaPromise<GetPoolsDBAggregateType<T>>

    /**
     * Group by PoolsDB.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoolsDBGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PoolsDBGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PoolsDBGroupByArgs['orderBy'] }
        : { orderBy?: PoolsDBGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PoolsDBGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoolsDBGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PoolsDB model
   */
  readonly fields: PoolsDBFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PoolsDB.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PoolsDBClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends PoolsDB$commentsArgs<ExtArgs> = {}>(args?: Subset<T, PoolsDB$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trust_pools<T extends PoolsDB$trust_poolsArgs<ExtArgs> = {}>(args?: Subset<T, PoolsDB$trust_poolsArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    holders<T extends PoolsDB$holdersArgs<ExtArgs> = {}>(args?: Subset<T, PoolsDB$holdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PoolsDB model
   */
  interface PoolsDBFieldRefs {
    readonly id: FieldRef<"PoolsDB", 'Int'>
    readonly description: FieldRef<"PoolsDB", 'String'>
    readonly dev: FieldRef<"PoolsDB", 'String'>
    readonly initialVirtualSupraReserves: FieldRef<"PoolsDB", 'BigInt'>
    readonly initialVirtualTokenReserves: FieldRef<"PoolsDB", 'BigInt'>
    readonly name: FieldRef<"PoolsDB", 'String'>
    readonly platformFee: FieldRef<"PoolsDB", 'Int'>
    readonly pool: FieldRef<"PoolsDB", 'String'>
    readonly symbol: FieldRef<"PoolsDB", 'String'>
    readonly telegram: FieldRef<"PoolsDB", 'String'>
    readonly tokenAddress: FieldRef<"PoolsDB", 'String'>
    readonly tokenDecimals: FieldRef<"PoolsDB", 'Int'>
    readonly twitter: FieldRef<"PoolsDB", 'String'>
    readonly uri: FieldRef<"PoolsDB", 'String'>
    readonly website: FieldRef<"PoolsDB", 'String'>
    readonly createdAt: FieldRef<"PoolsDB", 'DateTime'>
    readonly updatedAt: FieldRef<"PoolsDB", 'DateTime'>
    readonly network: FieldRef<"PoolsDB", 'String'>
    readonly displayOrder: FieldRef<"PoolsDB", 'Int'>
    readonly github: FieldRef<"PoolsDB", 'String'>
    readonly stream: FieldRef<"PoolsDB", 'String'>
    readonly unstakePeriodSeconds: FieldRef<"PoolsDB", 'BigInt'>
    readonly project_type: FieldRef<"PoolsDB", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PoolsDB findUnique
   */
  export type PoolsDBFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * Filter, which PoolsDB to fetch.
     */
    where: PoolsDBWhereUniqueInput
  }

  /**
   * PoolsDB findUniqueOrThrow
   */
  export type PoolsDBFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * Filter, which PoolsDB to fetch.
     */
    where: PoolsDBWhereUniqueInput
  }

  /**
   * PoolsDB findFirst
   */
  export type PoolsDBFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * Filter, which PoolsDB to fetch.
     */
    where?: PoolsDBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoolsDBS to fetch.
     */
    orderBy?: PoolsDBOrderByWithRelationInput | PoolsDBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoolsDBS.
     */
    cursor?: PoolsDBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoolsDBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoolsDBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoolsDBS.
     */
    distinct?: PoolsDBScalarFieldEnum | PoolsDBScalarFieldEnum[]
  }

  /**
   * PoolsDB findFirstOrThrow
   */
  export type PoolsDBFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * Filter, which PoolsDB to fetch.
     */
    where?: PoolsDBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoolsDBS to fetch.
     */
    orderBy?: PoolsDBOrderByWithRelationInput | PoolsDBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoolsDBS.
     */
    cursor?: PoolsDBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoolsDBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoolsDBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoolsDBS.
     */
    distinct?: PoolsDBScalarFieldEnum | PoolsDBScalarFieldEnum[]
  }

  /**
   * PoolsDB findMany
   */
  export type PoolsDBFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * Filter, which PoolsDBS to fetch.
     */
    where?: PoolsDBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoolsDBS to fetch.
     */
    orderBy?: PoolsDBOrderByWithRelationInput | PoolsDBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PoolsDBS.
     */
    cursor?: PoolsDBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoolsDBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoolsDBS.
     */
    skip?: number
    distinct?: PoolsDBScalarFieldEnum | PoolsDBScalarFieldEnum[]
  }

  /**
   * PoolsDB create
   */
  export type PoolsDBCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * The data needed to create a PoolsDB.
     */
    data: XOR<PoolsDBCreateInput, PoolsDBUncheckedCreateInput>
  }

  /**
   * PoolsDB createMany
   */
  export type PoolsDBCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PoolsDBS.
     */
    data: PoolsDBCreateManyInput | PoolsDBCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PoolsDB createManyAndReturn
   */
  export type PoolsDBCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * The data used to create many PoolsDBS.
     */
    data: PoolsDBCreateManyInput | PoolsDBCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PoolsDB update
   */
  export type PoolsDBUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * The data needed to update a PoolsDB.
     */
    data: XOR<PoolsDBUpdateInput, PoolsDBUncheckedUpdateInput>
    /**
     * Choose, which PoolsDB to update.
     */
    where: PoolsDBWhereUniqueInput
  }

  /**
   * PoolsDB updateMany
   */
  export type PoolsDBUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PoolsDBS.
     */
    data: XOR<PoolsDBUpdateManyMutationInput, PoolsDBUncheckedUpdateManyInput>
    /**
     * Filter which PoolsDBS to update
     */
    where?: PoolsDBWhereInput
    /**
     * Limit how many PoolsDBS to update.
     */
    limit?: number
  }

  /**
   * PoolsDB updateManyAndReturn
   */
  export type PoolsDBUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * The data used to update PoolsDBS.
     */
    data: XOR<PoolsDBUpdateManyMutationInput, PoolsDBUncheckedUpdateManyInput>
    /**
     * Filter which PoolsDBS to update
     */
    where?: PoolsDBWhereInput
    /**
     * Limit how many PoolsDBS to update.
     */
    limit?: number
  }

  /**
   * PoolsDB upsert
   */
  export type PoolsDBUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * The filter to search for the PoolsDB to update in case it exists.
     */
    where: PoolsDBWhereUniqueInput
    /**
     * In case the PoolsDB found by the `where` argument doesn't exist, create a new PoolsDB with this data.
     */
    create: XOR<PoolsDBCreateInput, PoolsDBUncheckedCreateInput>
    /**
     * In case the PoolsDB was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PoolsDBUpdateInput, PoolsDBUncheckedUpdateInput>
  }

  /**
   * PoolsDB delete
   */
  export type PoolsDBDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
    /**
     * Filter which PoolsDB to delete.
     */
    where: PoolsDBWhereUniqueInput
  }

  /**
   * PoolsDB deleteMany
   */
  export type PoolsDBDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoolsDBS to delete
     */
    where?: PoolsDBWhereInput
    /**
     * Limit how many PoolsDBS to delete.
     */
    limit?: number
  }

  /**
   * PoolsDB.comments
   */
  export type PoolsDB$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * PoolsDB.trust_pools
   */
  export type PoolsDB$trust_poolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    where?: trust_poolsWhereInput
  }

  /**
   * PoolsDB.holders
   */
  export type PoolsDB$holdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    where?: token_holdersWhereInput
    orderBy?: token_holdersOrderByWithRelationInput | token_holdersOrderByWithRelationInput[]
    cursor?: token_holdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Token_holdersScalarFieldEnum | Token_holdersScalarFieldEnum[]
  }

  /**
   * PoolsDB without action
   */
  export type PoolsDBDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoolsDB
     */
    select?: PoolsDBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoolsDB
     */
    omit?: PoolsDBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoolsDBInclude<ExtArgs> | null
  }


  /**
   * Model TradeEvent
   */

  export type AggregateTradeEvent = {
    _count: TradeEventCountAggregateOutputType | null
    _avg: TradeEventAvgAggregateOutputType | null
    _sum: TradeEventSumAggregateOutputType | null
    _min: TradeEventMinAggregateOutputType | null
    _max: TradeEventMaxAggregateOutputType | null
  }

  export type TradeEventAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
    supraAmount: number | null
    tokenAmount: number | null
    virtualSupraReserves: number | null
    virtualTokenReserves: number | null
  }

  export type TradeEventSumAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    supraAmount: bigint | null
    tokenAmount: bigint | null
    virtualSupraReserves: bigint | null
    virtualTokenReserves: bigint | null
  }

  export type TradeEventMinAggregateOutputType = {
    id: number | null
    type: string | null
    creationNumber: string | null
    accountAddress: string | null
    sequenceNumber: string | null
    timestamp: bigint | null
    isBuy: boolean | null
    supraAmount: bigint | null
    tokenAddress: string | null
    tokenAmount: bigint | null
    user: string | null
    virtualSupraReserves: bigint | null
    virtualTokenReserves: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
    processedForOHLC: boolean | null
  }

  export type TradeEventMaxAggregateOutputType = {
    id: number | null
    type: string | null
    creationNumber: string | null
    accountAddress: string | null
    sequenceNumber: string | null
    timestamp: bigint | null
    isBuy: boolean | null
    supraAmount: bigint | null
    tokenAddress: string | null
    tokenAmount: bigint | null
    user: string | null
    virtualSupraReserves: bigint | null
    virtualTokenReserves: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
    processedForOHLC: boolean | null
  }

  export type TradeEventCountAggregateOutputType = {
    id: number
    type: number
    creationNumber: number
    accountAddress: number
    sequenceNumber: number
    timestamp: number
    isBuy: number
    supraAmount: number
    tokenAddress: number
    tokenAmount: number
    user: number
    virtualSupraReserves: number
    virtualTokenReserves: number
    createdAt: number
    updatedAt: number
    network: number
    processedForOHLC: number
    _all: number
  }


  export type TradeEventAvgAggregateInputType = {
    id?: true
    timestamp?: true
    supraAmount?: true
    tokenAmount?: true
    virtualSupraReserves?: true
    virtualTokenReserves?: true
  }

  export type TradeEventSumAggregateInputType = {
    id?: true
    timestamp?: true
    supraAmount?: true
    tokenAmount?: true
    virtualSupraReserves?: true
    virtualTokenReserves?: true
  }

  export type TradeEventMinAggregateInputType = {
    id?: true
    type?: true
    creationNumber?: true
    accountAddress?: true
    sequenceNumber?: true
    timestamp?: true
    isBuy?: true
    supraAmount?: true
    tokenAddress?: true
    tokenAmount?: true
    user?: true
    virtualSupraReserves?: true
    virtualTokenReserves?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    processedForOHLC?: true
  }

  export type TradeEventMaxAggregateInputType = {
    id?: true
    type?: true
    creationNumber?: true
    accountAddress?: true
    sequenceNumber?: true
    timestamp?: true
    isBuy?: true
    supraAmount?: true
    tokenAddress?: true
    tokenAmount?: true
    user?: true
    virtualSupraReserves?: true
    virtualTokenReserves?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    processedForOHLC?: true
  }

  export type TradeEventCountAggregateInputType = {
    id?: true
    type?: true
    creationNumber?: true
    accountAddress?: true
    sequenceNumber?: true
    timestamp?: true
    isBuy?: true
    supraAmount?: true
    tokenAddress?: true
    tokenAmount?: true
    user?: true
    virtualSupraReserves?: true
    virtualTokenReserves?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    processedForOHLC?: true
    _all?: true
  }

  export type TradeEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeEvent to aggregate.
     */
    where?: TradeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeEvents to fetch.
     */
    orderBy?: TradeEventOrderByWithRelationInput | TradeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeEvents
    **/
    _count?: true | TradeEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeEventMaxAggregateInputType
  }

  export type GetTradeEventAggregateType<T extends TradeEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeEvent[P]>
      : GetScalarType<T[P], AggregateTradeEvent[P]>
  }




  export type TradeEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeEventWhereInput
    orderBy?: TradeEventOrderByWithAggregationInput | TradeEventOrderByWithAggregationInput[]
    by: TradeEventScalarFieldEnum[] | TradeEventScalarFieldEnum
    having?: TradeEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeEventCountAggregateInputType | true
    _avg?: TradeEventAvgAggregateInputType
    _sum?: TradeEventSumAggregateInputType
    _min?: TradeEventMinAggregateInputType
    _max?: TradeEventMaxAggregateInputType
  }

  export type TradeEventGroupByOutputType = {
    id: number
    type: string
    creationNumber: string
    accountAddress: string
    sequenceNumber: string
    timestamp: bigint
    isBuy: boolean
    supraAmount: bigint
    tokenAddress: string
    tokenAmount: bigint
    user: string
    virtualSupraReserves: bigint
    virtualTokenReserves: bigint
    createdAt: Date
    updatedAt: Date
    network: string
    processedForOHLC: boolean
    _count: TradeEventCountAggregateOutputType | null
    _avg: TradeEventAvgAggregateOutputType | null
    _sum: TradeEventSumAggregateOutputType | null
    _min: TradeEventMinAggregateOutputType | null
    _max: TradeEventMaxAggregateOutputType | null
  }

  type GetTradeEventGroupByPayload<T extends TradeEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeEventGroupByOutputType[P]>
            : GetScalarType<T[P], TradeEventGroupByOutputType[P]>
        }
      >
    >


  export type TradeEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    creationNumber?: boolean
    accountAddress?: boolean
    sequenceNumber?: boolean
    timestamp?: boolean
    isBuy?: boolean
    supraAmount?: boolean
    tokenAddress?: boolean
    tokenAmount?: boolean
    user?: boolean
    virtualSupraReserves?: boolean
    virtualTokenReserves?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    processedForOHLC?: boolean
  }, ExtArgs["result"]["tradeEvent"]>

  export type TradeEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    creationNumber?: boolean
    accountAddress?: boolean
    sequenceNumber?: boolean
    timestamp?: boolean
    isBuy?: boolean
    supraAmount?: boolean
    tokenAddress?: boolean
    tokenAmount?: boolean
    user?: boolean
    virtualSupraReserves?: boolean
    virtualTokenReserves?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    processedForOHLC?: boolean
  }, ExtArgs["result"]["tradeEvent"]>

  export type TradeEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    creationNumber?: boolean
    accountAddress?: boolean
    sequenceNumber?: boolean
    timestamp?: boolean
    isBuy?: boolean
    supraAmount?: boolean
    tokenAddress?: boolean
    tokenAmount?: boolean
    user?: boolean
    virtualSupraReserves?: boolean
    virtualTokenReserves?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    processedForOHLC?: boolean
  }, ExtArgs["result"]["tradeEvent"]>

  export type TradeEventSelectScalar = {
    id?: boolean
    type?: boolean
    creationNumber?: boolean
    accountAddress?: boolean
    sequenceNumber?: boolean
    timestamp?: boolean
    isBuy?: boolean
    supraAmount?: boolean
    tokenAddress?: boolean
    tokenAmount?: boolean
    user?: boolean
    virtualSupraReserves?: boolean
    virtualTokenReserves?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
    processedForOHLC?: boolean
  }

  export type TradeEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "creationNumber" | "accountAddress" | "sequenceNumber" | "timestamp" | "isBuy" | "supraAmount" | "tokenAddress" | "tokenAmount" | "user" | "virtualSupraReserves" | "virtualTokenReserves" | "createdAt" | "updatedAt" | "network" | "processedForOHLC", ExtArgs["result"]["tradeEvent"]>

  export type $TradeEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      creationNumber: string
      accountAddress: string
      sequenceNumber: string
      timestamp: bigint
      isBuy: boolean
      supraAmount: bigint
      tokenAddress: string
      tokenAmount: bigint
      user: string
      virtualSupraReserves: bigint
      virtualTokenReserves: bigint
      createdAt: Date
      updatedAt: Date
      network: string
      processedForOHLC: boolean
    }, ExtArgs["result"]["tradeEvent"]>
    composites: {}
  }

  type TradeEventGetPayload<S extends boolean | null | undefined | TradeEventDefaultArgs> = $Result.GetResult<Prisma.$TradeEventPayload, S>

  type TradeEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradeEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradeEventCountAggregateInputType | true
    }

  export interface TradeEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeEvent'], meta: { name: 'TradeEvent' } }
    /**
     * Find zero or one TradeEvent that matches the filter.
     * @param {TradeEventFindUniqueArgs} args - Arguments to find a TradeEvent
     * @example
     * // Get one TradeEvent
     * const tradeEvent = await prisma.tradeEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeEventFindUniqueArgs>(args: SelectSubset<T, TradeEventFindUniqueArgs<ExtArgs>>): Prisma__TradeEventClient<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TradeEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradeEventFindUniqueOrThrowArgs} args - Arguments to find a TradeEvent
     * @example
     * // Get one TradeEvent
     * const tradeEvent = await prisma.tradeEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeEventClient<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeEventFindFirstArgs} args - Arguments to find a TradeEvent
     * @example
     * // Get one TradeEvent
     * const tradeEvent = await prisma.tradeEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeEventFindFirstArgs>(args?: SelectSubset<T, TradeEventFindFirstArgs<ExtArgs>>): Prisma__TradeEventClient<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeEventFindFirstOrThrowArgs} args - Arguments to find a TradeEvent
     * @example
     * // Get one TradeEvent
     * const tradeEvent = await prisma.tradeEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeEventClient<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TradeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeEvents
     * const tradeEvents = await prisma.tradeEvent.findMany()
     * 
     * // Get first 10 TradeEvents
     * const tradeEvents = await prisma.tradeEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeEventWithIdOnly = await prisma.tradeEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeEventFindManyArgs>(args?: SelectSubset<T, TradeEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TradeEvent.
     * @param {TradeEventCreateArgs} args - Arguments to create a TradeEvent.
     * @example
     * // Create one TradeEvent
     * const TradeEvent = await prisma.tradeEvent.create({
     *   data: {
     *     // ... data to create a TradeEvent
     *   }
     * })
     * 
     */
    create<T extends TradeEventCreateArgs>(args: SelectSubset<T, TradeEventCreateArgs<ExtArgs>>): Prisma__TradeEventClient<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TradeEvents.
     * @param {TradeEventCreateManyArgs} args - Arguments to create many TradeEvents.
     * @example
     * // Create many TradeEvents
     * const tradeEvent = await prisma.tradeEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeEventCreateManyArgs>(args?: SelectSubset<T, TradeEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeEvents and returns the data saved in the database.
     * @param {TradeEventCreateManyAndReturnArgs} args - Arguments to create many TradeEvents.
     * @example
     * // Create many TradeEvents
     * const tradeEvent = await prisma.tradeEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeEvents and only return the `id`
     * const tradeEventWithIdOnly = await prisma.tradeEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TradeEvent.
     * @param {TradeEventDeleteArgs} args - Arguments to delete one TradeEvent.
     * @example
     * // Delete one TradeEvent
     * const TradeEvent = await prisma.tradeEvent.delete({
     *   where: {
     *     // ... filter to delete one TradeEvent
     *   }
     * })
     * 
     */
    delete<T extends TradeEventDeleteArgs>(args: SelectSubset<T, TradeEventDeleteArgs<ExtArgs>>): Prisma__TradeEventClient<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TradeEvent.
     * @param {TradeEventUpdateArgs} args - Arguments to update one TradeEvent.
     * @example
     * // Update one TradeEvent
     * const tradeEvent = await prisma.tradeEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeEventUpdateArgs>(args: SelectSubset<T, TradeEventUpdateArgs<ExtArgs>>): Prisma__TradeEventClient<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TradeEvents.
     * @param {TradeEventDeleteManyArgs} args - Arguments to filter TradeEvents to delete.
     * @example
     * // Delete a few TradeEvents
     * const { count } = await prisma.tradeEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeEventDeleteManyArgs>(args?: SelectSubset<T, TradeEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeEvents
     * const tradeEvent = await prisma.tradeEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeEventUpdateManyArgs>(args: SelectSubset<T, TradeEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeEvents and returns the data updated in the database.
     * @param {TradeEventUpdateManyAndReturnArgs} args - Arguments to update many TradeEvents.
     * @example
     * // Update many TradeEvents
     * const tradeEvent = await prisma.tradeEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TradeEvents and only return the `id`
     * const tradeEventWithIdOnly = await prisma.tradeEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TradeEventUpdateManyAndReturnArgs>(args: SelectSubset<T, TradeEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TradeEvent.
     * @param {TradeEventUpsertArgs} args - Arguments to update or create a TradeEvent.
     * @example
     * // Update or create a TradeEvent
     * const tradeEvent = await prisma.tradeEvent.upsert({
     *   create: {
     *     // ... data to create a TradeEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeEvent we want to update
     *   }
     * })
     */
    upsert<T extends TradeEventUpsertArgs>(args: SelectSubset<T, TradeEventUpsertArgs<ExtArgs>>): Prisma__TradeEventClient<$Result.GetResult<Prisma.$TradeEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TradeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeEventCountArgs} args - Arguments to filter TradeEvents to count.
     * @example
     * // Count the number of TradeEvents
     * const count = await prisma.tradeEvent.count({
     *   where: {
     *     // ... the filter for the TradeEvents we want to count
     *   }
     * })
    **/
    count<T extends TradeEventCountArgs>(
      args?: Subset<T, TradeEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeEventAggregateArgs>(args: Subset<T, TradeEventAggregateArgs>): Prisma.PrismaPromise<GetTradeEventAggregateType<T>>

    /**
     * Group by TradeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeEventGroupByArgs['orderBy'] }
        : { orderBy?: TradeEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeEvent model
   */
  readonly fields: TradeEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeEvent model
   */
  interface TradeEventFieldRefs {
    readonly id: FieldRef<"TradeEvent", 'Int'>
    readonly type: FieldRef<"TradeEvent", 'String'>
    readonly creationNumber: FieldRef<"TradeEvent", 'String'>
    readonly accountAddress: FieldRef<"TradeEvent", 'String'>
    readonly sequenceNumber: FieldRef<"TradeEvent", 'String'>
    readonly timestamp: FieldRef<"TradeEvent", 'BigInt'>
    readonly isBuy: FieldRef<"TradeEvent", 'Boolean'>
    readonly supraAmount: FieldRef<"TradeEvent", 'BigInt'>
    readonly tokenAddress: FieldRef<"TradeEvent", 'String'>
    readonly tokenAmount: FieldRef<"TradeEvent", 'BigInt'>
    readonly user: FieldRef<"TradeEvent", 'String'>
    readonly virtualSupraReserves: FieldRef<"TradeEvent", 'BigInt'>
    readonly virtualTokenReserves: FieldRef<"TradeEvent", 'BigInt'>
    readonly createdAt: FieldRef<"TradeEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"TradeEvent", 'DateTime'>
    readonly network: FieldRef<"TradeEvent", 'String'>
    readonly processedForOHLC: FieldRef<"TradeEvent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TradeEvent findUnique
   */
  export type TradeEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * Filter, which TradeEvent to fetch.
     */
    where: TradeEventWhereUniqueInput
  }

  /**
   * TradeEvent findUniqueOrThrow
   */
  export type TradeEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * Filter, which TradeEvent to fetch.
     */
    where: TradeEventWhereUniqueInput
  }

  /**
   * TradeEvent findFirst
   */
  export type TradeEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * Filter, which TradeEvent to fetch.
     */
    where?: TradeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeEvents to fetch.
     */
    orderBy?: TradeEventOrderByWithRelationInput | TradeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeEvents.
     */
    cursor?: TradeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeEvents.
     */
    distinct?: TradeEventScalarFieldEnum | TradeEventScalarFieldEnum[]
  }

  /**
   * TradeEvent findFirstOrThrow
   */
  export type TradeEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * Filter, which TradeEvent to fetch.
     */
    where?: TradeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeEvents to fetch.
     */
    orderBy?: TradeEventOrderByWithRelationInput | TradeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeEvents.
     */
    cursor?: TradeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeEvents.
     */
    distinct?: TradeEventScalarFieldEnum | TradeEventScalarFieldEnum[]
  }

  /**
   * TradeEvent findMany
   */
  export type TradeEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * Filter, which TradeEvents to fetch.
     */
    where?: TradeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeEvents to fetch.
     */
    orderBy?: TradeEventOrderByWithRelationInput | TradeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeEvents.
     */
    cursor?: TradeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeEvents.
     */
    skip?: number
    distinct?: TradeEventScalarFieldEnum | TradeEventScalarFieldEnum[]
  }

  /**
   * TradeEvent create
   */
  export type TradeEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * The data needed to create a TradeEvent.
     */
    data: XOR<TradeEventCreateInput, TradeEventUncheckedCreateInput>
  }

  /**
   * TradeEvent createMany
   */
  export type TradeEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeEvents.
     */
    data: TradeEventCreateManyInput | TradeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeEvent createManyAndReturn
   */
  export type TradeEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * The data used to create many TradeEvents.
     */
    data: TradeEventCreateManyInput | TradeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeEvent update
   */
  export type TradeEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * The data needed to update a TradeEvent.
     */
    data: XOR<TradeEventUpdateInput, TradeEventUncheckedUpdateInput>
    /**
     * Choose, which TradeEvent to update.
     */
    where: TradeEventWhereUniqueInput
  }

  /**
   * TradeEvent updateMany
   */
  export type TradeEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeEvents.
     */
    data: XOR<TradeEventUpdateManyMutationInput, TradeEventUncheckedUpdateManyInput>
    /**
     * Filter which TradeEvents to update
     */
    where?: TradeEventWhereInput
    /**
     * Limit how many TradeEvents to update.
     */
    limit?: number
  }

  /**
   * TradeEvent updateManyAndReturn
   */
  export type TradeEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * The data used to update TradeEvents.
     */
    data: XOR<TradeEventUpdateManyMutationInput, TradeEventUncheckedUpdateManyInput>
    /**
     * Filter which TradeEvents to update
     */
    where?: TradeEventWhereInput
    /**
     * Limit how many TradeEvents to update.
     */
    limit?: number
  }

  /**
   * TradeEvent upsert
   */
  export type TradeEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * The filter to search for the TradeEvent to update in case it exists.
     */
    where: TradeEventWhereUniqueInput
    /**
     * In case the TradeEvent found by the `where` argument doesn't exist, create a new TradeEvent with this data.
     */
    create: XOR<TradeEventCreateInput, TradeEventUncheckedCreateInput>
    /**
     * In case the TradeEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeEventUpdateInput, TradeEventUncheckedUpdateInput>
  }

  /**
   * TradeEvent delete
   */
  export type TradeEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
    /**
     * Filter which TradeEvent to delete.
     */
    where: TradeEventWhereUniqueInput
  }

  /**
   * TradeEvent deleteMany
   */
  export type TradeEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeEvents to delete
     */
    where?: TradeEventWhereInput
    /**
     * Limit how many TradeEvents to delete.
     */
    limit?: number
  }

  /**
   * TradeEvent without action
   */
  export type TradeEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeEvent
     */
    select?: TradeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeEvent
     */
    omit?: TradeEventOmit<ExtArgs> | null
  }


  /**
   * Model VRFCallback
   */

  export type AggregateVRFCallback = {
    _count: VRFCallbackCountAggregateOutputType | null
    _avg: VRFCallbackAvgAggregateOutputType | null
    _sum: VRFCallbackSumAggregateOutputType | null
    _min: VRFCallbackMinAggregateOutputType | null
    _max: VRFCallbackMaxAggregateOutputType | null
  }

  export type VRFCallbackAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
  }

  export type VRFCallbackSumAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
  }

  export type VRFCallbackMinAggregateOutputType = {
    id: number | null
    callerAddress: string | null
    nonce: string | null
    timestamp: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
  }

  export type VRFCallbackMaxAggregateOutputType = {
    id: number | null
    callerAddress: string | null
    nonce: string | null
    timestamp: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    network: string | null
  }

  export type VRFCallbackCountAggregateOutputType = {
    id: number
    callerAddress: number
    nonce: number
    randomNumbers: number
    timestamp: number
    createdAt: number
    updatedAt: number
    network: number
    _all: number
  }


  export type VRFCallbackAvgAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type VRFCallbackSumAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type VRFCallbackMinAggregateInputType = {
    id?: true
    callerAddress?: true
    nonce?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    network?: true
  }

  export type VRFCallbackMaxAggregateInputType = {
    id?: true
    callerAddress?: true
    nonce?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    network?: true
  }

  export type VRFCallbackCountAggregateInputType = {
    id?: true
    callerAddress?: true
    nonce?: true
    randomNumbers?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    network?: true
    _all?: true
  }

  export type VRFCallbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VRFCallback to aggregate.
     */
    where?: VRFCallbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VRFCallbacks to fetch.
     */
    orderBy?: VRFCallbackOrderByWithRelationInput | VRFCallbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VRFCallbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VRFCallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VRFCallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VRFCallbacks
    **/
    _count?: true | VRFCallbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VRFCallbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VRFCallbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VRFCallbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VRFCallbackMaxAggregateInputType
  }

  export type GetVRFCallbackAggregateType<T extends VRFCallbackAggregateArgs> = {
        [P in keyof T & keyof AggregateVRFCallback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVRFCallback[P]>
      : GetScalarType<T[P], AggregateVRFCallback[P]>
  }




  export type VRFCallbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VRFCallbackWhereInput
    orderBy?: VRFCallbackOrderByWithAggregationInput | VRFCallbackOrderByWithAggregationInput[]
    by: VRFCallbackScalarFieldEnum[] | VRFCallbackScalarFieldEnum
    having?: VRFCallbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VRFCallbackCountAggregateInputType | true
    _avg?: VRFCallbackAvgAggregateInputType
    _sum?: VRFCallbackSumAggregateInputType
    _min?: VRFCallbackMinAggregateInputType
    _max?: VRFCallbackMaxAggregateInputType
  }

  export type VRFCallbackGroupByOutputType = {
    id: number
    callerAddress: string
    nonce: string
    randomNumbers: string[]
    timestamp: bigint
    createdAt: Date
    updatedAt: Date
    network: string
    _count: VRFCallbackCountAggregateOutputType | null
    _avg: VRFCallbackAvgAggregateOutputType | null
    _sum: VRFCallbackSumAggregateOutputType | null
    _min: VRFCallbackMinAggregateOutputType | null
    _max: VRFCallbackMaxAggregateOutputType | null
  }

  type GetVRFCallbackGroupByPayload<T extends VRFCallbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VRFCallbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VRFCallbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VRFCallbackGroupByOutputType[P]>
            : GetScalarType<T[P], VRFCallbackGroupByOutputType[P]>
        }
      >
    >


  export type VRFCallbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callerAddress?: boolean
    nonce?: boolean
    randomNumbers?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
  }, ExtArgs["result"]["vRFCallback"]>

  export type VRFCallbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callerAddress?: boolean
    nonce?: boolean
    randomNumbers?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
  }, ExtArgs["result"]["vRFCallback"]>

  export type VRFCallbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callerAddress?: boolean
    nonce?: boolean
    randomNumbers?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
  }, ExtArgs["result"]["vRFCallback"]>

  export type VRFCallbackSelectScalar = {
    id?: boolean
    callerAddress?: boolean
    nonce?: boolean
    randomNumbers?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    network?: boolean
  }

  export type VRFCallbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "callerAddress" | "nonce" | "randomNumbers" | "timestamp" | "createdAt" | "updatedAt" | "network", ExtArgs["result"]["vRFCallback"]>

  export type $VRFCallbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VRFCallback"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      callerAddress: string
      nonce: string
      randomNumbers: string[]
      timestamp: bigint
      createdAt: Date
      updatedAt: Date
      network: string
    }, ExtArgs["result"]["vRFCallback"]>
    composites: {}
  }

  type VRFCallbackGetPayload<S extends boolean | null | undefined | VRFCallbackDefaultArgs> = $Result.GetResult<Prisma.$VRFCallbackPayload, S>

  type VRFCallbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VRFCallbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VRFCallbackCountAggregateInputType | true
    }

  export interface VRFCallbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VRFCallback'], meta: { name: 'VRFCallback' } }
    /**
     * Find zero or one VRFCallback that matches the filter.
     * @param {VRFCallbackFindUniqueArgs} args - Arguments to find a VRFCallback
     * @example
     * // Get one VRFCallback
     * const vRFCallback = await prisma.vRFCallback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VRFCallbackFindUniqueArgs>(args: SelectSubset<T, VRFCallbackFindUniqueArgs<ExtArgs>>): Prisma__VRFCallbackClient<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VRFCallback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VRFCallbackFindUniqueOrThrowArgs} args - Arguments to find a VRFCallback
     * @example
     * // Get one VRFCallback
     * const vRFCallback = await prisma.vRFCallback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VRFCallbackFindUniqueOrThrowArgs>(args: SelectSubset<T, VRFCallbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VRFCallbackClient<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VRFCallback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VRFCallbackFindFirstArgs} args - Arguments to find a VRFCallback
     * @example
     * // Get one VRFCallback
     * const vRFCallback = await prisma.vRFCallback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VRFCallbackFindFirstArgs>(args?: SelectSubset<T, VRFCallbackFindFirstArgs<ExtArgs>>): Prisma__VRFCallbackClient<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VRFCallback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VRFCallbackFindFirstOrThrowArgs} args - Arguments to find a VRFCallback
     * @example
     * // Get one VRFCallback
     * const vRFCallback = await prisma.vRFCallback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VRFCallbackFindFirstOrThrowArgs>(args?: SelectSubset<T, VRFCallbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__VRFCallbackClient<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VRFCallbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VRFCallbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VRFCallbacks
     * const vRFCallbacks = await prisma.vRFCallback.findMany()
     * 
     * // Get first 10 VRFCallbacks
     * const vRFCallbacks = await prisma.vRFCallback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vRFCallbackWithIdOnly = await prisma.vRFCallback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VRFCallbackFindManyArgs>(args?: SelectSubset<T, VRFCallbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VRFCallback.
     * @param {VRFCallbackCreateArgs} args - Arguments to create a VRFCallback.
     * @example
     * // Create one VRFCallback
     * const VRFCallback = await prisma.vRFCallback.create({
     *   data: {
     *     // ... data to create a VRFCallback
     *   }
     * })
     * 
     */
    create<T extends VRFCallbackCreateArgs>(args: SelectSubset<T, VRFCallbackCreateArgs<ExtArgs>>): Prisma__VRFCallbackClient<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VRFCallbacks.
     * @param {VRFCallbackCreateManyArgs} args - Arguments to create many VRFCallbacks.
     * @example
     * // Create many VRFCallbacks
     * const vRFCallback = await prisma.vRFCallback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VRFCallbackCreateManyArgs>(args?: SelectSubset<T, VRFCallbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VRFCallbacks and returns the data saved in the database.
     * @param {VRFCallbackCreateManyAndReturnArgs} args - Arguments to create many VRFCallbacks.
     * @example
     * // Create many VRFCallbacks
     * const vRFCallback = await prisma.vRFCallback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VRFCallbacks and only return the `id`
     * const vRFCallbackWithIdOnly = await prisma.vRFCallback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VRFCallbackCreateManyAndReturnArgs>(args?: SelectSubset<T, VRFCallbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VRFCallback.
     * @param {VRFCallbackDeleteArgs} args - Arguments to delete one VRFCallback.
     * @example
     * // Delete one VRFCallback
     * const VRFCallback = await prisma.vRFCallback.delete({
     *   where: {
     *     // ... filter to delete one VRFCallback
     *   }
     * })
     * 
     */
    delete<T extends VRFCallbackDeleteArgs>(args: SelectSubset<T, VRFCallbackDeleteArgs<ExtArgs>>): Prisma__VRFCallbackClient<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VRFCallback.
     * @param {VRFCallbackUpdateArgs} args - Arguments to update one VRFCallback.
     * @example
     * // Update one VRFCallback
     * const vRFCallback = await prisma.vRFCallback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VRFCallbackUpdateArgs>(args: SelectSubset<T, VRFCallbackUpdateArgs<ExtArgs>>): Prisma__VRFCallbackClient<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VRFCallbacks.
     * @param {VRFCallbackDeleteManyArgs} args - Arguments to filter VRFCallbacks to delete.
     * @example
     * // Delete a few VRFCallbacks
     * const { count } = await prisma.vRFCallback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VRFCallbackDeleteManyArgs>(args?: SelectSubset<T, VRFCallbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VRFCallbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VRFCallbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VRFCallbacks
     * const vRFCallback = await prisma.vRFCallback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VRFCallbackUpdateManyArgs>(args: SelectSubset<T, VRFCallbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VRFCallbacks and returns the data updated in the database.
     * @param {VRFCallbackUpdateManyAndReturnArgs} args - Arguments to update many VRFCallbacks.
     * @example
     * // Update many VRFCallbacks
     * const vRFCallback = await prisma.vRFCallback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VRFCallbacks and only return the `id`
     * const vRFCallbackWithIdOnly = await prisma.vRFCallback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VRFCallbackUpdateManyAndReturnArgs>(args: SelectSubset<T, VRFCallbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VRFCallback.
     * @param {VRFCallbackUpsertArgs} args - Arguments to update or create a VRFCallback.
     * @example
     * // Update or create a VRFCallback
     * const vRFCallback = await prisma.vRFCallback.upsert({
     *   create: {
     *     // ... data to create a VRFCallback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VRFCallback we want to update
     *   }
     * })
     */
    upsert<T extends VRFCallbackUpsertArgs>(args: SelectSubset<T, VRFCallbackUpsertArgs<ExtArgs>>): Prisma__VRFCallbackClient<$Result.GetResult<Prisma.$VRFCallbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VRFCallbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VRFCallbackCountArgs} args - Arguments to filter VRFCallbacks to count.
     * @example
     * // Count the number of VRFCallbacks
     * const count = await prisma.vRFCallback.count({
     *   where: {
     *     // ... the filter for the VRFCallbacks we want to count
     *   }
     * })
    **/
    count<T extends VRFCallbackCountArgs>(
      args?: Subset<T, VRFCallbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VRFCallbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VRFCallback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VRFCallbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VRFCallbackAggregateArgs>(args: Subset<T, VRFCallbackAggregateArgs>): Prisma.PrismaPromise<GetVRFCallbackAggregateType<T>>

    /**
     * Group by VRFCallback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VRFCallbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VRFCallbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VRFCallbackGroupByArgs['orderBy'] }
        : { orderBy?: VRFCallbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VRFCallbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVRFCallbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VRFCallback model
   */
  readonly fields: VRFCallbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VRFCallback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VRFCallbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VRFCallback model
   */
  interface VRFCallbackFieldRefs {
    readonly id: FieldRef<"VRFCallback", 'Int'>
    readonly callerAddress: FieldRef<"VRFCallback", 'String'>
    readonly nonce: FieldRef<"VRFCallback", 'String'>
    readonly randomNumbers: FieldRef<"VRFCallback", 'String[]'>
    readonly timestamp: FieldRef<"VRFCallback", 'BigInt'>
    readonly createdAt: FieldRef<"VRFCallback", 'DateTime'>
    readonly updatedAt: FieldRef<"VRFCallback", 'DateTime'>
    readonly network: FieldRef<"VRFCallback", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VRFCallback findUnique
   */
  export type VRFCallbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * Filter, which VRFCallback to fetch.
     */
    where: VRFCallbackWhereUniqueInput
  }

  /**
   * VRFCallback findUniqueOrThrow
   */
  export type VRFCallbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * Filter, which VRFCallback to fetch.
     */
    where: VRFCallbackWhereUniqueInput
  }

  /**
   * VRFCallback findFirst
   */
  export type VRFCallbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * Filter, which VRFCallback to fetch.
     */
    where?: VRFCallbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VRFCallbacks to fetch.
     */
    orderBy?: VRFCallbackOrderByWithRelationInput | VRFCallbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VRFCallbacks.
     */
    cursor?: VRFCallbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VRFCallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VRFCallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VRFCallbacks.
     */
    distinct?: VRFCallbackScalarFieldEnum | VRFCallbackScalarFieldEnum[]
  }

  /**
   * VRFCallback findFirstOrThrow
   */
  export type VRFCallbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * Filter, which VRFCallback to fetch.
     */
    where?: VRFCallbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VRFCallbacks to fetch.
     */
    orderBy?: VRFCallbackOrderByWithRelationInput | VRFCallbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VRFCallbacks.
     */
    cursor?: VRFCallbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VRFCallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VRFCallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VRFCallbacks.
     */
    distinct?: VRFCallbackScalarFieldEnum | VRFCallbackScalarFieldEnum[]
  }

  /**
   * VRFCallback findMany
   */
  export type VRFCallbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * Filter, which VRFCallbacks to fetch.
     */
    where?: VRFCallbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VRFCallbacks to fetch.
     */
    orderBy?: VRFCallbackOrderByWithRelationInput | VRFCallbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VRFCallbacks.
     */
    cursor?: VRFCallbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VRFCallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VRFCallbacks.
     */
    skip?: number
    distinct?: VRFCallbackScalarFieldEnum | VRFCallbackScalarFieldEnum[]
  }

  /**
   * VRFCallback create
   */
  export type VRFCallbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * The data needed to create a VRFCallback.
     */
    data: XOR<VRFCallbackCreateInput, VRFCallbackUncheckedCreateInput>
  }

  /**
   * VRFCallback createMany
   */
  export type VRFCallbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VRFCallbacks.
     */
    data: VRFCallbackCreateManyInput | VRFCallbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VRFCallback createManyAndReturn
   */
  export type VRFCallbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * The data used to create many VRFCallbacks.
     */
    data: VRFCallbackCreateManyInput | VRFCallbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VRFCallback update
   */
  export type VRFCallbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * The data needed to update a VRFCallback.
     */
    data: XOR<VRFCallbackUpdateInput, VRFCallbackUncheckedUpdateInput>
    /**
     * Choose, which VRFCallback to update.
     */
    where: VRFCallbackWhereUniqueInput
  }

  /**
   * VRFCallback updateMany
   */
  export type VRFCallbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VRFCallbacks.
     */
    data: XOR<VRFCallbackUpdateManyMutationInput, VRFCallbackUncheckedUpdateManyInput>
    /**
     * Filter which VRFCallbacks to update
     */
    where?: VRFCallbackWhereInput
    /**
     * Limit how many VRFCallbacks to update.
     */
    limit?: number
  }

  /**
   * VRFCallback updateManyAndReturn
   */
  export type VRFCallbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * The data used to update VRFCallbacks.
     */
    data: XOR<VRFCallbackUpdateManyMutationInput, VRFCallbackUncheckedUpdateManyInput>
    /**
     * Filter which VRFCallbacks to update
     */
    where?: VRFCallbackWhereInput
    /**
     * Limit how many VRFCallbacks to update.
     */
    limit?: number
  }

  /**
   * VRFCallback upsert
   */
  export type VRFCallbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * The filter to search for the VRFCallback to update in case it exists.
     */
    where: VRFCallbackWhereUniqueInput
    /**
     * In case the VRFCallback found by the `where` argument doesn't exist, create a new VRFCallback with this data.
     */
    create: XOR<VRFCallbackCreateInput, VRFCallbackUncheckedCreateInput>
    /**
     * In case the VRFCallback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VRFCallbackUpdateInput, VRFCallbackUncheckedUpdateInput>
  }

  /**
   * VRFCallback delete
   */
  export type VRFCallbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
    /**
     * Filter which VRFCallback to delete.
     */
    where: VRFCallbackWhereUniqueInput
  }

  /**
   * VRFCallback deleteMany
   */
  export type VRFCallbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VRFCallbacks to delete
     */
    where?: VRFCallbackWhereInput
    /**
     * Limit how many VRFCallbacks to delete.
     */
    limit?: number
  }

  /**
   * VRFCallback without action
   */
  export type VRFCallbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VRFCallback
     */
    select?: VRFCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VRFCallback
     */
    omit?: VRFCallbackOmit<ExtArgs> | null
  }


  /**
   * Model block_progress
   */

  export type AggregateBlock_progress = {
    _count: Block_progressCountAggregateOutputType | null
    _avg: Block_progressAvgAggregateOutputType | null
    _sum: Block_progressSumAggregateOutputType | null
    _min: Block_progressMinAggregateOutputType | null
    _max: Block_progressMaxAggregateOutputType | null
  }

  export type Block_progressAvgAggregateOutputType = {
    lastBlockHeight: number | null
  }

  export type Block_progressSumAggregateOutputType = {
    lastBlockHeight: bigint | null
  }

  export type Block_progressMinAggregateOutputType = {
    network: string | null
    lastBlockHeight: bigint | null
    updatedAt: Date | null
  }

  export type Block_progressMaxAggregateOutputType = {
    network: string | null
    lastBlockHeight: bigint | null
    updatedAt: Date | null
  }

  export type Block_progressCountAggregateOutputType = {
    network: number
    lastBlockHeight: number
    updatedAt: number
    _all: number
  }


  export type Block_progressAvgAggregateInputType = {
    lastBlockHeight?: true
  }

  export type Block_progressSumAggregateInputType = {
    lastBlockHeight?: true
  }

  export type Block_progressMinAggregateInputType = {
    network?: true
    lastBlockHeight?: true
    updatedAt?: true
  }

  export type Block_progressMaxAggregateInputType = {
    network?: true
    lastBlockHeight?: true
    updatedAt?: true
  }

  export type Block_progressCountAggregateInputType = {
    network?: true
    lastBlockHeight?: true
    updatedAt?: true
    _all?: true
  }

  export type Block_progressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which block_progress to aggregate.
     */
    where?: block_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of block_progresses to fetch.
     */
    orderBy?: block_progressOrderByWithRelationInput | block_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: block_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` block_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` block_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned block_progresses
    **/
    _count?: true | Block_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Block_progressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Block_progressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Block_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Block_progressMaxAggregateInputType
  }

  export type GetBlock_progressAggregateType<T extends Block_progressAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock_progress[P]>
      : GetScalarType<T[P], AggregateBlock_progress[P]>
  }




  export type block_progressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: block_progressWhereInput
    orderBy?: block_progressOrderByWithAggregationInput | block_progressOrderByWithAggregationInput[]
    by: Block_progressScalarFieldEnum[] | Block_progressScalarFieldEnum
    having?: block_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Block_progressCountAggregateInputType | true
    _avg?: Block_progressAvgAggregateInputType
    _sum?: Block_progressSumAggregateInputType
    _min?: Block_progressMinAggregateInputType
    _max?: Block_progressMaxAggregateInputType
  }

  export type Block_progressGroupByOutputType = {
    network: string
    lastBlockHeight: bigint
    updatedAt: Date
    _count: Block_progressCountAggregateOutputType | null
    _avg: Block_progressAvgAggregateOutputType | null
    _sum: Block_progressSumAggregateOutputType | null
    _min: Block_progressMinAggregateOutputType | null
    _max: Block_progressMaxAggregateOutputType | null
  }

  type GetBlock_progressGroupByPayload<T extends block_progressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Block_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Block_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Block_progressGroupByOutputType[P]>
            : GetScalarType<T[P], Block_progressGroupByOutputType[P]>
        }
      >
    >


  export type block_progressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    network?: boolean
    lastBlockHeight?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["block_progress"]>

  export type block_progressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    network?: boolean
    lastBlockHeight?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["block_progress"]>

  export type block_progressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    network?: boolean
    lastBlockHeight?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["block_progress"]>

  export type block_progressSelectScalar = {
    network?: boolean
    lastBlockHeight?: boolean
    updatedAt?: boolean
  }

  export type block_progressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"network" | "lastBlockHeight" | "updatedAt", ExtArgs["result"]["block_progress"]>

  export type $block_progressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "block_progress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      network: string
      lastBlockHeight: bigint
      updatedAt: Date
    }, ExtArgs["result"]["block_progress"]>
    composites: {}
  }

  type block_progressGetPayload<S extends boolean | null | undefined | block_progressDefaultArgs> = $Result.GetResult<Prisma.$block_progressPayload, S>

  type block_progressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<block_progressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Block_progressCountAggregateInputType | true
    }

  export interface block_progressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['block_progress'], meta: { name: 'block_progress' } }
    /**
     * Find zero or one Block_progress that matches the filter.
     * @param {block_progressFindUniqueArgs} args - Arguments to find a Block_progress
     * @example
     * // Get one Block_progress
     * const block_progress = await prisma.block_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends block_progressFindUniqueArgs>(args: SelectSubset<T, block_progressFindUniqueArgs<ExtArgs>>): Prisma__block_progressClient<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Block_progress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {block_progressFindUniqueOrThrowArgs} args - Arguments to find a Block_progress
     * @example
     * // Get one Block_progress
     * const block_progress = await prisma.block_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends block_progressFindUniqueOrThrowArgs>(args: SelectSubset<T, block_progressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__block_progressClient<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_progressFindFirstArgs} args - Arguments to find a Block_progress
     * @example
     * // Get one Block_progress
     * const block_progress = await prisma.block_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends block_progressFindFirstArgs>(args?: SelectSubset<T, block_progressFindFirstArgs<ExtArgs>>): Prisma__block_progressClient<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block_progress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_progressFindFirstOrThrowArgs} args - Arguments to find a Block_progress
     * @example
     * // Get one Block_progress
     * const block_progress = await prisma.block_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends block_progressFindFirstOrThrowArgs>(args?: SelectSubset<T, block_progressFindFirstOrThrowArgs<ExtArgs>>): Prisma__block_progressClient<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Block_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_progressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Block_progresses
     * const block_progresses = await prisma.block_progress.findMany()
     * 
     * // Get first 10 Block_progresses
     * const block_progresses = await prisma.block_progress.findMany({ take: 10 })
     * 
     * // Only select the `network`
     * const block_progressWithNetworkOnly = await prisma.block_progress.findMany({ select: { network: true } })
     * 
     */
    findMany<T extends block_progressFindManyArgs>(args?: SelectSubset<T, block_progressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Block_progress.
     * @param {block_progressCreateArgs} args - Arguments to create a Block_progress.
     * @example
     * // Create one Block_progress
     * const Block_progress = await prisma.block_progress.create({
     *   data: {
     *     // ... data to create a Block_progress
     *   }
     * })
     * 
     */
    create<T extends block_progressCreateArgs>(args: SelectSubset<T, block_progressCreateArgs<ExtArgs>>): Prisma__block_progressClient<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Block_progresses.
     * @param {block_progressCreateManyArgs} args - Arguments to create many Block_progresses.
     * @example
     * // Create many Block_progresses
     * const block_progress = await prisma.block_progress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends block_progressCreateManyArgs>(args?: SelectSubset<T, block_progressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Block_progresses and returns the data saved in the database.
     * @param {block_progressCreateManyAndReturnArgs} args - Arguments to create many Block_progresses.
     * @example
     * // Create many Block_progresses
     * const block_progress = await prisma.block_progress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Block_progresses and only return the `network`
     * const block_progressWithNetworkOnly = await prisma.block_progress.createManyAndReturn({
     *   select: { network: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends block_progressCreateManyAndReturnArgs>(args?: SelectSubset<T, block_progressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Block_progress.
     * @param {block_progressDeleteArgs} args - Arguments to delete one Block_progress.
     * @example
     * // Delete one Block_progress
     * const Block_progress = await prisma.block_progress.delete({
     *   where: {
     *     // ... filter to delete one Block_progress
     *   }
     * })
     * 
     */
    delete<T extends block_progressDeleteArgs>(args: SelectSubset<T, block_progressDeleteArgs<ExtArgs>>): Prisma__block_progressClient<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Block_progress.
     * @param {block_progressUpdateArgs} args - Arguments to update one Block_progress.
     * @example
     * // Update one Block_progress
     * const block_progress = await prisma.block_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends block_progressUpdateArgs>(args: SelectSubset<T, block_progressUpdateArgs<ExtArgs>>): Prisma__block_progressClient<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Block_progresses.
     * @param {block_progressDeleteManyArgs} args - Arguments to filter Block_progresses to delete.
     * @example
     * // Delete a few Block_progresses
     * const { count } = await prisma.block_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends block_progressDeleteManyArgs>(args?: SelectSubset<T, block_progressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Block_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Block_progresses
     * const block_progress = await prisma.block_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends block_progressUpdateManyArgs>(args: SelectSubset<T, block_progressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Block_progresses and returns the data updated in the database.
     * @param {block_progressUpdateManyAndReturnArgs} args - Arguments to update many Block_progresses.
     * @example
     * // Update many Block_progresses
     * const block_progress = await prisma.block_progress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Block_progresses and only return the `network`
     * const block_progressWithNetworkOnly = await prisma.block_progress.updateManyAndReturn({
     *   select: { network: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends block_progressUpdateManyAndReturnArgs>(args: SelectSubset<T, block_progressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Block_progress.
     * @param {block_progressUpsertArgs} args - Arguments to update or create a Block_progress.
     * @example
     * // Update or create a Block_progress
     * const block_progress = await prisma.block_progress.upsert({
     *   create: {
     *     // ... data to create a Block_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block_progress we want to update
     *   }
     * })
     */
    upsert<T extends block_progressUpsertArgs>(args: SelectSubset<T, block_progressUpsertArgs<ExtArgs>>): Prisma__block_progressClient<$Result.GetResult<Prisma.$block_progressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Block_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_progressCountArgs} args - Arguments to filter Block_progresses to count.
     * @example
     * // Count the number of Block_progresses
     * const count = await prisma.block_progress.count({
     *   where: {
     *     // ... the filter for the Block_progresses we want to count
     *   }
     * })
    **/
    count<T extends block_progressCountArgs>(
      args?: Subset<T, block_progressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Block_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Block_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Block_progressAggregateArgs>(args: Subset<T, Block_progressAggregateArgs>): Prisma.PrismaPromise<GetBlock_progressAggregateType<T>>

    /**
     * Group by Block_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends block_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: block_progressGroupByArgs['orderBy'] }
        : { orderBy?: block_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, block_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlock_progressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the block_progress model
   */
  readonly fields: block_progressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for block_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__block_progressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the block_progress model
   */
  interface block_progressFieldRefs {
    readonly network: FieldRef<"block_progress", 'String'>
    readonly lastBlockHeight: FieldRef<"block_progress", 'BigInt'>
    readonly updatedAt: FieldRef<"block_progress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * block_progress findUnique
   */
  export type block_progressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * Filter, which block_progress to fetch.
     */
    where: block_progressWhereUniqueInput
  }

  /**
   * block_progress findUniqueOrThrow
   */
  export type block_progressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * Filter, which block_progress to fetch.
     */
    where: block_progressWhereUniqueInput
  }

  /**
   * block_progress findFirst
   */
  export type block_progressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * Filter, which block_progress to fetch.
     */
    where?: block_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of block_progresses to fetch.
     */
    orderBy?: block_progressOrderByWithRelationInput | block_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for block_progresses.
     */
    cursor?: block_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` block_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` block_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of block_progresses.
     */
    distinct?: Block_progressScalarFieldEnum | Block_progressScalarFieldEnum[]
  }

  /**
   * block_progress findFirstOrThrow
   */
  export type block_progressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * Filter, which block_progress to fetch.
     */
    where?: block_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of block_progresses to fetch.
     */
    orderBy?: block_progressOrderByWithRelationInput | block_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for block_progresses.
     */
    cursor?: block_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` block_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` block_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of block_progresses.
     */
    distinct?: Block_progressScalarFieldEnum | Block_progressScalarFieldEnum[]
  }

  /**
   * block_progress findMany
   */
  export type block_progressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * Filter, which block_progresses to fetch.
     */
    where?: block_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of block_progresses to fetch.
     */
    orderBy?: block_progressOrderByWithRelationInput | block_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing block_progresses.
     */
    cursor?: block_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` block_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` block_progresses.
     */
    skip?: number
    distinct?: Block_progressScalarFieldEnum | Block_progressScalarFieldEnum[]
  }

  /**
   * block_progress create
   */
  export type block_progressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * The data needed to create a block_progress.
     */
    data: XOR<block_progressCreateInput, block_progressUncheckedCreateInput>
  }

  /**
   * block_progress createMany
   */
  export type block_progressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many block_progresses.
     */
    data: block_progressCreateManyInput | block_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * block_progress createManyAndReturn
   */
  export type block_progressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * The data used to create many block_progresses.
     */
    data: block_progressCreateManyInput | block_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * block_progress update
   */
  export type block_progressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * The data needed to update a block_progress.
     */
    data: XOR<block_progressUpdateInput, block_progressUncheckedUpdateInput>
    /**
     * Choose, which block_progress to update.
     */
    where: block_progressWhereUniqueInput
  }

  /**
   * block_progress updateMany
   */
  export type block_progressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update block_progresses.
     */
    data: XOR<block_progressUpdateManyMutationInput, block_progressUncheckedUpdateManyInput>
    /**
     * Filter which block_progresses to update
     */
    where?: block_progressWhereInput
    /**
     * Limit how many block_progresses to update.
     */
    limit?: number
  }

  /**
   * block_progress updateManyAndReturn
   */
  export type block_progressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * The data used to update block_progresses.
     */
    data: XOR<block_progressUpdateManyMutationInput, block_progressUncheckedUpdateManyInput>
    /**
     * Filter which block_progresses to update
     */
    where?: block_progressWhereInput
    /**
     * Limit how many block_progresses to update.
     */
    limit?: number
  }

  /**
   * block_progress upsert
   */
  export type block_progressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * The filter to search for the block_progress to update in case it exists.
     */
    where: block_progressWhereUniqueInput
    /**
     * In case the block_progress found by the `where` argument doesn't exist, create a new block_progress with this data.
     */
    create: XOR<block_progressCreateInput, block_progressUncheckedCreateInput>
    /**
     * In case the block_progress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<block_progressUpdateInput, block_progressUncheckedUpdateInput>
  }

  /**
   * block_progress delete
   */
  export type block_progressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
    /**
     * Filter which block_progress to delete.
     */
    where: block_progressWhereUniqueInput
  }

  /**
   * block_progress deleteMany
   */
  export type block_progressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which block_progresses to delete
     */
    where?: block_progressWhereInput
    /**
     * Limit how many block_progresses to delete.
     */
    limit?: number
  }

  /**
   * block_progress without action
   */
  export type block_progressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_progress
     */
    select?: block_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_progress
     */
    omit?: block_progressOmit<ExtArgs> | null
  }


  /**
   * Model comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    id: number | null
    poolId: number | null
    displayOrder: number | null
    likeCount: number | null
  }

  export type CommentsSumAggregateOutputType = {
    id: number | null
    poolId: number | null
    displayOrder: number | null
    likeCount: number | null
  }

  export type CommentsMinAggregateOutputType = {
    id: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
    poolId: number | null
    network: string | null
    userNetwork: string | null
    userWalletAddress: string | null
    displayOrder: number | null
    likeCount: number | null
    poolNetwork: string | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
    poolId: number | null
    network: string | null
    userNetwork: string | null
    userWalletAddress: string | null
    displayOrder: number | null
    likeCount: number | null
    poolNetwork: string | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    text: number
    createdAt: number
    updatedAt: number
    poolId: number
    network: number
    userNetwork: number
    userWalletAddress: number
    displayOrder: number
    likeCount: number
    poolNetwork: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    id?: true
    poolId?: true
    displayOrder?: true
    likeCount?: true
  }

  export type CommentsSumAggregateInputType = {
    id?: true
    poolId?: true
    displayOrder?: true
    likeCount?: true
  }

  export type CommentsMinAggregateInputType = {
    id?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    poolId?: true
    network?: true
    userNetwork?: true
    userWalletAddress?: true
    displayOrder?: true
    likeCount?: true
    poolNetwork?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    poolId?: true
    network?: true
    userNetwork?: true
    userWalletAddress?: true
    displayOrder?: true
    likeCount?: true
    poolNetwork?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    poolId?: true
    network?: true
    userNetwork?: true
    userWalletAddress?: true
    displayOrder?: true
    likeCount?: true
    poolNetwork?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithAggregationInput | commentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    id: number
    text: string
    createdAt: Date
    updatedAt: Date
    poolId: number
    network: string
    userNetwork: string
    userWalletAddress: string
    displayOrder: number | null
    likeCount: number
    poolNetwork: string
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    poolId?: boolean
    network?: boolean
    userNetwork?: boolean
    userWalletAddress?: boolean
    displayOrder?: boolean
    likeCount?: boolean
    poolNetwork?: boolean
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    images?: boolean | comments$imagesArgs<ExtArgs>
    likes?: boolean | comments$likesArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    poolId?: boolean
    network?: boolean
    userNetwork?: boolean
    userWalletAddress?: boolean
    displayOrder?: boolean
    likeCount?: boolean
    poolNetwork?: boolean
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    poolId?: boolean
    network?: boolean
    userNetwork?: boolean
    userWalletAddress?: boolean
    displayOrder?: boolean
    likeCount?: boolean
    poolNetwork?: boolean
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectScalar = {
    id?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    poolId?: boolean
    network?: boolean
    userNetwork?: boolean
    userWalletAddress?: boolean
    displayOrder?: boolean
    likeCount?: boolean
    poolNetwork?: boolean
  }

  export type commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "createdAt" | "updatedAt" | "poolId" | "network" | "userNetwork" | "userWalletAddress" | "displayOrder" | "likeCount" | "poolNetwork", ExtArgs["result"]["comments"]>
  export type commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    images?: boolean | comments$imagesArgs<ExtArgs>
    likes?: boolean | comments$likesArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type commentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type commentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comments"
    objects: {
      PoolsDB: Prisma.$PoolsDBPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
      images: Prisma.$imagesPayload<ExtArgs>[]
      likes: Prisma.$likesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      text: string
      createdAt: Date
      updatedAt: Date
      poolId: number
      network: string
      userNetwork: string
      userWalletAddress: string
      displayOrder: number | null
      likeCount: number
      poolNetwork: string
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type commentsGetPayload<S extends boolean | null | undefined | commentsDefaultArgs> = $Result.GetResult<Prisma.$commentsPayload, S>

  type commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentsFindUniqueArgs>(args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentsFindFirstArgs>(args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends commentsFindManyArgs>(args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends commentsCreateArgs>(args: SelectSubset<T, commentsCreateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commentsCreateManyArgs>(args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {commentsCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends commentsCreateManyAndReturnArgs>(args?: SelectSubset<T, commentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends commentsDeleteArgs>(args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commentsUpdateArgs>(args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commentsDeleteManyArgs>(args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commentsUpdateManyArgs>(args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {commentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends commentsUpdateManyAndReturnArgs>(args: SelectSubset<T, commentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends commentsUpsertArgs>(args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentsGroupByArgs['orderBy'] }
        : { orderBy?: commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comments model
   */
  readonly fields: commentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PoolsDB<T extends PoolsDBDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoolsDBDefaultArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends comments$imagesArgs<ExtArgs> = {}>(args?: Subset<T, comments$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends comments$likesArgs<ExtArgs> = {}>(args?: Subset<T, comments$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comments model
   */
  interface commentsFieldRefs {
    readonly id: FieldRef<"comments", 'Int'>
    readonly text: FieldRef<"comments", 'String'>
    readonly createdAt: FieldRef<"comments", 'DateTime'>
    readonly updatedAt: FieldRef<"comments", 'DateTime'>
    readonly poolId: FieldRef<"comments", 'Int'>
    readonly network: FieldRef<"comments", 'String'>
    readonly userNetwork: FieldRef<"comments", 'String'>
    readonly userWalletAddress: FieldRef<"comments", 'String'>
    readonly displayOrder: FieldRef<"comments", 'Int'>
    readonly likeCount: FieldRef<"comments", 'Int'>
    readonly poolNetwork: FieldRef<"comments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * comments findUnique
   */
  export type commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findFirst
   */
  export type commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findMany
   */
  export type commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments create
   */
  export type commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to create a comments.
     */
    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>
  }

  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comments createManyAndReturn
   */
  export type commentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comments update
   */
  export type commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
  }

  /**
   * comments updateManyAndReturn
   */
  export type commentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comments upsert
   */
  export type commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
  }

  /**
   * comments delete
   */
  export type commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to delete.
     */
    limit?: number
  }

  /**
   * comments.images
   */
  export type comments$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    cursor?: imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * comments.likes
   */
  export type comments$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    where?: likesWhereInput
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    cursor?: likesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * comments without action
   */
  export type commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
  }


  /**
   * Model images
   */

  export type AggregateImages = {
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  export type ImagesAvgAggregateOutputType = {
    id: number | null
    commentId: number | null
  }

  export type ImagesSumAggregateOutputType = {
    id: number | null
    commentId: number | null
  }

  export type ImagesMinAggregateOutputType = {
    id: number | null
    url: string | null
    altText: string | null
    createdAt: Date | null
    commentId: number | null
  }

  export type ImagesMaxAggregateOutputType = {
    id: number | null
    url: string | null
    altText: string | null
    createdAt: Date | null
    commentId: number | null
  }

  export type ImagesCountAggregateOutputType = {
    id: number
    url: number
    altText: number
    createdAt: number
    commentId: number
    _all: number
  }


  export type ImagesAvgAggregateInputType = {
    id?: true
    commentId?: true
  }

  export type ImagesSumAggregateInputType = {
    id?: true
    commentId?: true
  }

  export type ImagesMinAggregateInputType = {
    id?: true
    url?: true
    altText?: true
    createdAt?: true
    commentId?: true
  }

  export type ImagesMaxAggregateInputType = {
    id?: true
    url?: true
    altText?: true
    createdAt?: true
    commentId?: true
  }

  export type ImagesCountAggregateInputType = {
    id?: true
    url?: true
    altText?: true
    createdAt?: true
    commentId?: true
    _all?: true
  }

  export type ImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images to aggregate.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned images
    **/
    _count?: true | ImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagesMaxAggregateInputType
  }

  export type GetImagesAggregateType<T extends ImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImages[P]>
      : GetScalarType<T[P], AggregateImages[P]>
  }




  export type imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithAggregationInput | imagesOrderByWithAggregationInput[]
    by: ImagesScalarFieldEnum[] | ImagesScalarFieldEnum
    having?: imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagesCountAggregateInputType | true
    _avg?: ImagesAvgAggregateInputType
    _sum?: ImagesSumAggregateInputType
    _min?: ImagesMinAggregateInputType
    _max?: ImagesMaxAggregateInputType
  }

  export type ImagesGroupByOutputType = {
    id: number
    url: string
    altText: string | null
    createdAt: Date
    commentId: number
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  type GetImagesGroupByPayload<T extends imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ImagesGroupByOutputType[P]>
        }
      >
    >


  export type imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    altText?: boolean
    createdAt?: boolean
    commentId?: boolean
    comments?: boolean | commentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>

  export type imagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    altText?: boolean
    createdAt?: boolean
    commentId?: boolean
    comments?: boolean | commentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>

  export type imagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    altText?: boolean
    createdAt?: boolean
    commentId?: boolean
    comments?: boolean | commentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>

  export type imagesSelectScalar = {
    id?: boolean
    url?: boolean
    altText?: boolean
    createdAt?: boolean
    commentId?: boolean
  }

  export type imagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "altText" | "createdAt" | "commentId", ExtArgs["result"]["images"]>
  export type imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | commentsDefaultArgs<ExtArgs>
  }
  export type imagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | commentsDefaultArgs<ExtArgs>
  }
  export type imagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | commentsDefaultArgs<ExtArgs>
  }

  export type $imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "images"
    objects: {
      comments: Prisma.$commentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      altText: string | null
      createdAt: Date
      commentId: number
    }, ExtArgs["result"]["images"]>
    composites: {}
  }

  type imagesGetPayload<S extends boolean | null | undefined | imagesDefaultArgs> = $Result.GetResult<Prisma.$imagesPayload, S>

  type imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<imagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagesCountAggregateInputType | true
    }

  export interface imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['images'], meta: { name: 'images' } }
    /**
     * Find zero or one Images that matches the filter.
     * @param {imagesFindUniqueArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends imagesFindUniqueArgs>(args: SelectSubset<T, imagesFindUniqueArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Images that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {imagesFindUniqueOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends imagesFindFirstArgs>(args?: SelectSubset<T, imagesFindFirstArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.images.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagesWithIdOnly = await prisma.images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends imagesFindManyArgs>(args?: SelectSubset<T, imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Images.
     * @param {imagesCreateArgs} args - Arguments to create a Images.
     * @example
     * // Create one Images
     * const Images = await prisma.images.create({
     *   data: {
     *     // ... data to create a Images
     *   }
     * })
     * 
     */
    create<T extends imagesCreateArgs>(args: SelectSubset<T, imagesCreateArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {imagesCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const images = await prisma.images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends imagesCreateManyArgs>(args?: SelectSubset<T, imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {imagesCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const images = await prisma.images.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imagesWithIdOnly = await prisma.images.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends imagesCreateManyAndReturnArgs>(args?: SelectSubset<T, imagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Images.
     * @param {imagesDeleteArgs} args - Arguments to delete one Images.
     * @example
     * // Delete one Images
     * const Images = await prisma.images.delete({
     *   where: {
     *     // ... filter to delete one Images
     *   }
     * })
     * 
     */
    delete<T extends imagesDeleteArgs>(args: SelectSubset<T, imagesDeleteArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Images.
     * @param {imagesUpdateArgs} args - Arguments to update one Images.
     * @example
     * // Update one Images
     * const images = await prisma.images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends imagesUpdateArgs>(args: SelectSubset<T, imagesUpdateArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {imagesDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends imagesDeleteManyArgs>(args?: SelectSubset<T, imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends imagesUpdateManyArgs>(args: SelectSubset<T, imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {imagesUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `id`
     * const imagesWithIdOnly = await prisma.images.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends imagesUpdateManyAndReturnArgs>(args: SelectSubset<T, imagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Images.
     * @param {imagesUpsertArgs} args - Arguments to update or create a Images.
     * @example
     * // Update or create a Images
     * const images = await prisma.images.upsert({
     *   create: {
     *     // ... data to create a Images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Images we want to update
     *   }
     * })
     */
    upsert<T extends imagesUpsertArgs>(args: SelectSubset<T, imagesUpsertArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.images.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends imagesCountArgs>(
      args?: Subset<T, imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagesAggregateArgs>(args: Subset<T, ImagesAggregateArgs>): Prisma.PrismaPromise<GetImagesAggregateType<T>>

    /**
     * Group by Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: imagesGroupByArgs['orderBy'] }
        : { orderBy?: imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the images model
   */
  readonly fields: imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends commentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, commentsDefaultArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the images model
   */
  interface imagesFieldRefs {
    readonly id: FieldRef<"images", 'Int'>
    readonly url: FieldRef<"images", 'String'>
    readonly altText: FieldRef<"images", 'String'>
    readonly createdAt: FieldRef<"images", 'DateTime'>
    readonly commentId: FieldRef<"images", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * images findUnique
   */
  export type imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images findUniqueOrThrow
   */
  export type imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images findFirst
   */
  export type imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images findFirstOrThrow
   */
  export type imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images findMany
   */
  export type imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images create
   */
  export type imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a images.
     */
    data: XOR<imagesCreateInput, imagesUncheckedCreateInput>
  }

  /**
   * images createMany
   */
  export type imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many images.
     */
    data: imagesCreateManyInput | imagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * images createManyAndReturn
   */
  export type imagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * The data used to create many images.
     */
    data: imagesCreateManyInput | imagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * images update
   */
  export type imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a images.
     */
    data: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
    /**
     * Choose, which images to update.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images updateMany
   */
  export type imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update images.
     */
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyInput>
    /**
     * Filter which images to update
     */
    where?: imagesWhereInput
    /**
     * Limit how many images to update.
     */
    limit?: number
  }

  /**
   * images updateManyAndReturn
   */
  export type imagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * The data used to update images.
     */
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyInput>
    /**
     * Filter which images to update
     */
    where?: imagesWhereInput
    /**
     * Limit how many images to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * images upsert
   */
  export type imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the images to update in case it exists.
     */
    where: imagesWhereUniqueInput
    /**
     * In case the images found by the `where` argument doesn't exist, create a new images with this data.
     */
    create: XOR<imagesCreateInput, imagesUncheckedCreateInput>
    /**
     * In case the images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
  }

  /**
   * images delete
   */
  export type imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter which images to delete.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images deleteMany
   */
  export type imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images to delete
     */
    where?: imagesWhereInput
    /**
     * Limit how many images to delete.
     */
    limit?: number
  }

  /**
   * images without action
   */
  export type imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
  }


  /**
   * Model likes
   */

  export type AggregateLikes = {
    _count: LikesCountAggregateOutputType | null
    _avg: LikesAvgAggregateOutputType | null
    _sum: LikesSumAggregateOutputType | null
    _min: LikesMinAggregateOutputType | null
    _max: LikesMaxAggregateOutputType | null
  }

  export type LikesAvgAggregateOutputType = {
    id: number | null
    commentId: number | null
  }

  export type LikesSumAggregateOutputType = {
    id: number | null
    commentId: number | null
  }

  export type LikesMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    commentId: number | null
    network: string | null
    userNetwork: string | null
    userWalletAddress: string | null
  }

  export type LikesMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    commentId: number | null
    network: string | null
    userNetwork: string | null
    userWalletAddress: string | null
  }

  export type LikesCountAggregateOutputType = {
    id: number
    createdAt: number
    commentId: number
    network: number
    userNetwork: number
    userWalletAddress: number
    _all: number
  }


  export type LikesAvgAggregateInputType = {
    id?: true
    commentId?: true
  }

  export type LikesSumAggregateInputType = {
    id?: true
    commentId?: true
  }

  export type LikesMinAggregateInputType = {
    id?: true
    createdAt?: true
    commentId?: true
    network?: true
    userNetwork?: true
    userWalletAddress?: true
  }

  export type LikesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    commentId?: true
    network?: true
    userNetwork?: true
    userWalletAddress?: true
  }

  export type LikesCountAggregateInputType = {
    id?: true
    createdAt?: true
    commentId?: true
    network?: true
    userNetwork?: true
    userWalletAddress?: true
    _all?: true
  }

  export type LikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which likes to aggregate.
     */
    where?: likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of likes to fetch.
     */
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned likes
    **/
    _count?: true | LikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LikesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LikesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikesMaxAggregateInputType
  }

  export type GetLikesAggregateType<T extends LikesAggregateArgs> = {
        [P in keyof T & keyof AggregateLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikes[P]>
      : GetScalarType<T[P], AggregateLikes[P]>
  }




  export type likesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: likesWhereInput
    orderBy?: likesOrderByWithAggregationInput | likesOrderByWithAggregationInput[]
    by: LikesScalarFieldEnum[] | LikesScalarFieldEnum
    having?: likesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikesCountAggregateInputType | true
    _avg?: LikesAvgAggregateInputType
    _sum?: LikesSumAggregateInputType
    _min?: LikesMinAggregateInputType
    _max?: LikesMaxAggregateInputType
  }

  export type LikesGroupByOutputType = {
    id: number
    createdAt: Date
    commentId: number
    network: string
    userNetwork: string
    userWalletAddress: string
    _count: LikesCountAggregateOutputType | null
    _avg: LikesAvgAggregateOutputType | null
    _sum: LikesSumAggregateOutputType | null
    _min: LikesMinAggregateOutputType | null
    _max: LikesMaxAggregateOutputType | null
  }

  type GetLikesGroupByPayload<T extends likesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikesGroupByOutputType[P]>
            : GetScalarType<T[P], LikesGroupByOutputType[P]>
        }
      >
    >


  export type likesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    commentId?: boolean
    network?: boolean
    userNetwork?: boolean
    userWalletAddress?: boolean
    comments?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likes"]>

  export type likesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    commentId?: boolean
    network?: boolean
    userNetwork?: boolean
    userWalletAddress?: boolean
    comments?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likes"]>

  export type likesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    commentId?: boolean
    network?: boolean
    userNetwork?: boolean
    userWalletAddress?: boolean
    comments?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likes"]>

  export type likesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    commentId?: boolean
    network?: boolean
    userNetwork?: boolean
    userWalletAddress?: boolean
  }

  export type likesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "commentId" | "network" | "userNetwork" | "userWalletAddress", ExtArgs["result"]["likes"]>
  export type likesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type likesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type likesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $likesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "likes"
    objects: {
      comments: Prisma.$commentsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      commentId: number
      network: string
      userNetwork: string
      userWalletAddress: string
    }, ExtArgs["result"]["likes"]>
    composites: {}
  }

  type likesGetPayload<S extends boolean | null | undefined | likesDefaultArgs> = $Result.GetResult<Prisma.$likesPayload, S>

  type likesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<likesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikesCountAggregateInputType | true
    }

  export interface likesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['likes'], meta: { name: 'likes' } }
    /**
     * Find zero or one Likes that matches the filter.
     * @param {likesFindUniqueArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends likesFindUniqueArgs>(args: SelectSubset<T, likesFindUniqueArgs<ExtArgs>>): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Likes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {likesFindUniqueOrThrowArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends likesFindUniqueOrThrowArgs>(args: SelectSubset<T, likesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesFindFirstArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends likesFindFirstArgs>(args?: SelectSubset<T, likesFindFirstArgs<ExtArgs>>): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Likes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesFindFirstOrThrowArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends likesFindFirstOrThrowArgs>(args?: SelectSubset<T, likesFindFirstOrThrowArgs<ExtArgs>>): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.likes.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.likes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likesWithIdOnly = await prisma.likes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends likesFindManyArgs>(args?: SelectSubset<T, likesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Likes.
     * @param {likesCreateArgs} args - Arguments to create a Likes.
     * @example
     * // Create one Likes
     * const Likes = await prisma.likes.create({
     *   data: {
     *     // ... data to create a Likes
     *   }
     * })
     * 
     */
    create<T extends likesCreateArgs>(args: SelectSubset<T, likesCreateArgs<ExtArgs>>): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Likes.
     * @param {likesCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const likes = await prisma.likes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends likesCreateManyArgs>(args?: SelectSubset<T, likesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {likesCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const likes = await prisma.likes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likesWithIdOnly = await prisma.likes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends likesCreateManyAndReturnArgs>(args?: SelectSubset<T, likesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Likes.
     * @param {likesDeleteArgs} args - Arguments to delete one Likes.
     * @example
     * // Delete one Likes
     * const Likes = await prisma.likes.delete({
     *   where: {
     *     // ... filter to delete one Likes
     *   }
     * })
     * 
     */
    delete<T extends likesDeleteArgs>(args: SelectSubset<T, likesDeleteArgs<ExtArgs>>): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Likes.
     * @param {likesUpdateArgs} args - Arguments to update one Likes.
     * @example
     * // Update one Likes
     * const likes = await prisma.likes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends likesUpdateArgs>(args: SelectSubset<T, likesUpdateArgs<ExtArgs>>): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Likes.
     * @param {likesDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.likes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends likesDeleteManyArgs>(args?: SelectSubset<T, likesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const likes = await prisma.likes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends likesUpdateManyArgs>(args: SelectSubset<T, likesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes and returns the data updated in the database.
     * @param {likesUpdateManyAndReturnArgs} args - Arguments to update many Likes.
     * @example
     * // Update many Likes
     * const likes = await prisma.likes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Likes and only return the `id`
     * const likesWithIdOnly = await prisma.likes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends likesUpdateManyAndReturnArgs>(args: SelectSubset<T, likesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Likes.
     * @param {likesUpsertArgs} args - Arguments to update or create a Likes.
     * @example
     * // Update or create a Likes
     * const likes = await prisma.likes.upsert({
     *   create: {
     *     // ... data to create a Likes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Likes we want to update
     *   }
     * })
     */
    upsert<T extends likesUpsertArgs>(args: SelectSubset<T, likesUpsertArgs<ExtArgs>>): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.likes.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends likesCountArgs>(
      args?: Subset<T, likesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikesAggregateArgs>(args: Subset<T, LikesAggregateArgs>): Prisma.PrismaPromise<GetLikesAggregateType<T>>

    /**
     * Group by Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends likesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: likesGroupByArgs['orderBy'] }
        : { orderBy?: likesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, likesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the likes model
   */
  readonly fields: likesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for likes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__likesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends commentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, commentsDefaultArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the likes model
   */
  interface likesFieldRefs {
    readonly id: FieldRef<"likes", 'Int'>
    readonly createdAt: FieldRef<"likes", 'DateTime'>
    readonly commentId: FieldRef<"likes", 'Int'>
    readonly network: FieldRef<"likes", 'String'>
    readonly userNetwork: FieldRef<"likes", 'String'>
    readonly userWalletAddress: FieldRef<"likes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * likes findUnique
   */
  export type likesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where: likesWhereUniqueInput
  }

  /**
   * likes findUniqueOrThrow
   */
  export type likesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where: likesWhereUniqueInput
  }

  /**
   * likes findFirst
   */
  export type likesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where?: likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of likes to fetch.
     */
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for likes.
     */
    cursor?: likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of likes.
     */
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * likes findFirstOrThrow
   */
  export type likesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where?: likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of likes to fetch.
     */
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for likes.
     */
    cursor?: likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of likes.
     */
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * likes findMany
   */
  export type likesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where?: likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of likes to fetch.
     */
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing likes.
     */
    cursor?: likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` likes.
     */
    skip?: number
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * likes create
   */
  export type likesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * The data needed to create a likes.
     */
    data: XOR<likesCreateInput, likesUncheckedCreateInput>
  }

  /**
   * likes createMany
   */
  export type likesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many likes.
     */
    data: likesCreateManyInput | likesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * likes createManyAndReturn
   */
  export type likesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * The data used to create many likes.
     */
    data: likesCreateManyInput | likesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * likes update
   */
  export type likesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * The data needed to update a likes.
     */
    data: XOR<likesUpdateInput, likesUncheckedUpdateInput>
    /**
     * Choose, which likes to update.
     */
    where: likesWhereUniqueInput
  }

  /**
   * likes updateMany
   */
  export type likesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update likes.
     */
    data: XOR<likesUpdateManyMutationInput, likesUncheckedUpdateManyInput>
    /**
     * Filter which likes to update
     */
    where?: likesWhereInput
    /**
     * Limit how many likes to update.
     */
    limit?: number
  }

  /**
   * likes updateManyAndReturn
   */
  export type likesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * The data used to update likes.
     */
    data: XOR<likesUpdateManyMutationInput, likesUncheckedUpdateManyInput>
    /**
     * Filter which likes to update
     */
    where?: likesWhereInput
    /**
     * Limit how many likes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * likes upsert
   */
  export type likesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * The filter to search for the likes to update in case it exists.
     */
    where: likesWhereUniqueInput
    /**
     * In case the likes found by the `where` argument doesn't exist, create a new likes with this data.
     */
    create: XOR<likesCreateInput, likesUncheckedCreateInput>
    /**
     * In case the likes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<likesUpdateInput, likesUncheckedUpdateInput>
  }

  /**
   * likes delete
   */
  export type likesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter which likes to delete.
     */
    where: likesWhereUniqueInput
  }

  /**
   * likes deleteMany
   */
  export type likesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which likes to delete
     */
    where?: likesWhereInput
    /**
     * Limit how many likes to delete.
     */
    limit?: number
  }

  /**
   * likes without action
   */
  export type likesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
  }


  /**
   * Model migration_events
   */

  export type AggregateMigration_events = {
    _count: Migration_eventsCountAggregateOutputType | null
    _avg: Migration_eventsAvgAggregateOutputType | null
    _sum: Migration_eventsSumAggregateOutputType | null
    _min: Migration_eventsMinAggregateOutputType | null
    _max: Migration_eventsMaxAggregateOutputType | null
  }

  export type Migration_eventsAvgAggregateOutputType = {
    id: number | null
    supra_sent_to_lp: number | null
    tokens_sent_to_lp: number | null
    dev_reward_staked: number | null
    staking_pool_reward: number | null
    migrator_reward: number | null
    excess_supra_collected: number | null
  }

  export type Migration_eventsSumAggregateOutputType = {
    id: number | null
    supra_sent_to_lp: bigint | null
    tokens_sent_to_lp: bigint | null
    dev_reward_staked: bigint | null
    staking_pool_reward: bigint | null
    migrator_reward: bigint | null
    excess_supra_collected: bigint | null
  }

  export type Migration_eventsMinAggregateOutputType = {
    id: number | null
    network: string | null
    transactionHash: string | null
    sequenceNumber: string | null
    token_address: string | null
    migrator: string | null
    supra_sent_to_lp: bigint | null
    tokens_sent_to_lp: bigint | null
    dev_reward_staked: bigint | null
    staking_pool_reward: bigint | null
    migrator_reward: bigint | null
    excess_supra_collected: bigint | null
    createdAt: Date | null
  }

  export type Migration_eventsMaxAggregateOutputType = {
    id: number | null
    network: string | null
    transactionHash: string | null
    sequenceNumber: string | null
    token_address: string | null
    migrator: string | null
    supra_sent_to_lp: bigint | null
    tokens_sent_to_lp: bigint | null
    dev_reward_staked: bigint | null
    staking_pool_reward: bigint | null
    migrator_reward: bigint | null
    excess_supra_collected: bigint | null
    createdAt: Date | null
  }

  export type Migration_eventsCountAggregateOutputType = {
    id: number
    network: number
    transactionHash: number
    sequenceNumber: number
    token_address: number
    migrator: number
    supra_sent_to_lp: number
    tokens_sent_to_lp: number
    dev_reward_staked: number
    staking_pool_reward: number
    migrator_reward: number
    excess_supra_collected: number
    createdAt: number
    _all: number
  }


  export type Migration_eventsAvgAggregateInputType = {
    id?: true
    supra_sent_to_lp?: true
    tokens_sent_to_lp?: true
    dev_reward_staked?: true
    staking_pool_reward?: true
    migrator_reward?: true
    excess_supra_collected?: true
  }

  export type Migration_eventsSumAggregateInputType = {
    id?: true
    supra_sent_to_lp?: true
    tokens_sent_to_lp?: true
    dev_reward_staked?: true
    staking_pool_reward?: true
    migrator_reward?: true
    excess_supra_collected?: true
  }

  export type Migration_eventsMinAggregateInputType = {
    id?: true
    network?: true
    transactionHash?: true
    sequenceNumber?: true
    token_address?: true
    migrator?: true
    supra_sent_to_lp?: true
    tokens_sent_to_lp?: true
    dev_reward_staked?: true
    staking_pool_reward?: true
    migrator_reward?: true
    excess_supra_collected?: true
    createdAt?: true
  }

  export type Migration_eventsMaxAggregateInputType = {
    id?: true
    network?: true
    transactionHash?: true
    sequenceNumber?: true
    token_address?: true
    migrator?: true
    supra_sent_to_lp?: true
    tokens_sent_to_lp?: true
    dev_reward_staked?: true
    staking_pool_reward?: true
    migrator_reward?: true
    excess_supra_collected?: true
    createdAt?: true
  }

  export type Migration_eventsCountAggregateInputType = {
    id?: true
    network?: true
    transactionHash?: true
    sequenceNumber?: true
    token_address?: true
    migrator?: true
    supra_sent_to_lp?: true
    tokens_sent_to_lp?: true
    dev_reward_staked?: true
    staking_pool_reward?: true
    migrator_reward?: true
    excess_supra_collected?: true
    createdAt?: true
    _all?: true
  }

  export type Migration_eventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migration_events to aggregate.
     */
    where?: migration_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migration_events to fetch.
     */
    orderBy?: migration_eventsOrderByWithRelationInput | migration_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migration_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migration_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migration_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migration_events
    **/
    _count?: true | Migration_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Migration_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Migration_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Migration_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Migration_eventsMaxAggregateInputType
  }

  export type GetMigration_eventsAggregateType<T extends Migration_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigration_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigration_events[P]>
      : GetScalarType<T[P], AggregateMigration_events[P]>
  }




  export type migration_eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migration_eventsWhereInput
    orderBy?: migration_eventsOrderByWithAggregationInput | migration_eventsOrderByWithAggregationInput[]
    by: Migration_eventsScalarFieldEnum[] | Migration_eventsScalarFieldEnum
    having?: migration_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Migration_eventsCountAggregateInputType | true
    _avg?: Migration_eventsAvgAggregateInputType
    _sum?: Migration_eventsSumAggregateInputType
    _min?: Migration_eventsMinAggregateInputType
    _max?: Migration_eventsMaxAggregateInputType
  }

  export type Migration_eventsGroupByOutputType = {
    id: number
    network: string
    transactionHash: string
    sequenceNumber: string
    token_address: string
    migrator: string
    supra_sent_to_lp: bigint
    tokens_sent_to_lp: bigint
    dev_reward_staked: bigint
    staking_pool_reward: bigint
    migrator_reward: bigint
    excess_supra_collected: bigint
    createdAt: Date
    _count: Migration_eventsCountAggregateOutputType | null
    _avg: Migration_eventsAvgAggregateOutputType | null
    _sum: Migration_eventsSumAggregateOutputType | null
    _min: Migration_eventsMinAggregateOutputType | null
    _max: Migration_eventsMaxAggregateOutputType | null
  }

  type GetMigration_eventsGroupByPayload<T extends migration_eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Migration_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Migration_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Migration_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Migration_eventsGroupByOutputType[P]>
        }
      >
    >


  export type migration_eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    transactionHash?: boolean
    sequenceNumber?: boolean
    token_address?: boolean
    migrator?: boolean
    supra_sent_to_lp?: boolean
    tokens_sent_to_lp?: boolean
    dev_reward_staked?: boolean
    staking_pool_reward?: boolean
    migrator_reward?: boolean
    excess_supra_collected?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["migration_events"]>

  export type migration_eventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    transactionHash?: boolean
    sequenceNumber?: boolean
    token_address?: boolean
    migrator?: boolean
    supra_sent_to_lp?: boolean
    tokens_sent_to_lp?: boolean
    dev_reward_staked?: boolean
    staking_pool_reward?: boolean
    migrator_reward?: boolean
    excess_supra_collected?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["migration_events"]>

  export type migration_eventsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    transactionHash?: boolean
    sequenceNumber?: boolean
    token_address?: boolean
    migrator?: boolean
    supra_sent_to_lp?: boolean
    tokens_sent_to_lp?: boolean
    dev_reward_staked?: boolean
    staking_pool_reward?: boolean
    migrator_reward?: boolean
    excess_supra_collected?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["migration_events"]>

  export type migration_eventsSelectScalar = {
    id?: boolean
    network?: boolean
    transactionHash?: boolean
    sequenceNumber?: boolean
    token_address?: boolean
    migrator?: boolean
    supra_sent_to_lp?: boolean
    tokens_sent_to_lp?: boolean
    dev_reward_staked?: boolean
    staking_pool_reward?: boolean
    migrator_reward?: boolean
    excess_supra_collected?: boolean
    createdAt?: boolean
  }

  export type migration_eventsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "network" | "transactionHash" | "sequenceNumber" | "token_address" | "migrator" | "supra_sent_to_lp" | "tokens_sent_to_lp" | "dev_reward_staked" | "staking_pool_reward" | "migrator_reward" | "excess_supra_collected" | "createdAt", ExtArgs["result"]["migration_events"]>

  export type $migration_eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migration_events"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      network: string
      transactionHash: string
      sequenceNumber: string
      token_address: string
      migrator: string
      supra_sent_to_lp: bigint
      tokens_sent_to_lp: bigint
      dev_reward_staked: bigint
      staking_pool_reward: bigint
      migrator_reward: bigint
      excess_supra_collected: bigint
      createdAt: Date
    }, ExtArgs["result"]["migration_events"]>
    composites: {}
  }

  type migration_eventsGetPayload<S extends boolean | null | undefined | migration_eventsDefaultArgs> = $Result.GetResult<Prisma.$migration_eventsPayload, S>

  type migration_eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migration_eventsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Migration_eventsCountAggregateInputType | true
    }

  export interface migration_eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migration_events'], meta: { name: 'migration_events' } }
    /**
     * Find zero or one Migration_events that matches the filter.
     * @param {migration_eventsFindUniqueArgs} args - Arguments to find a Migration_events
     * @example
     * // Get one Migration_events
     * const migration_events = await prisma.migration_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migration_eventsFindUniqueArgs>(args: SelectSubset<T, migration_eventsFindUniqueArgs<ExtArgs>>): Prisma__migration_eventsClient<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migration_events that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migration_eventsFindUniqueOrThrowArgs} args - Arguments to find a Migration_events
     * @example
     * // Get one Migration_events
     * const migration_events = await prisma.migration_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migration_eventsFindUniqueOrThrowArgs>(args: SelectSubset<T, migration_eventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migration_eventsClient<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migration_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migration_eventsFindFirstArgs} args - Arguments to find a Migration_events
     * @example
     * // Get one Migration_events
     * const migration_events = await prisma.migration_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migration_eventsFindFirstArgs>(args?: SelectSubset<T, migration_eventsFindFirstArgs<ExtArgs>>): Prisma__migration_eventsClient<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migration_events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migration_eventsFindFirstOrThrowArgs} args - Arguments to find a Migration_events
     * @example
     * // Get one Migration_events
     * const migration_events = await prisma.migration_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migration_eventsFindFirstOrThrowArgs>(args?: SelectSubset<T, migration_eventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migration_eventsClient<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migration_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migration_eventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migration_events
     * const migration_events = await prisma.migration_events.findMany()
     * 
     * // Get first 10 Migration_events
     * const migration_events = await prisma.migration_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migration_eventsWithIdOnly = await prisma.migration_events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migration_eventsFindManyArgs>(args?: SelectSubset<T, migration_eventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migration_events.
     * @param {migration_eventsCreateArgs} args - Arguments to create a Migration_events.
     * @example
     * // Create one Migration_events
     * const Migration_events = await prisma.migration_events.create({
     *   data: {
     *     // ... data to create a Migration_events
     *   }
     * })
     * 
     */
    create<T extends migration_eventsCreateArgs>(args: SelectSubset<T, migration_eventsCreateArgs<ExtArgs>>): Prisma__migration_eventsClient<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migration_events.
     * @param {migration_eventsCreateManyArgs} args - Arguments to create many Migration_events.
     * @example
     * // Create many Migration_events
     * const migration_events = await prisma.migration_events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migration_eventsCreateManyArgs>(args?: SelectSubset<T, migration_eventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Migration_events and returns the data saved in the database.
     * @param {migration_eventsCreateManyAndReturnArgs} args - Arguments to create many Migration_events.
     * @example
     * // Create many Migration_events
     * const migration_events = await prisma.migration_events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Migration_events and only return the `id`
     * const migration_eventsWithIdOnly = await prisma.migration_events.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends migration_eventsCreateManyAndReturnArgs>(args?: SelectSubset<T, migration_eventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Migration_events.
     * @param {migration_eventsDeleteArgs} args - Arguments to delete one Migration_events.
     * @example
     * // Delete one Migration_events
     * const Migration_events = await prisma.migration_events.delete({
     *   where: {
     *     // ... filter to delete one Migration_events
     *   }
     * })
     * 
     */
    delete<T extends migration_eventsDeleteArgs>(args: SelectSubset<T, migration_eventsDeleteArgs<ExtArgs>>): Prisma__migration_eventsClient<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migration_events.
     * @param {migration_eventsUpdateArgs} args - Arguments to update one Migration_events.
     * @example
     * // Update one Migration_events
     * const migration_events = await prisma.migration_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migration_eventsUpdateArgs>(args: SelectSubset<T, migration_eventsUpdateArgs<ExtArgs>>): Prisma__migration_eventsClient<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migration_events.
     * @param {migration_eventsDeleteManyArgs} args - Arguments to filter Migration_events to delete.
     * @example
     * // Delete a few Migration_events
     * const { count } = await prisma.migration_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migration_eventsDeleteManyArgs>(args?: SelectSubset<T, migration_eventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migration_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migration_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migration_events
     * const migration_events = await prisma.migration_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migration_eventsUpdateManyArgs>(args: SelectSubset<T, migration_eventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migration_events and returns the data updated in the database.
     * @param {migration_eventsUpdateManyAndReturnArgs} args - Arguments to update many Migration_events.
     * @example
     * // Update many Migration_events
     * const migration_events = await prisma.migration_events.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Migration_events and only return the `id`
     * const migration_eventsWithIdOnly = await prisma.migration_events.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends migration_eventsUpdateManyAndReturnArgs>(args: SelectSubset<T, migration_eventsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Migration_events.
     * @param {migration_eventsUpsertArgs} args - Arguments to update or create a Migration_events.
     * @example
     * // Update or create a Migration_events
     * const migration_events = await prisma.migration_events.upsert({
     *   create: {
     *     // ... data to create a Migration_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migration_events we want to update
     *   }
     * })
     */
    upsert<T extends migration_eventsUpsertArgs>(args: SelectSubset<T, migration_eventsUpsertArgs<ExtArgs>>): Prisma__migration_eventsClient<$Result.GetResult<Prisma.$migration_eventsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migration_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migration_eventsCountArgs} args - Arguments to filter Migration_events to count.
     * @example
     * // Count the number of Migration_events
     * const count = await prisma.migration_events.count({
     *   where: {
     *     // ... the filter for the Migration_events we want to count
     *   }
     * })
    **/
    count<T extends migration_eventsCountArgs>(
      args?: Subset<T, migration_eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Migration_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migration_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Migration_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Migration_eventsAggregateArgs>(args: Subset<T, Migration_eventsAggregateArgs>): Prisma.PrismaPromise<GetMigration_eventsAggregateType<T>>

    /**
     * Group by Migration_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migration_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migration_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migration_eventsGroupByArgs['orderBy'] }
        : { orderBy?: migration_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migration_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigration_eventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migration_events model
   */
  readonly fields: migration_eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migration_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migration_eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migration_events model
   */
  interface migration_eventsFieldRefs {
    readonly id: FieldRef<"migration_events", 'Int'>
    readonly network: FieldRef<"migration_events", 'String'>
    readonly transactionHash: FieldRef<"migration_events", 'String'>
    readonly sequenceNumber: FieldRef<"migration_events", 'String'>
    readonly token_address: FieldRef<"migration_events", 'String'>
    readonly migrator: FieldRef<"migration_events", 'String'>
    readonly supra_sent_to_lp: FieldRef<"migration_events", 'BigInt'>
    readonly tokens_sent_to_lp: FieldRef<"migration_events", 'BigInt'>
    readonly dev_reward_staked: FieldRef<"migration_events", 'BigInt'>
    readonly staking_pool_reward: FieldRef<"migration_events", 'BigInt'>
    readonly migrator_reward: FieldRef<"migration_events", 'BigInt'>
    readonly excess_supra_collected: FieldRef<"migration_events", 'BigInt'>
    readonly createdAt: FieldRef<"migration_events", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * migration_events findUnique
   */
  export type migration_eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * Filter, which migration_events to fetch.
     */
    where: migration_eventsWhereUniqueInput
  }

  /**
   * migration_events findUniqueOrThrow
   */
  export type migration_eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * Filter, which migration_events to fetch.
     */
    where: migration_eventsWhereUniqueInput
  }

  /**
   * migration_events findFirst
   */
  export type migration_eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * Filter, which migration_events to fetch.
     */
    where?: migration_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migration_events to fetch.
     */
    orderBy?: migration_eventsOrderByWithRelationInput | migration_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migration_events.
     */
    cursor?: migration_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migration_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migration_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migration_events.
     */
    distinct?: Migration_eventsScalarFieldEnum | Migration_eventsScalarFieldEnum[]
  }

  /**
   * migration_events findFirstOrThrow
   */
  export type migration_eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * Filter, which migration_events to fetch.
     */
    where?: migration_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migration_events to fetch.
     */
    orderBy?: migration_eventsOrderByWithRelationInput | migration_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migration_events.
     */
    cursor?: migration_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migration_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migration_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migration_events.
     */
    distinct?: Migration_eventsScalarFieldEnum | Migration_eventsScalarFieldEnum[]
  }

  /**
   * migration_events findMany
   */
  export type migration_eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * Filter, which migration_events to fetch.
     */
    where?: migration_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migration_events to fetch.
     */
    orderBy?: migration_eventsOrderByWithRelationInput | migration_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migration_events.
     */
    cursor?: migration_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migration_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migration_events.
     */
    skip?: number
    distinct?: Migration_eventsScalarFieldEnum | Migration_eventsScalarFieldEnum[]
  }

  /**
   * migration_events create
   */
  export type migration_eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * The data needed to create a migration_events.
     */
    data: XOR<migration_eventsCreateInput, migration_eventsUncheckedCreateInput>
  }

  /**
   * migration_events createMany
   */
  export type migration_eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migration_events.
     */
    data: migration_eventsCreateManyInput | migration_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migration_events createManyAndReturn
   */
  export type migration_eventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * The data used to create many migration_events.
     */
    data: migration_eventsCreateManyInput | migration_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migration_events update
   */
  export type migration_eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * The data needed to update a migration_events.
     */
    data: XOR<migration_eventsUpdateInput, migration_eventsUncheckedUpdateInput>
    /**
     * Choose, which migration_events to update.
     */
    where: migration_eventsWhereUniqueInput
  }

  /**
   * migration_events updateMany
   */
  export type migration_eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migration_events.
     */
    data: XOR<migration_eventsUpdateManyMutationInput, migration_eventsUncheckedUpdateManyInput>
    /**
     * Filter which migration_events to update
     */
    where?: migration_eventsWhereInput
    /**
     * Limit how many migration_events to update.
     */
    limit?: number
  }

  /**
   * migration_events updateManyAndReturn
   */
  export type migration_eventsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * The data used to update migration_events.
     */
    data: XOR<migration_eventsUpdateManyMutationInput, migration_eventsUncheckedUpdateManyInput>
    /**
     * Filter which migration_events to update
     */
    where?: migration_eventsWhereInput
    /**
     * Limit how many migration_events to update.
     */
    limit?: number
  }

  /**
   * migration_events upsert
   */
  export type migration_eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * The filter to search for the migration_events to update in case it exists.
     */
    where: migration_eventsWhereUniqueInput
    /**
     * In case the migration_events found by the `where` argument doesn't exist, create a new migration_events with this data.
     */
    create: XOR<migration_eventsCreateInput, migration_eventsUncheckedCreateInput>
    /**
     * In case the migration_events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migration_eventsUpdateInput, migration_eventsUncheckedUpdateInput>
  }

  /**
   * migration_events delete
   */
  export type migration_eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
    /**
     * Filter which migration_events to delete.
     */
    where: migration_eventsWhereUniqueInput
  }

  /**
   * migration_events deleteMany
   */
  export type migration_eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migration_events to delete
     */
    where?: migration_eventsWhereInput
    /**
     * Limit how many migration_events to delete.
     */
    limit?: number
  }

  /**
   * migration_events without action
   */
  export type migration_eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration_events
     */
    select?: migration_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration_events
     */
    omit?: migration_eventsOmit<ExtArgs> | null
  }


  /**
   * Model protocol_stats
   */

  export type AggregateProtocol_stats = {
    _count: Protocol_statsCountAggregateOutputType | null
    _avg: Protocol_statsAvgAggregateOutputType | null
    _sum: Protocol_statsSumAggregateOutputType | null
    _min: Protocol_statsMinAggregateOutputType | null
    _max: Protocol_statsMaxAggregateOutputType | null
  }

  export type Protocol_statsAvgAggregateOutputType = {
    id: number | null
    totalTvlUsd: Decimal | null
    ammTvlUsd: Decimal | null
    virtualPoolsTvlUsd: Decimal | null
    stakingTvlUsd: Decimal | null
    totalVolume24hUsd: Decimal | null
    ammVolume24hUsd: Decimal | null
    totalUniqueUsers: number | null
    totalFeesEarnedUsd24h: Decimal | null
  }

  export type Protocol_statsSumAggregateOutputType = {
    id: number | null
    totalTvlUsd: Decimal | null
    ammTvlUsd: Decimal | null
    virtualPoolsTvlUsd: Decimal | null
    stakingTvlUsd: Decimal | null
    totalVolume24hUsd: Decimal | null
    ammVolume24hUsd: Decimal | null
    totalUniqueUsers: number | null
    totalFeesEarnedUsd24h: Decimal | null
  }

  export type Protocol_statsMinAggregateOutputType = {
    id: number | null
    network: string | null
    timestamp: Date | null
    totalTvlUsd: Decimal | null
    ammTvlUsd: Decimal | null
    virtualPoolsTvlUsd: Decimal | null
    stakingTvlUsd: Decimal | null
    totalVolume24hUsd: Decimal | null
    ammVolume24hUsd: Decimal | null
    totalUniqueUsers: number | null
    totalFeesEarnedUsd24h: Decimal | null
  }

  export type Protocol_statsMaxAggregateOutputType = {
    id: number | null
    network: string | null
    timestamp: Date | null
    totalTvlUsd: Decimal | null
    ammTvlUsd: Decimal | null
    virtualPoolsTvlUsd: Decimal | null
    stakingTvlUsd: Decimal | null
    totalVolume24hUsd: Decimal | null
    ammVolume24hUsd: Decimal | null
    totalUniqueUsers: number | null
    totalFeesEarnedUsd24h: Decimal | null
  }

  export type Protocol_statsCountAggregateOutputType = {
    id: number
    network: number
    timestamp: number
    totalTvlUsd: number
    ammTvlUsd: number
    virtualPoolsTvlUsd: number
    stakingTvlUsd: number
    totalVolume24hUsd: number
    ammVolume24hUsd: number
    totalUniqueUsers: number
    totalFeesEarnedUsd24h: number
    _all: number
  }


  export type Protocol_statsAvgAggregateInputType = {
    id?: true
    totalTvlUsd?: true
    ammTvlUsd?: true
    virtualPoolsTvlUsd?: true
    stakingTvlUsd?: true
    totalVolume24hUsd?: true
    ammVolume24hUsd?: true
    totalUniqueUsers?: true
    totalFeesEarnedUsd24h?: true
  }

  export type Protocol_statsSumAggregateInputType = {
    id?: true
    totalTvlUsd?: true
    ammTvlUsd?: true
    virtualPoolsTvlUsd?: true
    stakingTvlUsd?: true
    totalVolume24hUsd?: true
    ammVolume24hUsd?: true
    totalUniqueUsers?: true
    totalFeesEarnedUsd24h?: true
  }

  export type Protocol_statsMinAggregateInputType = {
    id?: true
    network?: true
    timestamp?: true
    totalTvlUsd?: true
    ammTvlUsd?: true
    virtualPoolsTvlUsd?: true
    stakingTvlUsd?: true
    totalVolume24hUsd?: true
    ammVolume24hUsd?: true
    totalUniqueUsers?: true
    totalFeesEarnedUsd24h?: true
  }

  export type Protocol_statsMaxAggregateInputType = {
    id?: true
    network?: true
    timestamp?: true
    totalTvlUsd?: true
    ammTvlUsd?: true
    virtualPoolsTvlUsd?: true
    stakingTvlUsd?: true
    totalVolume24hUsd?: true
    ammVolume24hUsd?: true
    totalUniqueUsers?: true
    totalFeesEarnedUsd24h?: true
  }

  export type Protocol_statsCountAggregateInputType = {
    id?: true
    network?: true
    timestamp?: true
    totalTvlUsd?: true
    ammTvlUsd?: true
    virtualPoolsTvlUsd?: true
    stakingTvlUsd?: true
    totalVolume24hUsd?: true
    ammVolume24hUsd?: true
    totalUniqueUsers?: true
    totalFeesEarnedUsd24h?: true
    _all?: true
  }

  export type Protocol_statsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which protocol_stats to aggregate.
     */
    where?: protocol_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of protocol_stats to fetch.
     */
    orderBy?: protocol_statsOrderByWithRelationInput | protocol_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: protocol_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` protocol_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` protocol_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned protocol_stats
    **/
    _count?: true | Protocol_statsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Protocol_statsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Protocol_statsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Protocol_statsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Protocol_statsMaxAggregateInputType
  }

  export type GetProtocol_statsAggregateType<T extends Protocol_statsAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocol_stats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocol_stats[P]>
      : GetScalarType<T[P], AggregateProtocol_stats[P]>
  }




  export type protocol_statsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: protocol_statsWhereInput
    orderBy?: protocol_statsOrderByWithAggregationInput | protocol_statsOrderByWithAggregationInput[]
    by: Protocol_statsScalarFieldEnum[] | Protocol_statsScalarFieldEnum
    having?: protocol_statsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Protocol_statsCountAggregateInputType | true
    _avg?: Protocol_statsAvgAggregateInputType
    _sum?: Protocol_statsSumAggregateInputType
    _min?: Protocol_statsMinAggregateInputType
    _max?: Protocol_statsMaxAggregateInputType
  }

  export type Protocol_statsGroupByOutputType = {
    id: number
    network: string
    timestamp: Date
    totalTvlUsd: Decimal | null
    ammTvlUsd: Decimal | null
    virtualPoolsTvlUsd: Decimal | null
    stakingTvlUsd: Decimal | null
    totalVolume24hUsd: Decimal | null
    ammVolume24hUsd: Decimal | null
    totalUniqueUsers: number | null
    totalFeesEarnedUsd24h: Decimal | null
    _count: Protocol_statsCountAggregateOutputType | null
    _avg: Protocol_statsAvgAggregateOutputType | null
    _sum: Protocol_statsSumAggregateOutputType | null
    _min: Protocol_statsMinAggregateOutputType | null
    _max: Protocol_statsMaxAggregateOutputType | null
  }

  type GetProtocol_statsGroupByPayload<T extends protocol_statsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Protocol_statsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Protocol_statsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Protocol_statsGroupByOutputType[P]>
            : GetScalarType<T[P], Protocol_statsGroupByOutputType[P]>
        }
      >
    >


  export type protocol_statsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    timestamp?: boolean
    totalTvlUsd?: boolean
    ammTvlUsd?: boolean
    virtualPoolsTvlUsd?: boolean
    stakingTvlUsd?: boolean
    totalVolume24hUsd?: boolean
    ammVolume24hUsd?: boolean
    totalUniqueUsers?: boolean
    totalFeesEarnedUsd24h?: boolean
  }, ExtArgs["result"]["protocol_stats"]>

  export type protocol_statsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    timestamp?: boolean
    totalTvlUsd?: boolean
    ammTvlUsd?: boolean
    virtualPoolsTvlUsd?: boolean
    stakingTvlUsd?: boolean
    totalVolume24hUsd?: boolean
    ammVolume24hUsd?: boolean
    totalUniqueUsers?: boolean
    totalFeesEarnedUsd24h?: boolean
  }, ExtArgs["result"]["protocol_stats"]>

  export type protocol_statsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    timestamp?: boolean
    totalTvlUsd?: boolean
    ammTvlUsd?: boolean
    virtualPoolsTvlUsd?: boolean
    stakingTvlUsd?: boolean
    totalVolume24hUsd?: boolean
    ammVolume24hUsd?: boolean
    totalUniqueUsers?: boolean
    totalFeesEarnedUsd24h?: boolean
  }, ExtArgs["result"]["protocol_stats"]>

  export type protocol_statsSelectScalar = {
    id?: boolean
    network?: boolean
    timestamp?: boolean
    totalTvlUsd?: boolean
    ammTvlUsd?: boolean
    virtualPoolsTvlUsd?: boolean
    stakingTvlUsd?: boolean
    totalVolume24hUsd?: boolean
    ammVolume24hUsd?: boolean
    totalUniqueUsers?: boolean
    totalFeesEarnedUsd24h?: boolean
  }

  export type protocol_statsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "network" | "timestamp" | "totalTvlUsd" | "ammTvlUsd" | "virtualPoolsTvlUsd" | "stakingTvlUsd" | "totalVolume24hUsd" | "ammVolume24hUsd" | "totalUniqueUsers" | "totalFeesEarnedUsd24h", ExtArgs["result"]["protocol_stats"]>

  export type $protocol_statsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "protocol_stats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      network: string
      timestamp: Date
      totalTvlUsd: Prisma.Decimal | null
      ammTvlUsd: Prisma.Decimal | null
      virtualPoolsTvlUsd: Prisma.Decimal | null
      stakingTvlUsd: Prisma.Decimal | null
      totalVolume24hUsd: Prisma.Decimal | null
      ammVolume24hUsd: Prisma.Decimal | null
      totalUniqueUsers: number | null
      totalFeesEarnedUsd24h: Prisma.Decimal | null
    }, ExtArgs["result"]["protocol_stats"]>
    composites: {}
  }

  type protocol_statsGetPayload<S extends boolean | null | undefined | protocol_statsDefaultArgs> = $Result.GetResult<Prisma.$protocol_statsPayload, S>

  type protocol_statsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<protocol_statsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Protocol_statsCountAggregateInputType | true
    }

  export interface protocol_statsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['protocol_stats'], meta: { name: 'protocol_stats' } }
    /**
     * Find zero or one Protocol_stats that matches the filter.
     * @param {protocol_statsFindUniqueArgs} args - Arguments to find a Protocol_stats
     * @example
     * // Get one Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends protocol_statsFindUniqueArgs>(args: SelectSubset<T, protocol_statsFindUniqueArgs<ExtArgs>>): Prisma__protocol_statsClient<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Protocol_stats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {protocol_statsFindUniqueOrThrowArgs} args - Arguments to find a Protocol_stats
     * @example
     * // Get one Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends protocol_statsFindUniqueOrThrowArgs>(args: SelectSubset<T, protocol_statsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__protocol_statsClient<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Protocol_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {protocol_statsFindFirstArgs} args - Arguments to find a Protocol_stats
     * @example
     * // Get one Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends protocol_statsFindFirstArgs>(args?: SelectSubset<T, protocol_statsFindFirstArgs<ExtArgs>>): Prisma__protocol_statsClient<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Protocol_stats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {protocol_statsFindFirstOrThrowArgs} args - Arguments to find a Protocol_stats
     * @example
     * // Get one Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends protocol_statsFindFirstOrThrowArgs>(args?: SelectSubset<T, protocol_statsFindFirstOrThrowArgs<ExtArgs>>): Prisma__protocol_statsClient<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Protocol_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {protocol_statsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.findMany()
     * 
     * // Get first 10 Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const protocol_statsWithIdOnly = await prisma.protocol_stats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends protocol_statsFindManyArgs>(args?: SelectSubset<T, protocol_statsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Protocol_stats.
     * @param {protocol_statsCreateArgs} args - Arguments to create a Protocol_stats.
     * @example
     * // Create one Protocol_stats
     * const Protocol_stats = await prisma.protocol_stats.create({
     *   data: {
     *     // ... data to create a Protocol_stats
     *   }
     * })
     * 
     */
    create<T extends protocol_statsCreateArgs>(args: SelectSubset<T, protocol_statsCreateArgs<ExtArgs>>): Prisma__protocol_statsClient<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Protocol_stats.
     * @param {protocol_statsCreateManyArgs} args - Arguments to create many Protocol_stats.
     * @example
     * // Create many Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends protocol_statsCreateManyArgs>(args?: SelectSubset<T, protocol_statsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Protocol_stats and returns the data saved in the database.
     * @param {protocol_statsCreateManyAndReturnArgs} args - Arguments to create many Protocol_stats.
     * @example
     * // Create many Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Protocol_stats and only return the `id`
     * const protocol_statsWithIdOnly = await prisma.protocol_stats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends protocol_statsCreateManyAndReturnArgs>(args?: SelectSubset<T, protocol_statsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Protocol_stats.
     * @param {protocol_statsDeleteArgs} args - Arguments to delete one Protocol_stats.
     * @example
     * // Delete one Protocol_stats
     * const Protocol_stats = await prisma.protocol_stats.delete({
     *   where: {
     *     // ... filter to delete one Protocol_stats
     *   }
     * })
     * 
     */
    delete<T extends protocol_statsDeleteArgs>(args: SelectSubset<T, protocol_statsDeleteArgs<ExtArgs>>): Prisma__protocol_statsClient<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Protocol_stats.
     * @param {protocol_statsUpdateArgs} args - Arguments to update one Protocol_stats.
     * @example
     * // Update one Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends protocol_statsUpdateArgs>(args: SelectSubset<T, protocol_statsUpdateArgs<ExtArgs>>): Prisma__protocol_statsClient<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Protocol_stats.
     * @param {protocol_statsDeleteManyArgs} args - Arguments to filter Protocol_stats to delete.
     * @example
     * // Delete a few Protocol_stats
     * const { count } = await prisma.protocol_stats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends protocol_statsDeleteManyArgs>(args?: SelectSubset<T, protocol_statsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Protocol_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {protocol_statsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends protocol_statsUpdateManyArgs>(args: SelectSubset<T, protocol_statsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Protocol_stats and returns the data updated in the database.
     * @param {protocol_statsUpdateManyAndReturnArgs} args - Arguments to update many Protocol_stats.
     * @example
     * // Update many Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Protocol_stats and only return the `id`
     * const protocol_statsWithIdOnly = await prisma.protocol_stats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends protocol_statsUpdateManyAndReturnArgs>(args: SelectSubset<T, protocol_statsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Protocol_stats.
     * @param {protocol_statsUpsertArgs} args - Arguments to update or create a Protocol_stats.
     * @example
     * // Update or create a Protocol_stats
     * const protocol_stats = await prisma.protocol_stats.upsert({
     *   create: {
     *     // ... data to create a Protocol_stats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Protocol_stats we want to update
     *   }
     * })
     */
    upsert<T extends protocol_statsUpsertArgs>(args: SelectSubset<T, protocol_statsUpsertArgs<ExtArgs>>): Prisma__protocol_statsClient<$Result.GetResult<Prisma.$protocol_statsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Protocol_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {protocol_statsCountArgs} args - Arguments to filter Protocol_stats to count.
     * @example
     * // Count the number of Protocol_stats
     * const count = await prisma.protocol_stats.count({
     *   where: {
     *     // ... the filter for the Protocol_stats we want to count
     *   }
     * })
    **/
    count<T extends protocol_statsCountArgs>(
      args?: Subset<T, protocol_statsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Protocol_statsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Protocol_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Protocol_statsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Protocol_statsAggregateArgs>(args: Subset<T, Protocol_statsAggregateArgs>): Prisma.PrismaPromise<GetProtocol_statsAggregateType<T>>

    /**
     * Group by Protocol_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {protocol_statsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends protocol_statsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: protocol_statsGroupByArgs['orderBy'] }
        : { orderBy?: protocol_statsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, protocol_statsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocol_statsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the protocol_stats model
   */
  readonly fields: protocol_statsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for protocol_stats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__protocol_statsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the protocol_stats model
   */
  interface protocol_statsFieldRefs {
    readonly id: FieldRef<"protocol_stats", 'Int'>
    readonly network: FieldRef<"protocol_stats", 'String'>
    readonly timestamp: FieldRef<"protocol_stats", 'DateTime'>
    readonly totalTvlUsd: FieldRef<"protocol_stats", 'Decimal'>
    readonly ammTvlUsd: FieldRef<"protocol_stats", 'Decimal'>
    readonly virtualPoolsTvlUsd: FieldRef<"protocol_stats", 'Decimal'>
    readonly stakingTvlUsd: FieldRef<"protocol_stats", 'Decimal'>
    readonly totalVolume24hUsd: FieldRef<"protocol_stats", 'Decimal'>
    readonly ammVolume24hUsd: FieldRef<"protocol_stats", 'Decimal'>
    readonly totalUniqueUsers: FieldRef<"protocol_stats", 'Int'>
    readonly totalFeesEarnedUsd24h: FieldRef<"protocol_stats", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * protocol_stats findUnique
   */
  export type protocol_statsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * Filter, which protocol_stats to fetch.
     */
    where: protocol_statsWhereUniqueInput
  }

  /**
   * protocol_stats findUniqueOrThrow
   */
  export type protocol_statsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * Filter, which protocol_stats to fetch.
     */
    where: protocol_statsWhereUniqueInput
  }

  /**
   * protocol_stats findFirst
   */
  export type protocol_statsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * Filter, which protocol_stats to fetch.
     */
    where?: protocol_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of protocol_stats to fetch.
     */
    orderBy?: protocol_statsOrderByWithRelationInput | protocol_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for protocol_stats.
     */
    cursor?: protocol_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` protocol_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` protocol_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of protocol_stats.
     */
    distinct?: Protocol_statsScalarFieldEnum | Protocol_statsScalarFieldEnum[]
  }

  /**
   * protocol_stats findFirstOrThrow
   */
  export type protocol_statsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * Filter, which protocol_stats to fetch.
     */
    where?: protocol_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of protocol_stats to fetch.
     */
    orderBy?: protocol_statsOrderByWithRelationInput | protocol_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for protocol_stats.
     */
    cursor?: protocol_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` protocol_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` protocol_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of protocol_stats.
     */
    distinct?: Protocol_statsScalarFieldEnum | Protocol_statsScalarFieldEnum[]
  }

  /**
   * protocol_stats findMany
   */
  export type protocol_statsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * Filter, which protocol_stats to fetch.
     */
    where?: protocol_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of protocol_stats to fetch.
     */
    orderBy?: protocol_statsOrderByWithRelationInput | protocol_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing protocol_stats.
     */
    cursor?: protocol_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` protocol_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` protocol_stats.
     */
    skip?: number
    distinct?: Protocol_statsScalarFieldEnum | Protocol_statsScalarFieldEnum[]
  }

  /**
   * protocol_stats create
   */
  export type protocol_statsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * The data needed to create a protocol_stats.
     */
    data: XOR<protocol_statsCreateInput, protocol_statsUncheckedCreateInput>
  }

  /**
   * protocol_stats createMany
   */
  export type protocol_statsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many protocol_stats.
     */
    data: protocol_statsCreateManyInput | protocol_statsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * protocol_stats createManyAndReturn
   */
  export type protocol_statsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * The data used to create many protocol_stats.
     */
    data: protocol_statsCreateManyInput | protocol_statsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * protocol_stats update
   */
  export type protocol_statsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * The data needed to update a protocol_stats.
     */
    data: XOR<protocol_statsUpdateInput, protocol_statsUncheckedUpdateInput>
    /**
     * Choose, which protocol_stats to update.
     */
    where: protocol_statsWhereUniqueInput
  }

  /**
   * protocol_stats updateMany
   */
  export type protocol_statsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update protocol_stats.
     */
    data: XOR<protocol_statsUpdateManyMutationInput, protocol_statsUncheckedUpdateManyInput>
    /**
     * Filter which protocol_stats to update
     */
    where?: protocol_statsWhereInput
    /**
     * Limit how many protocol_stats to update.
     */
    limit?: number
  }

  /**
   * protocol_stats updateManyAndReturn
   */
  export type protocol_statsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * The data used to update protocol_stats.
     */
    data: XOR<protocol_statsUpdateManyMutationInput, protocol_statsUncheckedUpdateManyInput>
    /**
     * Filter which protocol_stats to update
     */
    where?: protocol_statsWhereInput
    /**
     * Limit how many protocol_stats to update.
     */
    limit?: number
  }

  /**
   * protocol_stats upsert
   */
  export type protocol_statsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * The filter to search for the protocol_stats to update in case it exists.
     */
    where: protocol_statsWhereUniqueInput
    /**
     * In case the protocol_stats found by the `where` argument doesn't exist, create a new protocol_stats with this data.
     */
    create: XOR<protocol_statsCreateInput, protocol_statsUncheckedCreateInput>
    /**
     * In case the protocol_stats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<protocol_statsUpdateInput, protocol_statsUncheckedUpdateInput>
  }

  /**
   * protocol_stats delete
   */
  export type protocol_statsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
    /**
     * Filter which protocol_stats to delete.
     */
    where: protocol_statsWhereUniqueInput
  }

  /**
   * protocol_stats deleteMany
   */
  export type protocol_statsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which protocol_stats to delete
     */
    where?: protocol_statsWhereInput
    /**
     * Limit how many protocol_stats to delete.
     */
    limit?: number
  }

  /**
   * protocol_stats without action
   */
  export type protocol_statsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the protocol_stats
     */
    select?: protocol_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the protocol_stats
     */
    omit?: protocol_statsOmit<ExtArgs> | null
  }


  /**
   * Model staking_pools
   */

  export type AggregateStaking_pools = {
    _count: Staking_poolsCountAggregateOutputType | null
    _avg: Staking_poolsAvgAggregateOutputType | null
    _sum: Staking_poolsSumAggregateOutputType | null
    _min: Staking_poolsMinAggregateOutputType | null
    _max: Staking_poolsMaxAggregateOutputType | null
  }

  export type Staking_poolsAvgAggregateOutputType = {
    id: number | null
    lastUpdatedTimestamp: number | null
    startTimestamp: number | null
    endTimestamp: number | null
    initialEndTimestamp: number | null
    displayOrder: number | null
    cachedStakerCount: number | null
  }

  export type Staking_poolsSumAggregateOutputType = {
    id: number | null
    lastUpdatedTimestamp: bigint | null
    startTimestamp: bigint | null
    endTimestamp: bigint | null
    initialEndTimestamp: bigint | null
    displayOrder: number | null
    cachedStakerCount: number | null
  }

  export type Staking_poolsMinAggregateOutputType = {
    id: number | null
    creatorAddress: string | null
    stakeTokenAddress: string | null
    rewardTokenAddress: string | null
    isDynamicPool: boolean | null
    rewardPerSec: string | null
    accumReward: string | null
    lastUpdatedTimestamp: bigint | null
    startTimestamp: bigint | null
    endTimestamp: bigint | null
    emergencyLocked: boolean | null
    stakesClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorNetwork: string | null
    network: string | null
    rewardTokenNetwork: string | null
    stakeTokenNetwork: string | null
    boostEnabled: boolean | null
    initialEndTimestamp: bigint | null
    initialRewardPerSec: string | null
    verified: boolean | null
    totalBoosted: string | null
    displayOrder: number | null
    cachedApy: string | null
    cachedStakerCount: number | null
    cachedTvlUsd: string | null
    poolType: $Enums.PoolType | null
    totalStakedAmount: string | null
    boostConfigCollectionName: string | null
    boostConfigCollectionOwner: string | null
    boostConfigPercent: string | null
  }

  export type Staking_poolsMaxAggregateOutputType = {
    id: number | null
    creatorAddress: string | null
    stakeTokenAddress: string | null
    rewardTokenAddress: string | null
    isDynamicPool: boolean | null
    rewardPerSec: string | null
    accumReward: string | null
    lastUpdatedTimestamp: bigint | null
    startTimestamp: bigint | null
    endTimestamp: bigint | null
    emergencyLocked: boolean | null
    stakesClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorNetwork: string | null
    network: string | null
    rewardTokenNetwork: string | null
    stakeTokenNetwork: string | null
    boostEnabled: boolean | null
    initialEndTimestamp: bigint | null
    initialRewardPerSec: string | null
    verified: boolean | null
    totalBoosted: string | null
    displayOrder: number | null
    cachedApy: string | null
    cachedStakerCount: number | null
    cachedTvlUsd: string | null
    poolType: $Enums.PoolType | null
    totalStakedAmount: string | null
    boostConfigCollectionName: string | null
    boostConfigCollectionOwner: string | null
    boostConfigPercent: string | null
  }

  export type Staking_poolsCountAggregateOutputType = {
    id: number
    creatorAddress: number
    stakeTokenAddress: number
    rewardTokenAddress: number
    isDynamicPool: number
    rewardPerSec: number
    accumReward: number
    lastUpdatedTimestamp: number
    startTimestamp: number
    endTimestamp: number
    emergencyLocked: number
    stakesClosed: number
    createdAt: number
    updatedAt: number
    creatorNetwork: number
    network: number
    rewardTokenNetwork: number
    stakeTokenNetwork: number
    boostEnabled: number
    initialEndTimestamp: number
    initialRewardPerSec: number
    verified: number
    totalBoosted: number
    displayOrder: number
    cachedApy: number
    cachedStakerCount: number
    cachedTvlUsd: number
    poolType: number
    totalStakedAmount: number
    boostConfigCollectionName: number
    boostConfigCollectionOwner: number
    boostConfigPercent: number
    _all: number
  }


  export type Staking_poolsAvgAggregateInputType = {
    id?: true
    lastUpdatedTimestamp?: true
    startTimestamp?: true
    endTimestamp?: true
    initialEndTimestamp?: true
    displayOrder?: true
    cachedStakerCount?: true
  }

  export type Staking_poolsSumAggregateInputType = {
    id?: true
    lastUpdatedTimestamp?: true
    startTimestamp?: true
    endTimestamp?: true
    initialEndTimestamp?: true
    displayOrder?: true
    cachedStakerCount?: true
  }

  export type Staking_poolsMinAggregateInputType = {
    id?: true
    creatorAddress?: true
    stakeTokenAddress?: true
    rewardTokenAddress?: true
    isDynamicPool?: true
    rewardPerSec?: true
    accumReward?: true
    lastUpdatedTimestamp?: true
    startTimestamp?: true
    endTimestamp?: true
    emergencyLocked?: true
    stakesClosed?: true
    createdAt?: true
    updatedAt?: true
    creatorNetwork?: true
    network?: true
    rewardTokenNetwork?: true
    stakeTokenNetwork?: true
    boostEnabled?: true
    initialEndTimestamp?: true
    initialRewardPerSec?: true
    verified?: true
    totalBoosted?: true
    displayOrder?: true
    cachedApy?: true
    cachedStakerCount?: true
    cachedTvlUsd?: true
    poolType?: true
    totalStakedAmount?: true
    boostConfigCollectionName?: true
    boostConfigCollectionOwner?: true
    boostConfigPercent?: true
  }

  export type Staking_poolsMaxAggregateInputType = {
    id?: true
    creatorAddress?: true
    stakeTokenAddress?: true
    rewardTokenAddress?: true
    isDynamicPool?: true
    rewardPerSec?: true
    accumReward?: true
    lastUpdatedTimestamp?: true
    startTimestamp?: true
    endTimestamp?: true
    emergencyLocked?: true
    stakesClosed?: true
    createdAt?: true
    updatedAt?: true
    creatorNetwork?: true
    network?: true
    rewardTokenNetwork?: true
    stakeTokenNetwork?: true
    boostEnabled?: true
    initialEndTimestamp?: true
    initialRewardPerSec?: true
    verified?: true
    totalBoosted?: true
    displayOrder?: true
    cachedApy?: true
    cachedStakerCount?: true
    cachedTvlUsd?: true
    poolType?: true
    totalStakedAmount?: true
    boostConfigCollectionName?: true
    boostConfigCollectionOwner?: true
    boostConfigPercent?: true
  }

  export type Staking_poolsCountAggregateInputType = {
    id?: true
    creatorAddress?: true
    stakeTokenAddress?: true
    rewardTokenAddress?: true
    isDynamicPool?: true
    rewardPerSec?: true
    accumReward?: true
    lastUpdatedTimestamp?: true
    startTimestamp?: true
    endTimestamp?: true
    emergencyLocked?: true
    stakesClosed?: true
    createdAt?: true
    updatedAt?: true
    creatorNetwork?: true
    network?: true
    rewardTokenNetwork?: true
    stakeTokenNetwork?: true
    boostEnabled?: true
    initialEndTimestamp?: true
    initialRewardPerSec?: true
    verified?: true
    totalBoosted?: true
    displayOrder?: true
    cachedApy?: true
    cachedStakerCount?: true
    cachedTvlUsd?: true
    poolType?: true
    totalStakedAmount?: true
    boostConfigCollectionName?: true
    boostConfigCollectionOwner?: true
    boostConfigPercent?: true
    _all?: true
  }

  export type Staking_poolsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which staking_pools to aggregate.
     */
    where?: staking_poolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staking_pools to fetch.
     */
    orderBy?: staking_poolsOrderByWithRelationInput | staking_poolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: staking_poolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staking_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staking_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staking_pools
    **/
    _count?: true | Staking_poolsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Staking_poolsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Staking_poolsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Staking_poolsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Staking_poolsMaxAggregateInputType
  }

  export type GetStaking_poolsAggregateType<T extends Staking_poolsAggregateArgs> = {
        [P in keyof T & keyof AggregateStaking_pools]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaking_pools[P]>
      : GetScalarType<T[P], AggregateStaking_pools[P]>
  }




  export type staking_poolsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: staking_poolsWhereInput
    orderBy?: staking_poolsOrderByWithAggregationInput | staking_poolsOrderByWithAggregationInput[]
    by: Staking_poolsScalarFieldEnum[] | Staking_poolsScalarFieldEnum
    having?: staking_poolsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Staking_poolsCountAggregateInputType | true
    _avg?: Staking_poolsAvgAggregateInputType
    _sum?: Staking_poolsSumAggregateInputType
    _min?: Staking_poolsMinAggregateInputType
    _max?: Staking_poolsMaxAggregateInputType
  }

  export type Staking_poolsGroupByOutputType = {
    id: number
    creatorAddress: string
    stakeTokenAddress: string
    rewardTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward: string
    lastUpdatedTimestamp: bigint
    startTimestamp: bigint
    endTimestamp: bigint
    emergencyLocked: boolean
    stakesClosed: boolean
    createdAt: Date
    updatedAt: Date
    creatorNetwork: string
    network: string
    rewardTokenNetwork: string
    stakeTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint
    initialRewardPerSec: string
    verified: boolean
    totalBoosted: string
    displayOrder: number | null
    cachedApy: string | null
    cachedStakerCount: number | null
    cachedTvlUsd: string | null
    poolType: $Enums.PoolType
    totalStakedAmount: string
    boostConfigCollectionName: string | null
    boostConfigCollectionOwner: string | null
    boostConfigPercent: string | null
    _count: Staking_poolsCountAggregateOutputType | null
    _avg: Staking_poolsAvgAggregateOutputType | null
    _sum: Staking_poolsSumAggregateOutputType | null
    _min: Staking_poolsMinAggregateOutputType | null
    _max: Staking_poolsMaxAggregateOutputType | null
  }

  type GetStaking_poolsGroupByPayload<T extends staking_poolsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Staking_poolsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Staking_poolsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Staking_poolsGroupByOutputType[P]>
            : GetScalarType<T[P], Staking_poolsGroupByOutputType[P]>
        }
      >
    >


  export type staking_poolsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorAddress?: boolean
    stakeTokenAddress?: boolean
    rewardTokenAddress?: boolean
    isDynamicPool?: boolean
    rewardPerSec?: boolean
    accumReward?: boolean
    lastUpdatedTimestamp?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorNetwork?: boolean
    network?: boolean
    rewardTokenNetwork?: boolean
    stakeTokenNetwork?: boolean
    boostEnabled?: boolean
    initialEndTimestamp?: boolean
    initialRewardPerSec?: boolean
    verified?: boolean
    totalBoosted?: boolean
    displayOrder?: boolean
    cachedApy?: boolean
    cachedStakerCount?: boolean
    cachedTvlUsd?: boolean
    poolType?: boolean
    totalStakedAmount?: boolean
    boostConfigCollectionName?: boolean
    boostConfigCollectionOwner?: boolean
    boostConfigPercent?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
    user_stakes?: boolean | staking_pools$user_stakesArgs<ExtArgs>
    _count?: boolean | Staking_poolsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staking_pools"]>

  export type staking_poolsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorAddress?: boolean
    stakeTokenAddress?: boolean
    rewardTokenAddress?: boolean
    isDynamicPool?: boolean
    rewardPerSec?: boolean
    accumReward?: boolean
    lastUpdatedTimestamp?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorNetwork?: boolean
    network?: boolean
    rewardTokenNetwork?: boolean
    stakeTokenNetwork?: boolean
    boostEnabled?: boolean
    initialEndTimestamp?: boolean
    initialRewardPerSec?: boolean
    verified?: boolean
    totalBoosted?: boolean
    displayOrder?: boolean
    cachedApy?: boolean
    cachedStakerCount?: boolean
    cachedTvlUsd?: boolean
    poolType?: boolean
    totalStakedAmount?: boolean
    boostConfigCollectionName?: boolean
    boostConfigCollectionOwner?: boolean
    boostConfigPercent?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staking_pools"]>

  export type staking_poolsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorAddress?: boolean
    stakeTokenAddress?: boolean
    rewardTokenAddress?: boolean
    isDynamicPool?: boolean
    rewardPerSec?: boolean
    accumReward?: boolean
    lastUpdatedTimestamp?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorNetwork?: boolean
    network?: boolean
    rewardTokenNetwork?: boolean
    stakeTokenNetwork?: boolean
    boostEnabled?: boolean
    initialEndTimestamp?: boolean
    initialRewardPerSec?: boolean
    verified?: boolean
    totalBoosted?: boolean
    displayOrder?: boolean
    cachedApy?: boolean
    cachedStakerCount?: boolean
    cachedTvlUsd?: boolean
    poolType?: boolean
    totalStakedAmount?: boolean
    boostConfigCollectionName?: boolean
    boostConfigCollectionOwner?: boolean
    boostConfigPercent?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staking_pools"]>

  export type staking_poolsSelectScalar = {
    id?: boolean
    creatorAddress?: boolean
    stakeTokenAddress?: boolean
    rewardTokenAddress?: boolean
    isDynamicPool?: boolean
    rewardPerSec?: boolean
    accumReward?: boolean
    lastUpdatedTimestamp?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorNetwork?: boolean
    network?: boolean
    rewardTokenNetwork?: boolean
    stakeTokenNetwork?: boolean
    boostEnabled?: boolean
    initialEndTimestamp?: boolean
    initialRewardPerSec?: boolean
    verified?: boolean
    totalBoosted?: boolean
    displayOrder?: boolean
    cachedApy?: boolean
    cachedStakerCount?: boolean
    cachedTvlUsd?: boolean
    poolType?: boolean
    totalStakedAmount?: boolean
    boostConfigCollectionName?: boolean
    boostConfigCollectionOwner?: boolean
    boostConfigPercent?: boolean
  }

  export type staking_poolsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creatorAddress" | "stakeTokenAddress" | "rewardTokenAddress" | "isDynamicPool" | "rewardPerSec" | "accumReward" | "lastUpdatedTimestamp" | "startTimestamp" | "endTimestamp" | "emergencyLocked" | "stakesClosed" | "createdAt" | "updatedAt" | "creatorNetwork" | "network" | "rewardTokenNetwork" | "stakeTokenNetwork" | "boostEnabled" | "initialEndTimestamp" | "initialRewardPerSec" | "verified" | "totalBoosted" | "displayOrder" | "cachedApy" | "cachedStakerCount" | "cachedTvlUsd" | "poolType" | "totalStakedAmount" | "boostConfigCollectionName" | "boostConfigCollectionOwner" | "boostConfigPercent", ExtArgs["result"]["staking_pools"]>
  export type staking_poolsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
    user_stakes?: boolean | staking_pools$user_stakesArgs<ExtArgs>
    _count?: boolean | Staking_poolsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type staking_poolsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
  }
  export type staking_poolsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | tokensDefaultArgs<ExtArgs>
  }

  export type $staking_poolsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "staking_pools"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens: Prisma.$tokensPayload<ExtArgs>
      tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens: Prisma.$tokensPayload<ExtArgs>
      user_stakes: Prisma.$user_stakesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creatorAddress: string
      stakeTokenAddress: string
      rewardTokenAddress: string
      isDynamicPool: boolean
      rewardPerSec: string
      accumReward: string
      lastUpdatedTimestamp: bigint
      startTimestamp: bigint
      endTimestamp: bigint
      emergencyLocked: boolean
      stakesClosed: boolean
      createdAt: Date
      updatedAt: Date
      creatorNetwork: string
      network: string
      rewardTokenNetwork: string
      stakeTokenNetwork: string
      boostEnabled: boolean
      initialEndTimestamp: bigint
      initialRewardPerSec: string
      verified: boolean
      totalBoosted: string
      displayOrder: number | null
      cachedApy: string | null
      cachedStakerCount: number | null
      cachedTvlUsd: string | null
      poolType: $Enums.PoolType
      totalStakedAmount: string
      boostConfigCollectionName: string | null
      boostConfigCollectionOwner: string | null
      boostConfigPercent: string | null
    }, ExtArgs["result"]["staking_pools"]>
    composites: {}
  }

  type staking_poolsGetPayload<S extends boolean | null | undefined | staking_poolsDefaultArgs> = $Result.GetResult<Prisma.$staking_poolsPayload, S>

  type staking_poolsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<staking_poolsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Staking_poolsCountAggregateInputType | true
    }

  export interface staking_poolsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['staking_pools'], meta: { name: 'staking_pools' } }
    /**
     * Find zero or one Staking_pools that matches the filter.
     * @param {staking_poolsFindUniqueArgs} args - Arguments to find a Staking_pools
     * @example
     * // Get one Staking_pools
     * const staking_pools = await prisma.staking_pools.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends staking_poolsFindUniqueArgs>(args: SelectSubset<T, staking_poolsFindUniqueArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staking_pools that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {staking_poolsFindUniqueOrThrowArgs} args - Arguments to find a Staking_pools
     * @example
     * // Get one Staking_pools
     * const staking_pools = await prisma.staking_pools.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends staking_poolsFindUniqueOrThrowArgs>(args: SelectSubset<T, staking_poolsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staking_pools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staking_poolsFindFirstArgs} args - Arguments to find a Staking_pools
     * @example
     * // Get one Staking_pools
     * const staking_pools = await prisma.staking_pools.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends staking_poolsFindFirstArgs>(args?: SelectSubset<T, staking_poolsFindFirstArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staking_pools that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staking_poolsFindFirstOrThrowArgs} args - Arguments to find a Staking_pools
     * @example
     * // Get one Staking_pools
     * const staking_pools = await prisma.staking_pools.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends staking_poolsFindFirstOrThrowArgs>(args?: SelectSubset<T, staking_poolsFindFirstOrThrowArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staking_pools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staking_poolsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staking_pools
     * const staking_pools = await prisma.staking_pools.findMany()
     * 
     * // Get first 10 Staking_pools
     * const staking_pools = await prisma.staking_pools.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staking_poolsWithIdOnly = await prisma.staking_pools.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends staking_poolsFindManyArgs>(args?: SelectSubset<T, staking_poolsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staking_pools.
     * @param {staking_poolsCreateArgs} args - Arguments to create a Staking_pools.
     * @example
     * // Create one Staking_pools
     * const Staking_pools = await prisma.staking_pools.create({
     *   data: {
     *     // ... data to create a Staking_pools
     *   }
     * })
     * 
     */
    create<T extends staking_poolsCreateArgs>(args: SelectSubset<T, staking_poolsCreateArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staking_pools.
     * @param {staking_poolsCreateManyArgs} args - Arguments to create many Staking_pools.
     * @example
     * // Create many Staking_pools
     * const staking_pools = await prisma.staking_pools.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends staking_poolsCreateManyArgs>(args?: SelectSubset<T, staking_poolsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staking_pools and returns the data saved in the database.
     * @param {staking_poolsCreateManyAndReturnArgs} args - Arguments to create many Staking_pools.
     * @example
     * // Create many Staking_pools
     * const staking_pools = await prisma.staking_pools.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staking_pools and only return the `id`
     * const staking_poolsWithIdOnly = await prisma.staking_pools.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends staking_poolsCreateManyAndReturnArgs>(args?: SelectSubset<T, staking_poolsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staking_pools.
     * @param {staking_poolsDeleteArgs} args - Arguments to delete one Staking_pools.
     * @example
     * // Delete one Staking_pools
     * const Staking_pools = await prisma.staking_pools.delete({
     *   where: {
     *     // ... filter to delete one Staking_pools
     *   }
     * })
     * 
     */
    delete<T extends staking_poolsDeleteArgs>(args: SelectSubset<T, staking_poolsDeleteArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staking_pools.
     * @param {staking_poolsUpdateArgs} args - Arguments to update one Staking_pools.
     * @example
     * // Update one Staking_pools
     * const staking_pools = await prisma.staking_pools.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends staking_poolsUpdateArgs>(args: SelectSubset<T, staking_poolsUpdateArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staking_pools.
     * @param {staking_poolsDeleteManyArgs} args - Arguments to filter Staking_pools to delete.
     * @example
     * // Delete a few Staking_pools
     * const { count } = await prisma.staking_pools.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends staking_poolsDeleteManyArgs>(args?: SelectSubset<T, staking_poolsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staking_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staking_poolsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staking_pools
     * const staking_pools = await prisma.staking_pools.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends staking_poolsUpdateManyArgs>(args: SelectSubset<T, staking_poolsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staking_pools and returns the data updated in the database.
     * @param {staking_poolsUpdateManyAndReturnArgs} args - Arguments to update many Staking_pools.
     * @example
     * // Update many Staking_pools
     * const staking_pools = await prisma.staking_pools.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staking_pools and only return the `id`
     * const staking_poolsWithIdOnly = await prisma.staking_pools.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends staking_poolsUpdateManyAndReturnArgs>(args: SelectSubset<T, staking_poolsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staking_pools.
     * @param {staking_poolsUpsertArgs} args - Arguments to update or create a Staking_pools.
     * @example
     * // Update or create a Staking_pools
     * const staking_pools = await prisma.staking_pools.upsert({
     *   create: {
     *     // ... data to create a Staking_pools
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staking_pools we want to update
     *   }
     * })
     */
    upsert<T extends staking_poolsUpsertArgs>(args: SelectSubset<T, staking_poolsUpsertArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staking_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staking_poolsCountArgs} args - Arguments to filter Staking_pools to count.
     * @example
     * // Count the number of Staking_pools
     * const count = await prisma.staking_pools.count({
     *   where: {
     *     // ... the filter for the Staking_pools we want to count
     *   }
     * })
    **/
    count<T extends staking_poolsCountArgs>(
      args?: Subset<T, staking_poolsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Staking_poolsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staking_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staking_poolsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Staking_poolsAggregateArgs>(args: Subset<T, Staking_poolsAggregateArgs>): Prisma.PrismaPromise<GetStaking_poolsAggregateType<T>>

    /**
     * Group by Staking_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staking_poolsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends staking_poolsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: staking_poolsGroupByArgs['orderBy'] }
        : { orderBy?: staking_poolsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, staking_poolsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaking_poolsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the staking_pools model
   */
  readonly fields: staking_poolsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for staking_pools.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__staking_poolsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens<T extends tokensDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tokensDefaultArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens<T extends tokensDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tokensDefaultArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user_stakes<T extends staking_pools$user_stakesArgs<ExtArgs> = {}>(args?: Subset<T, staking_pools$user_stakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the staking_pools model
   */
  interface staking_poolsFieldRefs {
    readonly id: FieldRef<"staking_pools", 'Int'>
    readonly creatorAddress: FieldRef<"staking_pools", 'String'>
    readonly stakeTokenAddress: FieldRef<"staking_pools", 'String'>
    readonly rewardTokenAddress: FieldRef<"staking_pools", 'String'>
    readonly isDynamicPool: FieldRef<"staking_pools", 'Boolean'>
    readonly rewardPerSec: FieldRef<"staking_pools", 'String'>
    readonly accumReward: FieldRef<"staking_pools", 'String'>
    readonly lastUpdatedTimestamp: FieldRef<"staking_pools", 'BigInt'>
    readonly startTimestamp: FieldRef<"staking_pools", 'BigInt'>
    readonly endTimestamp: FieldRef<"staking_pools", 'BigInt'>
    readonly emergencyLocked: FieldRef<"staking_pools", 'Boolean'>
    readonly stakesClosed: FieldRef<"staking_pools", 'Boolean'>
    readonly createdAt: FieldRef<"staking_pools", 'DateTime'>
    readonly updatedAt: FieldRef<"staking_pools", 'DateTime'>
    readonly creatorNetwork: FieldRef<"staking_pools", 'String'>
    readonly network: FieldRef<"staking_pools", 'String'>
    readonly rewardTokenNetwork: FieldRef<"staking_pools", 'String'>
    readonly stakeTokenNetwork: FieldRef<"staking_pools", 'String'>
    readonly boostEnabled: FieldRef<"staking_pools", 'Boolean'>
    readonly initialEndTimestamp: FieldRef<"staking_pools", 'BigInt'>
    readonly initialRewardPerSec: FieldRef<"staking_pools", 'String'>
    readonly verified: FieldRef<"staking_pools", 'Boolean'>
    readonly totalBoosted: FieldRef<"staking_pools", 'String'>
    readonly displayOrder: FieldRef<"staking_pools", 'Int'>
    readonly cachedApy: FieldRef<"staking_pools", 'String'>
    readonly cachedStakerCount: FieldRef<"staking_pools", 'Int'>
    readonly cachedTvlUsd: FieldRef<"staking_pools", 'String'>
    readonly poolType: FieldRef<"staking_pools", 'PoolType'>
    readonly totalStakedAmount: FieldRef<"staking_pools", 'String'>
    readonly boostConfigCollectionName: FieldRef<"staking_pools", 'String'>
    readonly boostConfigCollectionOwner: FieldRef<"staking_pools", 'String'>
    readonly boostConfigPercent: FieldRef<"staking_pools", 'String'>
  }
    

  // Custom InputTypes
  /**
   * staking_pools findUnique
   */
  export type staking_poolsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * Filter, which staking_pools to fetch.
     */
    where: staking_poolsWhereUniqueInput
  }

  /**
   * staking_pools findUniqueOrThrow
   */
  export type staking_poolsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * Filter, which staking_pools to fetch.
     */
    where: staking_poolsWhereUniqueInput
  }

  /**
   * staking_pools findFirst
   */
  export type staking_poolsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * Filter, which staking_pools to fetch.
     */
    where?: staking_poolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staking_pools to fetch.
     */
    orderBy?: staking_poolsOrderByWithRelationInput | staking_poolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staking_pools.
     */
    cursor?: staking_poolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staking_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staking_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staking_pools.
     */
    distinct?: Staking_poolsScalarFieldEnum | Staking_poolsScalarFieldEnum[]
  }

  /**
   * staking_pools findFirstOrThrow
   */
  export type staking_poolsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * Filter, which staking_pools to fetch.
     */
    where?: staking_poolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staking_pools to fetch.
     */
    orderBy?: staking_poolsOrderByWithRelationInput | staking_poolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staking_pools.
     */
    cursor?: staking_poolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staking_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staking_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staking_pools.
     */
    distinct?: Staking_poolsScalarFieldEnum | Staking_poolsScalarFieldEnum[]
  }

  /**
   * staking_pools findMany
   */
  export type staking_poolsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * Filter, which staking_pools to fetch.
     */
    where?: staking_poolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staking_pools to fetch.
     */
    orderBy?: staking_poolsOrderByWithRelationInput | staking_poolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staking_pools.
     */
    cursor?: staking_poolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staking_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staking_pools.
     */
    skip?: number
    distinct?: Staking_poolsScalarFieldEnum | Staking_poolsScalarFieldEnum[]
  }

  /**
   * staking_pools create
   */
  export type staking_poolsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * The data needed to create a staking_pools.
     */
    data: XOR<staking_poolsCreateInput, staking_poolsUncheckedCreateInput>
  }

  /**
   * staking_pools createMany
   */
  export type staking_poolsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many staking_pools.
     */
    data: staking_poolsCreateManyInput | staking_poolsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * staking_pools createManyAndReturn
   */
  export type staking_poolsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * The data used to create many staking_pools.
     */
    data: staking_poolsCreateManyInput | staking_poolsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * staking_pools update
   */
  export type staking_poolsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * The data needed to update a staking_pools.
     */
    data: XOR<staking_poolsUpdateInput, staking_poolsUncheckedUpdateInput>
    /**
     * Choose, which staking_pools to update.
     */
    where: staking_poolsWhereUniqueInput
  }

  /**
   * staking_pools updateMany
   */
  export type staking_poolsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update staking_pools.
     */
    data: XOR<staking_poolsUpdateManyMutationInput, staking_poolsUncheckedUpdateManyInput>
    /**
     * Filter which staking_pools to update
     */
    where?: staking_poolsWhereInput
    /**
     * Limit how many staking_pools to update.
     */
    limit?: number
  }

  /**
   * staking_pools updateManyAndReturn
   */
  export type staking_poolsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * The data used to update staking_pools.
     */
    data: XOR<staking_poolsUpdateManyMutationInput, staking_poolsUncheckedUpdateManyInput>
    /**
     * Filter which staking_pools to update
     */
    where?: staking_poolsWhereInput
    /**
     * Limit how many staking_pools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * staking_pools upsert
   */
  export type staking_poolsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * The filter to search for the staking_pools to update in case it exists.
     */
    where: staking_poolsWhereUniqueInput
    /**
     * In case the staking_pools found by the `where` argument doesn't exist, create a new staking_pools with this data.
     */
    create: XOR<staking_poolsCreateInput, staking_poolsUncheckedCreateInput>
    /**
     * In case the staking_pools was found with the provided `where` argument, update it with this data.
     */
    update: XOR<staking_poolsUpdateInput, staking_poolsUncheckedUpdateInput>
  }

  /**
   * staking_pools delete
   */
  export type staking_poolsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    /**
     * Filter which staking_pools to delete.
     */
    where: staking_poolsWhereUniqueInput
  }

  /**
   * staking_pools deleteMany
   */
  export type staking_poolsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which staking_pools to delete
     */
    where?: staking_poolsWhereInput
    /**
     * Limit how many staking_pools to delete.
     */
    limit?: number
  }

  /**
   * staking_pools.user_stakes
   */
  export type staking_pools$user_stakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    where?: user_stakesWhereInput
    orderBy?: user_stakesOrderByWithRelationInput | user_stakesOrderByWithRelationInput[]
    cursor?: user_stakesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_stakesScalarFieldEnum | User_stakesScalarFieldEnum[]
  }

  /**
   * staking_pools without action
   */
  export type staking_poolsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
  }


  /**
   * Model token_price_history
   */

  export type AggregateToken_price_history = {
    _count: Token_price_historyCountAggregateOutputType | null
    _avg: Token_price_historyAvgAggregateOutputType | null
    _sum: Token_price_historySumAggregateOutputType | null
    _min: Token_price_historyMinAggregateOutputType | null
    _max: Token_price_historyMaxAggregateOutputType | null
  }

  export type Token_price_historyAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: Decimal | null
  }

  export type Token_price_historySumAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: Decimal | null
  }

  export type Token_price_historyMinAggregateOutputType = {
    id: number | null
    network: string | null
    tokenAddress: string | null
    timestamp: bigint | null
    granularity: string | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: Decimal | null
  }

  export type Token_price_historyMaxAggregateOutputType = {
    id: number | null
    network: string | null
    tokenAddress: string | null
    timestamp: bigint | null
    granularity: string | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: Decimal | null
  }

  export type Token_price_historyCountAggregateOutputType = {
    id: number
    network: number
    tokenAddress: number
    timestamp: number
    granularity: number
    open: number
    high: number
    low: number
    close: number
    volume: number
    _all: number
  }


  export type Token_price_historyAvgAggregateInputType = {
    id?: true
    timestamp?: true
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
  }

  export type Token_price_historySumAggregateInputType = {
    id?: true
    timestamp?: true
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
  }

  export type Token_price_historyMinAggregateInputType = {
    id?: true
    network?: true
    tokenAddress?: true
    timestamp?: true
    granularity?: true
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
  }

  export type Token_price_historyMaxAggregateInputType = {
    id?: true
    network?: true
    tokenAddress?: true
    timestamp?: true
    granularity?: true
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
  }

  export type Token_price_historyCountAggregateInputType = {
    id?: true
    network?: true
    tokenAddress?: true
    timestamp?: true
    granularity?: true
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
    _all?: true
  }

  export type Token_price_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which token_price_history to aggregate.
     */
    where?: token_price_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_price_histories to fetch.
     */
    orderBy?: token_price_historyOrderByWithRelationInput | token_price_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: token_price_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_price_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_price_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned token_price_histories
    **/
    _count?: true | Token_price_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Token_price_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Token_price_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Token_price_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Token_price_historyMaxAggregateInputType
  }

  export type GetToken_price_historyAggregateType<T extends Token_price_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateToken_price_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken_price_history[P]>
      : GetScalarType<T[P], AggregateToken_price_history[P]>
  }




  export type token_price_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: token_price_historyWhereInput
    orderBy?: token_price_historyOrderByWithAggregationInput | token_price_historyOrderByWithAggregationInput[]
    by: Token_price_historyScalarFieldEnum[] | Token_price_historyScalarFieldEnum
    having?: token_price_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Token_price_historyCountAggregateInputType | true
    _avg?: Token_price_historyAvgAggregateInputType
    _sum?: Token_price_historySumAggregateInputType
    _min?: Token_price_historyMinAggregateInputType
    _max?: Token_price_historyMaxAggregateInputType
  }

  export type Token_price_historyGroupByOutputType = {
    id: number
    network: string
    tokenAddress: string
    timestamp: bigint
    granularity: string
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: Decimal | null
    _count: Token_price_historyCountAggregateOutputType | null
    _avg: Token_price_historyAvgAggregateOutputType | null
    _sum: Token_price_historySumAggregateOutputType | null
    _min: Token_price_historyMinAggregateOutputType | null
    _max: Token_price_historyMaxAggregateOutputType | null
  }

  type GetToken_price_historyGroupByPayload<T extends token_price_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Token_price_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Token_price_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Token_price_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Token_price_historyGroupByOutputType[P]>
        }
      >
    >


  export type token_price_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    tokenAddress?: boolean
    timestamp?: boolean
    granularity?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    volume?: boolean
  }, ExtArgs["result"]["token_price_history"]>

  export type token_price_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    tokenAddress?: boolean
    timestamp?: boolean
    granularity?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    volume?: boolean
  }, ExtArgs["result"]["token_price_history"]>

  export type token_price_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    tokenAddress?: boolean
    timestamp?: boolean
    granularity?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    volume?: boolean
  }, ExtArgs["result"]["token_price_history"]>

  export type token_price_historySelectScalar = {
    id?: boolean
    network?: boolean
    tokenAddress?: boolean
    timestamp?: boolean
    granularity?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    volume?: boolean
  }

  export type token_price_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "network" | "tokenAddress" | "timestamp" | "granularity" | "open" | "high" | "low" | "close" | "volume", ExtArgs["result"]["token_price_history"]>

  export type $token_price_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "token_price_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      network: string
      tokenAddress: string
      timestamp: bigint
      granularity: string
      open: Prisma.Decimal | null
      high: Prisma.Decimal | null
      low: Prisma.Decimal | null
      close: Prisma.Decimal | null
      volume: Prisma.Decimal | null
    }, ExtArgs["result"]["token_price_history"]>
    composites: {}
  }

  type token_price_historyGetPayload<S extends boolean | null | undefined | token_price_historyDefaultArgs> = $Result.GetResult<Prisma.$token_price_historyPayload, S>

  type token_price_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<token_price_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Token_price_historyCountAggregateInputType | true
    }

  export interface token_price_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['token_price_history'], meta: { name: 'token_price_history' } }
    /**
     * Find zero or one Token_price_history that matches the filter.
     * @param {token_price_historyFindUniqueArgs} args - Arguments to find a Token_price_history
     * @example
     * // Get one Token_price_history
     * const token_price_history = await prisma.token_price_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends token_price_historyFindUniqueArgs>(args: SelectSubset<T, token_price_historyFindUniqueArgs<ExtArgs>>): Prisma__token_price_historyClient<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token_price_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {token_price_historyFindUniqueOrThrowArgs} args - Arguments to find a Token_price_history
     * @example
     * // Get one Token_price_history
     * const token_price_history = await prisma.token_price_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends token_price_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, token_price_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__token_price_historyClient<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token_price_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_price_historyFindFirstArgs} args - Arguments to find a Token_price_history
     * @example
     * // Get one Token_price_history
     * const token_price_history = await prisma.token_price_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends token_price_historyFindFirstArgs>(args?: SelectSubset<T, token_price_historyFindFirstArgs<ExtArgs>>): Prisma__token_price_historyClient<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token_price_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_price_historyFindFirstOrThrowArgs} args - Arguments to find a Token_price_history
     * @example
     * // Get one Token_price_history
     * const token_price_history = await prisma.token_price_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends token_price_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, token_price_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__token_price_historyClient<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Token_price_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_price_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Token_price_histories
     * const token_price_histories = await prisma.token_price_history.findMany()
     * 
     * // Get first 10 Token_price_histories
     * const token_price_histories = await prisma.token_price_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const token_price_historyWithIdOnly = await prisma.token_price_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends token_price_historyFindManyArgs>(args?: SelectSubset<T, token_price_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token_price_history.
     * @param {token_price_historyCreateArgs} args - Arguments to create a Token_price_history.
     * @example
     * // Create one Token_price_history
     * const Token_price_history = await prisma.token_price_history.create({
     *   data: {
     *     // ... data to create a Token_price_history
     *   }
     * })
     * 
     */
    create<T extends token_price_historyCreateArgs>(args: SelectSubset<T, token_price_historyCreateArgs<ExtArgs>>): Prisma__token_price_historyClient<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Token_price_histories.
     * @param {token_price_historyCreateManyArgs} args - Arguments to create many Token_price_histories.
     * @example
     * // Create many Token_price_histories
     * const token_price_history = await prisma.token_price_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends token_price_historyCreateManyArgs>(args?: SelectSubset<T, token_price_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Token_price_histories and returns the data saved in the database.
     * @param {token_price_historyCreateManyAndReturnArgs} args - Arguments to create many Token_price_histories.
     * @example
     * // Create many Token_price_histories
     * const token_price_history = await prisma.token_price_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Token_price_histories and only return the `id`
     * const token_price_historyWithIdOnly = await prisma.token_price_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends token_price_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, token_price_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token_price_history.
     * @param {token_price_historyDeleteArgs} args - Arguments to delete one Token_price_history.
     * @example
     * // Delete one Token_price_history
     * const Token_price_history = await prisma.token_price_history.delete({
     *   where: {
     *     // ... filter to delete one Token_price_history
     *   }
     * })
     * 
     */
    delete<T extends token_price_historyDeleteArgs>(args: SelectSubset<T, token_price_historyDeleteArgs<ExtArgs>>): Prisma__token_price_historyClient<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token_price_history.
     * @param {token_price_historyUpdateArgs} args - Arguments to update one Token_price_history.
     * @example
     * // Update one Token_price_history
     * const token_price_history = await prisma.token_price_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends token_price_historyUpdateArgs>(args: SelectSubset<T, token_price_historyUpdateArgs<ExtArgs>>): Prisma__token_price_historyClient<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Token_price_histories.
     * @param {token_price_historyDeleteManyArgs} args - Arguments to filter Token_price_histories to delete.
     * @example
     * // Delete a few Token_price_histories
     * const { count } = await prisma.token_price_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends token_price_historyDeleteManyArgs>(args?: SelectSubset<T, token_price_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_price_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_price_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Token_price_histories
     * const token_price_history = await prisma.token_price_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends token_price_historyUpdateManyArgs>(args: SelectSubset<T, token_price_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_price_histories and returns the data updated in the database.
     * @param {token_price_historyUpdateManyAndReturnArgs} args - Arguments to update many Token_price_histories.
     * @example
     * // Update many Token_price_histories
     * const token_price_history = await prisma.token_price_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Token_price_histories and only return the `id`
     * const token_price_historyWithIdOnly = await prisma.token_price_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends token_price_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, token_price_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token_price_history.
     * @param {token_price_historyUpsertArgs} args - Arguments to update or create a Token_price_history.
     * @example
     * // Update or create a Token_price_history
     * const token_price_history = await prisma.token_price_history.upsert({
     *   create: {
     *     // ... data to create a Token_price_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token_price_history we want to update
     *   }
     * })
     */
    upsert<T extends token_price_historyUpsertArgs>(args: SelectSubset<T, token_price_historyUpsertArgs<ExtArgs>>): Prisma__token_price_historyClient<$Result.GetResult<Prisma.$token_price_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Token_price_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_price_historyCountArgs} args - Arguments to filter Token_price_histories to count.
     * @example
     * // Count the number of Token_price_histories
     * const count = await prisma.token_price_history.count({
     *   where: {
     *     // ... the filter for the Token_price_histories we want to count
     *   }
     * })
    **/
    count<T extends token_price_historyCountArgs>(
      args?: Subset<T, token_price_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Token_price_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token_price_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_price_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Token_price_historyAggregateArgs>(args: Subset<T, Token_price_historyAggregateArgs>): Prisma.PrismaPromise<GetToken_price_historyAggregateType<T>>

    /**
     * Group by Token_price_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_price_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends token_price_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: token_price_historyGroupByArgs['orderBy'] }
        : { orderBy?: token_price_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, token_price_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToken_price_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the token_price_history model
   */
  readonly fields: token_price_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for token_price_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__token_price_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the token_price_history model
   */
  interface token_price_historyFieldRefs {
    readonly id: FieldRef<"token_price_history", 'Int'>
    readonly network: FieldRef<"token_price_history", 'String'>
    readonly tokenAddress: FieldRef<"token_price_history", 'String'>
    readonly timestamp: FieldRef<"token_price_history", 'BigInt'>
    readonly granularity: FieldRef<"token_price_history", 'String'>
    readonly open: FieldRef<"token_price_history", 'Decimal'>
    readonly high: FieldRef<"token_price_history", 'Decimal'>
    readonly low: FieldRef<"token_price_history", 'Decimal'>
    readonly close: FieldRef<"token_price_history", 'Decimal'>
    readonly volume: FieldRef<"token_price_history", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * token_price_history findUnique
   */
  export type token_price_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * Filter, which token_price_history to fetch.
     */
    where: token_price_historyWhereUniqueInput
  }

  /**
   * token_price_history findUniqueOrThrow
   */
  export type token_price_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * Filter, which token_price_history to fetch.
     */
    where: token_price_historyWhereUniqueInput
  }

  /**
   * token_price_history findFirst
   */
  export type token_price_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * Filter, which token_price_history to fetch.
     */
    where?: token_price_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_price_histories to fetch.
     */
    orderBy?: token_price_historyOrderByWithRelationInput | token_price_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_price_histories.
     */
    cursor?: token_price_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_price_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_price_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_price_histories.
     */
    distinct?: Token_price_historyScalarFieldEnum | Token_price_historyScalarFieldEnum[]
  }

  /**
   * token_price_history findFirstOrThrow
   */
  export type token_price_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * Filter, which token_price_history to fetch.
     */
    where?: token_price_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_price_histories to fetch.
     */
    orderBy?: token_price_historyOrderByWithRelationInput | token_price_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_price_histories.
     */
    cursor?: token_price_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_price_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_price_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_price_histories.
     */
    distinct?: Token_price_historyScalarFieldEnum | Token_price_historyScalarFieldEnum[]
  }

  /**
   * token_price_history findMany
   */
  export type token_price_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * Filter, which token_price_histories to fetch.
     */
    where?: token_price_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_price_histories to fetch.
     */
    orderBy?: token_price_historyOrderByWithRelationInput | token_price_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing token_price_histories.
     */
    cursor?: token_price_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_price_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_price_histories.
     */
    skip?: number
    distinct?: Token_price_historyScalarFieldEnum | Token_price_historyScalarFieldEnum[]
  }

  /**
   * token_price_history create
   */
  export type token_price_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a token_price_history.
     */
    data: XOR<token_price_historyCreateInput, token_price_historyUncheckedCreateInput>
  }

  /**
   * token_price_history createMany
   */
  export type token_price_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many token_price_histories.
     */
    data: token_price_historyCreateManyInput | token_price_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * token_price_history createManyAndReturn
   */
  export type token_price_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * The data used to create many token_price_histories.
     */
    data: token_price_historyCreateManyInput | token_price_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * token_price_history update
   */
  export type token_price_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a token_price_history.
     */
    data: XOR<token_price_historyUpdateInput, token_price_historyUncheckedUpdateInput>
    /**
     * Choose, which token_price_history to update.
     */
    where: token_price_historyWhereUniqueInput
  }

  /**
   * token_price_history updateMany
   */
  export type token_price_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update token_price_histories.
     */
    data: XOR<token_price_historyUpdateManyMutationInput, token_price_historyUncheckedUpdateManyInput>
    /**
     * Filter which token_price_histories to update
     */
    where?: token_price_historyWhereInput
    /**
     * Limit how many token_price_histories to update.
     */
    limit?: number
  }

  /**
   * token_price_history updateManyAndReturn
   */
  export type token_price_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * The data used to update token_price_histories.
     */
    data: XOR<token_price_historyUpdateManyMutationInput, token_price_historyUncheckedUpdateManyInput>
    /**
     * Filter which token_price_histories to update
     */
    where?: token_price_historyWhereInput
    /**
     * Limit how many token_price_histories to update.
     */
    limit?: number
  }

  /**
   * token_price_history upsert
   */
  export type token_price_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the token_price_history to update in case it exists.
     */
    where: token_price_historyWhereUniqueInput
    /**
     * In case the token_price_history found by the `where` argument doesn't exist, create a new token_price_history with this data.
     */
    create: XOR<token_price_historyCreateInput, token_price_historyUncheckedCreateInput>
    /**
     * In case the token_price_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<token_price_historyUpdateInput, token_price_historyUncheckedUpdateInput>
  }

  /**
   * token_price_history delete
   */
  export type token_price_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
    /**
     * Filter which token_price_history to delete.
     */
    where: token_price_historyWhereUniqueInput
  }

  /**
   * token_price_history deleteMany
   */
  export type token_price_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which token_price_histories to delete
     */
    where?: token_price_historyWhereInput
    /**
     * Limit how many token_price_histories to delete.
     */
    limit?: number
  }

  /**
   * token_price_history without action
   */
  export type token_price_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_price_history
     */
    select?: token_price_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_price_history
     */
    omit?: token_price_historyOmit<ExtArgs> | null
  }


  /**
   * Model token_prices
   */

  export type AggregateToken_prices = {
    _count: Token_pricesCountAggregateOutputType | null
    _avg: Token_pricesAvgAggregateOutputType | null
    _sum: Token_pricesSumAggregateOutputType | null
    _min: Token_pricesMinAggregateOutputType | null
    _max: Token_pricesMaxAggregateOutputType | null
  }

  export type Token_pricesAvgAggregateOutputType = {
    id: number | null
    priceUsd: Decimal | null
    priceAnchor: Decimal | null
  }

  export type Token_pricesSumAggregateOutputType = {
    id: number | null
    priceUsd: Decimal | null
    priceAnchor: Decimal | null
  }

  export type Token_pricesMinAggregateOutputType = {
    id: number | null
    network: string | null
    tokenAddress: string | null
    priceUsd: Decimal | null
    priceAnchor: Decimal | null
    source: string | null
    lastUpdatedAt: Date | null
  }

  export type Token_pricesMaxAggregateOutputType = {
    id: number | null
    network: string | null
    tokenAddress: string | null
    priceUsd: Decimal | null
    priceAnchor: Decimal | null
    source: string | null
    lastUpdatedAt: Date | null
  }

  export type Token_pricesCountAggregateOutputType = {
    id: number
    network: number
    tokenAddress: number
    priceUsd: number
    priceAnchor: number
    source: number
    lastUpdatedAt: number
    _all: number
  }


  export type Token_pricesAvgAggregateInputType = {
    id?: true
    priceUsd?: true
    priceAnchor?: true
  }

  export type Token_pricesSumAggregateInputType = {
    id?: true
    priceUsd?: true
    priceAnchor?: true
  }

  export type Token_pricesMinAggregateInputType = {
    id?: true
    network?: true
    tokenAddress?: true
    priceUsd?: true
    priceAnchor?: true
    source?: true
    lastUpdatedAt?: true
  }

  export type Token_pricesMaxAggregateInputType = {
    id?: true
    network?: true
    tokenAddress?: true
    priceUsd?: true
    priceAnchor?: true
    source?: true
    lastUpdatedAt?: true
  }

  export type Token_pricesCountAggregateInputType = {
    id?: true
    network?: true
    tokenAddress?: true
    priceUsd?: true
    priceAnchor?: true
    source?: true
    lastUpdatedAt?: true
    _all?: true
  }

  export type Token_pricesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which token_prices to aggregate.
     */
    where?: token_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_prices to fetch.
     */
    orderBy?: token_pricesOrderByWithRelationInput | token_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: token_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned token_prices
    **/
    _count?: true | Token_pricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Token_pricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Token_pricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Token_pricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Token_pricesMaxAggregateInputType
  }

  export type GetToken_pricesAggregateType<T extends Token_pricesAggregateArgs> = {
        [P in keyof T & keyof AggregateToken_prices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken_prices[P]>
      : GetScalarType<T[P], AggregateToken_prices[P]>
  }




  export type token_pricesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: token_pricesWhereInput
    orderBy?: token_pricesOrderByWithAggregationInput | token_pricesOrderByWithAggregationInput[]
    by: Token_pricesScalarFieldEnum[] | Token_pricesScalarFieldEnum
    having?: token_pricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Token_pricesCountAggregateInputType | true
    _avg?: Token_pricesAvgAggregateInputType
    _sum?: Token_pricesSumAggregateInputType
    _min?: Token_pricesMinAggregateInputType
    _max?: Token_pricesMaxAggregateInputType
  }

  export type Token_pricesGroupByOutputType = {
    id: number
    network: string
    tokenAddress: string
    priceUsd: Decimal | null
    priceAnchor: Decimal | null
    source: string | null
    lastUpdatedAt: Date
    _count: Token_pricesCountAggregateOutputType | null
    _avg: Token_pricesAvgAggregateOutputType | null
    _sum: Token_pricesSumAggregateOutputType | null
    _min: Token_pricesMinAggregateOutputType | null
    _max: Token_pricesMaxAggregateOutputType | null
  }

  type GetToken_pricesGroupByPayload<T extends token_pricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Token_pricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Token_pricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Token_pricesGroupByOutputType[P]>
            : GetScalarType<T[P], Token_pricesGroupByOutputType[P]>
        }
      >
    >


  export type token_pricesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    tokenAddress?: boolean
    priceUsd?: boolean
    priceAnchor?: boolean
    source?: boolean
    lastUpdatedAt?: boolean
  }, ExtArgs["result"]["token_prices"]>

  export type token_pricesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    tokenAddress?: boolean
    priceUsd?: boolean
    priceAnchor?: boolean
    source?: boolean
    lastUpdatedAt?: boolean
  }, ExtArgs["result"]["token_prices"]>

  export type token_pricesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    tokenAddress?: boolean
    priceUsd?: boolean
    priceAnchor?: boolean
    source?: boolean
    lastUpdatedAt?: boolean
  }, ExtArgs["result"]["token_prices"]>

  export type token_pricesSelectScalar = {
    id?: boolean
    network?: boolean
    tokenAddress?: boolean
    priceUsd?: boolean
    priceAnchor?: boolean
    source?: boolean
    lastUpdatedAt?: boolean
  }

  export type token_pricesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "network" | "tokenAddress" | "priceUsd" | "priceAnchor" | "source" | "lastUpdatedAt", ExtArgs["result"]["token_prices"]>

  export type $token_pricesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "token_prices"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      network: string
      tokenAddress: string
      priceUsd: Prisma.Decimal | null
      priceAnchor: Prisma.Decimal | null
      source: string | null
      lastUpdatedAt: Date
    }, ExtArgs["result"]["token_prices"]>
    composites: {}
  }

  type token_pricesGetPayload<S extends boolean | null | undefined | token_pricesDefaultArgs> = $Result.GetResult<Prisma.$token_pricesPayload, S>

  type token_pricesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<token_pricesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Token_pricesCountAggregateInputType | true
    }

  export interface token_pricesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['token_prices'], meta: { name: 'token_prices' } }
    /**
     * Find zero or one Token_prices that matches the filter.
     * @param {token_pricesFindUniqueArgs} args - Arguments to find a Token_prices
     * @example
     * // Get one Token_prices
     * const token_prices = await prisma.token_prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends token_pricesFindUniqueArgs>(args: SelectSubset<T, token_pricesFindUniqueArgs<ExtArgs>>): Prisma__token_pricesClient<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token_prices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {token_pricesFindUniqueOrThrowArgs} args - Arguments to find a Token_prices
     * @example
     * // Get one Token_prices
     * const token_prices = await prisma.token_prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends token_pricesFindUniqueOrThrowArgs>(args: SelectSubset<T, token_pricesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__token_pricesClient<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_pricesFindFirstArgs} args - Arguments to find a Token_prices
     * @example
     * // Get one Token_prices
     * const token_prices = await prisma.token_prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends token_pricesFindFirstArgs>(args?: SelectSubset<T, token_pricesFindFirstArgs<ExtArgs>>): Prisma__token_pricesClient<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token_prices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_pricesFindFirstOrThrowArgs} args - Arguments to find a Token_prices
     * @example
     * // Get one Token_prices
     * const token_prices = await prisma.token_prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends token_pricesFindFirstOrThrowArgs>(args?: SelectSubset<T, token_pricesFindFirstOrThrowArgs<ExtArgs>>): Prisma__token_pricesClient<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Token_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_pricesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Token_prices
     * const token_prices = await prisma.token_prices.findMany()
     * 
     * // Get first 10 Token_prices
     * const token_prices = await prisma.token_prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const token_pricesWithIdOnly = await prisma.token_prices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends token_pricesFindManyArgs>(args?: SelectSubset<T, token_pricesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token_prices.
     * @param {token_pricesCreateArgs} args - Arguments to create a Token_prices.
     * @example
     * // Create one Token_prices
     * const Token_prices = await prisma.token_prices.create({
     *   data: {
     *     // ... data to create a Token_prices
     *   }
     * })
     * 
     */
    create<T extends token_pricesCreateArgs>(args: SelectSubset<T, token_pricesCreateArgs<ExtArgs>>): Prisma__token_pricesClient<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Token_prices.
     * @param {token_pricesCreateManyArgs} args - Arguments to create many Token_prices.
     * @example
     * // Create many Token_prices
     * const token_prices = await prisma.token_prices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends token_pricesCreateManyArgs>(args?: SelectSubset<T, token_pricesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Token_prices and returns the data saved in the database.
     * @param {token_pricesCreateManyAndReturnArgs} args - Arguments to create many Token_prices.
     * @example
     * // Create many Token_prices
     * const token_prices = await prisma.token_prices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Token_prices and only return the `id`
     * const token_pricesWithIdOnly = await prisma.token_prices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends token_pricesCreateManyAndReturnArgs>(args?: SelectSubset<T, token_pricesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token_prices.
     * @param {token_pricesDeleteArgs} args - Arguments to delete one Token_prices.
     * @example
     * // Delete one Token_prices
     * const Token_prices = await prisma.token_prices.delete({
     *   where: {
     *     // ... filter to delete one Token_prices
     *   }
     * })
     * 
     */
    delete<T extends token_pricesDeleteArgs>(args: SelectSubset<T, token_pricesDeleteArgs<ExtArgs>>): Prisma__token_pricesClient<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token_prices.
     * @param {token_pricesUpdateArgs} args - Arguments to update one Token_prices.
     * @example
     * // Update one Token_prices
     * const token_prices = await prisma.token_prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends token_pricesUpdateArgs>(args: SelectSubset<T, token_pricesUpdateArgs<ExtArgs>>): Prisma__token_pricesClient<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Token_prices.
     * @param {token_pricesDeleteManyArgs} args - Arguments to filter Token_prices to delete.
     * @example
     * // Delete a few Token_prices
     * const { count } = await prisma.token_prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends token_pricesDeleteManyArgs>(args?: SelectSubset<T, token_pricesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_pricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Token_prices
     * const token_prices = await prisma.token_prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends token_pricesUpdateManyArgs>(args: SelectSubset<T, token_pricesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_prices and returns the data updated in the database.
     * @param {token_pricesUpdateManyAndReturnArgs} args - Arguments to update many Token_prices.
     * @example
     * // Update many Token_prices
     * const token_prices = await prisma.token_prices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Token_prices and only return the `id`
     * const token_pricesWithIdOnly = await prisma.token_prices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends token_pricesUpdateManyAndReturnArgs>(args: SelectSubset<T, token_pricesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token_prices.
     * @param {token_pricesUpsertArgs} args - Arguments to update or create a Token_prices.
     * @example
     * // Update or create a Token_prices
     * const token_prices = await prisma.token_prices.upsert({
     *   create: {
     *     // ... data to create a Token_prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token_prices we want to update
     *   }
     * })
     */
    upsert<T extends token_pricesUpsertArgs>(args: SelectSubset<T, token_pricesUpsertArgs<ExtArgs>>): Prisma__token_pricesClient<$Result.GetResult<Prisma.$token_pricesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Token_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_pricesCountArgs} args - Arguments to filter Token_prices to count.
     * @example
     * // Count the number of Token_prices
     * const count = await prisma.token_prices.count({
     *   where: {
     *     // ... the filter for the Token_prices we want to count
     *   }
     * })
    **/
    count<T extends token_pricesCountArgs>(
      args?: Subset<T, token_pricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Token_pricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_pricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Token_pricesAggregateArgs>(args: Subset<T, Token_pricesAggregateArgs>): Prisma.PrismaPromise<GetToken_pricesAggregateType<T>>

    /**
     * Group by Token_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_pricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends token_pricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: token_pricesGroupByArgs['orderBy'] }
        : { orderBy?: token_pricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, token_pricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToken_pricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the token_prices model
   */
  readonly fields: token_pricesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for token_prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__token_pricesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the token_prices model
   */
  interface token_pricesFieldRefs {
    readonly id: FieldRef<"token_prices", 'Int'>
    readonly network: FieldRef<"token_prices", 'String'>
    readonly tokenAddress: FieldRef<"token_prices", 'String'>
    readonly priceUsd: FieldRef<"token_prices", 'Decimal'>
    readonly priceAnchor: FieldRef<"token_prices", 'Decimal'>
    readonly source: FieldRef<"token_prices", 'String'>
    readonly lastUpdatedAt: FieldRef<"token_prices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * token_prices findUnique
   */
  export type token_pricesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * Filter, which token_prices to fetch.
     */
    where: token_pricesWhereUniqueInput
  }

  /**
   * token_prices findUniqueOrThrow
   */
  export type token_pricesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * Filter, which token_prices to fetch.
     */
    where: token_pricesWhereUniqueInput
  }

  /**
   * token_prices findFirst
   */
  export type token_pricesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * Filter, which token_prices to fetch.
     */
    where?: token_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_prices to fetch.
     */
    orderBy?: token_pricesOrderByWithRelationInput | token_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_prices.
     */
    cursor?: token_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_prices.
     */
    distinct?: Token_pricesScalarFieldEnum | Token_pricesScalarFieldEnum[]
  }

  /**
   * token_prices findFirstOrThrow
   */
  export type token_pricesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * Filter, which token_prices to fetch.
     */
    where?: token_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_prices to fetch.
     */
    orderBy?: token_pricesOrderByWithRelationInput | token_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_prices.
     */
    cursor?: token_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_prices.
     */
    distinct?: Token_pricesScalarFieldEnum | Token_pricesScalarFieldEnum[]
  }

  /**
   * token_prices findMany
   */
  export type token_pricesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * Filter, which token_prices to fetch.
     */
    where?: token_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_prices to fetch.
     */
    orderBy?: token_pricesOrderByWithRelationInput | token_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing token_prices.
     */
    cursor?: token_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_prices.
     */
    skip?: number
    distinct?: Token_pricesScalarFieldEnum | Token_pricesScalarFieldEnum[]
  }

  /**
   * token_prices create
   */
  export type token_pricesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * The data needed to create a token_prices.
     */
    data: XOR<token_pricesCreateInput, token_pricesUncheckedCreateInput>
  }

  /**
   * token_prices createMany
   */
  export type token_pricesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many token_prices.
     */
    data: token_pricesCreateManyInput | token_pricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * token_prices createManyAndReturn
   */
  export type token_pricesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * The data used to create many token_prices.
     */
    data: token_pricesCreateManyInput | token_pricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * token_prices update
   */
  export type token_pricesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * The data needed to update a token_prices.
     */
    data: XOR<token_pricesUpdateInput, token_pricesUncheckedUpdateInput>
    /**
     * Choose, which token_prices to update.
     */
    where: token_pricesWhereUniqueInput
  }

  /**
   * token_prices updateMany
   */
  export type token_pricesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update token_prices.
     */
    data: XOR<token_pricesUpdateManyMutationInput, token_pricesUncheckedUpdateManyInput>
    /**
     * Filter which token_prices to update
     */
    where?: token_pricesWhereInput
    /**
     * Limit how many token_prices to update.
     */
    limit?: number
  }

  /**
   * token_prices updateManyAndReturn
   */
  export type token_pricesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * The data used to update token_prices.
     */
    data: XOR<token_pricesUpdateManyMutationInput, token_pricesUncheckedUpdateManyInput>
    /**
     * Filter which token_prices to update
     */
    where?: token_pricesWhereInput
    /**
     * Limit how many token_prices to update.
     */
    limit?: number
  }

  /**
   * token_prices upsert
   */
  export type token_pricesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * The filter to search for the token_prices to update in case it exists.
     */
    where: token_pricesWhereUniqueInput
    /**
     * In case the token_prices found by the `where` argument doesn't exist, create a new token_prices with this data.
     */
    create: XOR<token_pricesCreateInput, token_pricesUncheckedCreateInput>
    /**
     * In case the token_prices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<token_pricesUpdateInput, token_pricesUncheckedUpdateInput>
  }

  /**
   * token_prices delete
   */
  export type token_pricesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
    /**
     * Filter which token_prices to delete.
     */
    where: token_pricesWhereUniqueInput
  }

  /**
   * token_prices deleteMany
   */
  export type token_pricesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which token_prices to delete
     */
    where?: token_pricesWhereInput
    /**
     * Limit how many token_prices to delete.
     */
    limit?: number
  }

  /**
   * token_prices without action
   */
  export type token_pricesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_prices
     */
    select?: token_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_prices
     */
    omit?: token_pricesOmit<ExtArgs> | null
  }


  /**
   * Model tokens
   */

  export type AggregateTokens = {
    _count: TokensCountAggregateOutputType | null
    _avg: TokensAvgAggregateOutputType | null
    _sum: TokensSumAggregateOutputType | null
    _min: TokensMinAggregateOutputType | null
    _max: TokensMaxAggregateOutputType | null
  }

  export type TokensAvgAggregateOutputType = {
    decimals: number | null
    displayOrder: number | null
    priceChange24hPercent: Decimal | null
    priceUsdCurrent: Decimal | null
    priceAnchor: Decimal | null
  }

  export type TokensSumAggregateOutputType = {
    decimals: number | null
    displayOrder: number | null
    priceChange24hPercent: Decimal | null
    priceUsdCurrent: Decimal | null
    priceAnchor: Decimal | null
  }

  export type TokensMinAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    decimals: number | null
    iconUri: string | null
    projectUri: string | null
    network: string | null
    lastMetadataAttempt: Date | null
    metadataFetched: boolean | null
    metadataStandard: string | null
    verified: boolean | null
    displayOrder: number | null
    originalCoinType: string | null
    circulatingSupply: string | null
    createdAt: Date | null
    marketCapUsd: string | null
    priceChange24hPercent: Decimal | null
    priceUsdCurrent: Decimal | null
    priceAnchor: Decimal | null
    lastPriceUpdate: Date | null
    totalSupply: string | null
    updatedAt: Date | null
    volume24hUsd: string | null
  }

  export type TokensMaxAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    decimals: number | null
    iconUri: string | null
    projectUri: string | null
    network: string | null
    lastMetadataAttempt: Date | null
    metadataFetched: boolean | null
    metadataStandard: string | null
    verified: boolean | null
    displayOrder: number | null
    originalCoinType: string | null
    circulatingSupply: string | null
    createdAt: Date | null
    marketCapUsd: string | null
    priceChange24hPercent: Decimal | null
    priceUsdCurrent: Decimal | null
    priceAnchor: Decimal | null
    lastPriceUpdate: Date | null
    totalSupply: string | null
    updatedAt: Date | null
    volume24hUsd: string | null
  }

  export type TokensCountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    decimals: number
    iconUri: number
    projectUri: number
    network: number
    lastMetadataAttempt: number
    metadataFetched: number
    metadataStandard: number
    verified: number
    displayOrder: number
    originalCoinType: number
    circulatingSupply: number
    createdAt: number
    marketCapUsd: number
    priceChange24hPercent: number
    priceUsdCurrent: number
    priceAnchor: number
    lastPriceUpdate: number
    totalSupply: number
    updatedAt: number
    volume24hUsd: number
    _all: number
  }


  export type TokensAvgAggregateInputType = {
    decimals?: true
    displayOrder?: true
    priceChange24hPercent?: true
    priceUsdCurrent?: true
    priceAnchor?: true
  }

  export type TokensSumAggregateInputType = {
    decimals?: true
    displayOrder?: true
    priceChange24hPercent?: true
    priceUsdCurrent?: true
    priceAnchor?: true
  }

  export type TokensMinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    decimals?: true
    iconUri?: true
    projectUri?: true
    network?: true
    lastMetadataAttempt?: true
    metadataFetched?: true
    metadataStandard?: true
    verified?: true
    displayOrder?: true
    originalCoinType?: true
    circulatingSupply?: true
    createdAt?: true
    marketCapUsd?: true
    priceChange24hPercent?: true
    priceUsdCurrent?: true
    priceAnchor?: true
    lastPriceUpdate?: true
    totalSupply?: true
    updatedAt?: true
    volume24hUsd?: true
  }

  export type TokensMaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    decimals?: true
    iconUri?: true
    projectUri?: true
    network?: true
    lastMetadataAttempt?: true
    metadataFetched?: true
    metadataStandard?: true
    verified?: true
    displayOrder?: true
    originalCoinType?: true
    circulatingSupply?: true
    createdAt?: true
    marketCapUsd?: true
    priceChange24hPercent?: true
    priceUsdCurrent?: true
    priceAnchor?: true
    lastPriceUpdate?: true
    totalSupply?: true
    updatedAt?: true
    volume24hUsd?: true
  }

  export type TokensCountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    decimals?: true
    iconUri?: true
    projectUri?: true
    network?: true
    lastMetadataAttempt?: true
    metadataFetched?: true
    metadataStandard?: true
    verified?: true
    displayOrder?: true
    originalCoinType?: true
    circulatingSupply?: true
    createdAt?: true
    marketCapUsd?: true
    priceChange24hPercent?: true
    priceUsdCurrent?: true
    priceAnchor?: true
    lastPriceUpdate?: true
    totalSupply?: true
    updatedAt?: true
    volume24hUsd?: true
    _all?: true
  }

  export type TokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens to aggregate.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokens
    **/
    _count?: true | TokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokensMaxAggregateInputType
  }

  export type GetTokensAggregateType<T extends TokensAggregateArgs> = {
        [P in keyof T & keyof AggregateTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokens[P]>
      : GetScalarType<T[P], AggregateTokens[P]>
  }




  export type tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokensWhereInput
    orderBy?: tokensOrderByWithAggregationInput | tokensOrderByWithAggregationInput[]
    by: TokensScalarFieldEnum[] | TokensScalarFieldEnum
    having?: tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokensCountAggregateInputType | true
    _avg?: TokensAvgAggregateInputType
    _sum?: TokensSumAggregateInputType
    _min?: TokensMinAggregateInputType
    _max?: TokensMaxAggregateInputType
  }

  export type TokensGroupByOutputType = {
    id: string
    name: string | null
    symbol: string | null
    decimals: number | null
    iconUri: string | null
    projectUri: string | null
    network: string
    lastMetadataAttempt: Date | null
    metadataFetched: boolean
    metadataStandard: string | null
    verified: boolean
    displayOrder: number | null
    originalCoinType: string | null
    circulatingSupply: string | null
    createdAt: Date
    marketCapUsd: string | null
    priceChange24hPercent: Decimal | null
    priceUsdCurrent: Decimal | null
    priceAnchor: Decimal | null
    lastPriceUpdate: Date | null
    totalSupply: string | null
    updatedAt: Date
    volume24hUsd: string | null
    _count: TokensCountAggregateOutputType | null
    _avg: TokensAvgAggregateOutputType | null
    _sum: TokensSumAggregateOutputType | null
    _min: TokensMinAggregateOutputType | null
    _max: TokensMaxAggregateOutputType | null
  }

  type GetTokensGroupByPayload<T extends tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokensGroupByOutputType[P]>
            : GetScalarType<T[P], TokensGroupByOutputType[P]>
        }
      >
    >


  export type tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    iconUri?: boolean
    projectUri?: boolean
    network?: boolean
    lastMetadataAttempt?: boolean
    metadataFetched?: boolean
    metadataStandard?: boolean
    verified?: boolean
    displayOrder?: boolean
    originalCoinType?: boolean
    circulatingSupply?: boolean
    createdAt?: boolean
    marketCapUsd?: boolean
    priceChange24hPercent?: boolean
    priceUsdCurrent?: boolean
    priceAnchor?: boolean
    lastPriceUpdate?: boolean
    totalSupply?: boolean
    updatedAt?: boolean
    volume24hUsd?: boolean
    ammpairsAsToken0?: boolean | tokens$ammpairsAsToken0Args<ExtArgs>
    ammpairsAsToken1?: boolean | tokens$ammpairsAsToken1Args<ExtArgs>
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | tokens$staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensArgs<ExtArgs>
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | tokens$staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensArgs<ExtArgs>
    _count?: boolean | TokensCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    iconUri?: boolean
    projectUri?: boolean
    network?: boolean
    lastMetadataAttempt?: boolean
    metadataFetched?: boolean
    metadataStandard?: boolean
    verified?: boolean
    displayOrder?: boolean
    originalCoinType?: boolean
    circulatingSupply?: boolean
    createdAt?: boolean
    marketCapUsd?: boolean
    priceChange24hPercent?: boolean
    priceUsdCurrent?: boolean
    priceAnchor?: boolean
    lastPriceUpdate?: boolean
    totalSupply?: boolean
    updatedAt?: boolean
    volume24hUsd?: boolean
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    iconUri?: boolean
    projectUri?: boolean
    network?: boolean
    lastMetadataAttempt?: boolean
    metadataFetched?: boolean
    metadataStandard?: boolean
    verified?: boolean
    displayOrder?: boolean
    originalCoinType?: boolean
    circulatingSupply?: boolean
    createdAt?: boolean
    marketCapUsd?: boolean
    priceChange24hPercent?: boolean
    priceUsdCurrent?: boolean
    priceAnchor?: boolean
    lastPriceUpdate?: boolean
    totalSupply?: boolean
    updatedAt?: boolean
    volume24hUsd?: boolean
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    iconUri?: boolean
    projectUri?: boolean
    network?: boolean
    lastMetadataAttempt?: boolean
    metadataFetched?: boolean
    metadataStandard?: boolean
    verified?: boolean
    displayOrder?: boolean
    originalCoinType?: boolean
    circulatingSupply?: boolean
    createdAt?: boolean
    marketCapUsd?: boolean
    priceChange24hPercent?: boolean
    priceUsdCurrent?: boolean
    priceAnchor?: boolean
    lastPriceUpdate?: boolean
    totalSupply?: boolean
    updatedAt?: boolean
    volume24hUsd?: boolean
  }

  export type tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "decimals" | "iconUri" | "projectUri" | "network" | "lastMetadataAttempt" | "metadataFetched" | "metadataStandard" | "verified" | "displayOrder" | "originalCoinType" | "circulatingSupply" | "createdAt" | "marketCapUsd" | "priceChange24hPercent" | "priceUsdCurrent" | "priceAnchor" | "lastPriceUpdate" | "totalSupply" | "updatedAt" | "volume24hUsd", ExtArgs["result"]["tokens"]>
  export type tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ammpairsAsToken0?: boolean | tokens$ammpairsAsToken0Args<ExtArgs>
    ammpairsAsToken1?: boolean | tokens$ammpairsAsToken1Args<ExtArgs>
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: boolean | tokens$staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensArgs<ExtArgs>
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: boolean | tokens$staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensArgs<ExtArgs>
    _count?: boolean | TokensCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tokens"
    objects: {
      ammpairsAsToken0: Prisma.$AmmpairPayload<ExtArgs>[]
      ammpairsAsToken1: Prisma.$AmmpairPayload<ExtArgs>[]
      staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens: Prisma.$staking_poolsPayload<ExtArgs>[]
      staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens: Prisma.$staking_poolsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      symbol: string | null
      decimals: number | null
      iconUri: string | null
      projectUri: string | null
      network: string
      lastMetadataAttempt: Date | null
      metadataFetched: boolean
      metadataStandard: string | null
      verified: boolean
      displayOrder: number | null
      originalCoinType: string | null
      circulatingSupply: string | null
      createdAt: Date
      marketCapUsd: string | null
      priceChange24hPercent: Prisma.Decimal | null
      priceUsdCurrent: Prisma.Decimal | null
      priceAnchor: Prisma.Decimal | null
      lastPriceUpdate: Date | null
      totalSupply: string | null
      updatedAt: Date
      volume24hUsd: string | null
    }, ExtArgs["result"]["tokens"]>
    composites: {}
  }

  type tokensGetPayload<S extends boolean | null | undefined | tokensDefaultArgs> = $Result.GetResult<Prisma.$tokensPayload, S>

  type tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokensCountAggregateInputType | true
    }

  export interface tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tokens'], meta: { name: 'tokens' } }
    /**
     * Find zero or one Tokens that matches the filter.
     * @param {tokensFindUniqueArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tokensFindUniqueArgs>(args: SelectSubset<T, tokensFindUniqueArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tokensFindUniqueOrThrowArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindFirstArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tokensFindFirstArgs>(args?: SelectSubset<T, tokensFindFirstArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindFirstOrThrowArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.tokens.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokensWithIdOnly = await prisma.tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tokensFindManyArgs>(args?: SelectSubset<T, tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tokens.
     * @param {tokensCreateArgs} args - Arguments to create a Tokens.
     * @example
     * // Create one Tokens
     * const Tokens = await prisma.tokens.create({
     *   data: {
     *     // ... data to create a Tokens
     *   }
     * })
     * 
     */
    create<T extends tokensCreateArgs>(args: SelectSubset<T, tokensCreateArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {tokensCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const tokens = await prisma.tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tokensCreateManyArgs>(args?: SelectSubset<T, tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {tokensCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const tokens = await prisma.tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokensWithIdOnly = await prisma.tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tokens.
     * @param {tokensDeleteArgs} args - Arguments to delete one Tokens.
     * @example
     * // Delete one Tokens
     * const Tokens = await prisma.tokens.delete({
     *   where: {
     *     // ... filter to delete one Tokens
     *   }
     * })
     * 
     */
    delete<T extends tokensDeleteArgs>(args: SelectSubset<T, tokensDeleteArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tokens.
     * @param {tokensUpdateArgs} args - Arguments to update one Tokens.
     * @example
     * // Update one Tokens
     * const tokens = await prisma.tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tokensUpdateArgs>(args: SelectSubset<T, tokensUpdateArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {tokensDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tokensDeleteManyArgs>(args?: SelectSubset<T, tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const tokens = await prisma.tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tokensUpdateManyArgs>(args: SelectSubset<T, tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {tokensUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const tokens = await prisma.tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokensWithIdOnly = await prisma.tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tokens.
     * @param {tokensUpsertArgs} args - Arguments to update or create a Tokens.
     * @example
     * // Update or create a Tokens
     * const tokens = await prisma.tokens.upsert({
     *   create: {
     *     // ... data to create a Tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tokens we want to update
     *   }
     * })
     */
    upsert<T extends tokensUpsertArgs>(args: SelectSubset<T, tokensUpsertArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.tokens.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends tokensCountArgs>(
      args?: Subset<T, tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokensAggregateArgs>(args: Subset<T, TokensAggregateArgs>): Prisma.PrismaPromise<GetTokensAggregateType<T>>

    /**
     * Group by Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tokensGroupByArgs['orderBy'] }
        : { orderBy?: tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tokens model
   */
  readonly fields: tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ammpairsAsToken0<T extends tokens$ammpairsAsToken0Args<ExtArgs> = {}>(args?: Subset<T, tokens$ammpairsAsToken0Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ammpairsAsToken1<T extends tokens$ammpairsAsToken1Args<ExtArgs> = {}>(args?: Subset<T, tokens$ammpairsAsToken1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmpairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens<T extends tokens$staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensArgs<ExtArgs> = {}>(args?: Subset<T, tokens$staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens<T extends tokens$staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensArgs<ExtArgs> = {}>(args?: Subset<T, tokens$staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tokens model
   */
  interface tokensFieldRefs {
    readonly id: FieldRef<"tokens", 'String'>
    readonly name: FieldRef<"tokens", 'String'>
    readonly symbol: FieldRef<"tokens", 'String'>
    readonly decimals: FieldRef<"tokens", 'Int'>
    readonly iconUri: FieldRef<"tokens", 'String'>
    readonly projectUri: FieldRef<"tokens", 'String'>
    readonly network: FieldRef<"tokens", 'String'>
    readonly lastMetadataAttempt: FieldRef<"tokens", 'DateTime'>
    readonly metadataFetched: FieldRef<"tokens", 'Boolean'>
    readonly metadataStandard: FieldRef<"tokens", 'String'>
    readonly verified: FieldRef<"tokens", 'Boolean'>
    readonly displayOrder: FieldRef<"tokens", 'Int'>
    readonly originalCoinType: FieldRef<"tokens", 'String'>
    readonly circulatingSupply: FieldRef<"tokens", 'String'>
    readonly createdAt: FieldRef<"tokens", 'DateTime'>
    readonly marketCapUsd: FieldRef<"tokens", 'String'>
    readonly priceChange24hPercent: FieldRef<"tokens", 'Decimal'>
    readonly priceUsdCurrent: FieldRef<"tokens", 'Decimal'>
    readonly priceAnchor: FieldRef<"tokens", 'Decimal'>
    readonly lastPriceUpdate: FieldRef<"tokens", 'DateTime'>
    readonly totalSupply: FieldRef<"tokens", 'String'>
    readonly updatedAt: FieldRef<"tokens", 'DateTime'>
    readonly volume24hUsd: FieldRef<"tokens", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tokens findUnique
   */
  export type tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens findUniqueOrThrow
   */
  export type tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens findFirst
   */
  export type tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens.
     */
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens findFirstOrThrow
   */
  export type tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens.
     */
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens findMany
   */
  export type tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens create
   */
  export type tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a tokens.
     */
    data: XOR<tokensCreateInput, tokensUncheckedCreateInput>
  }

  /**
   * tokens createMany
   */
  export type tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tokens.
     */
    data: tokensCreateManyInput | tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens createManyAndReturn
   */
  export type tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The data used to create many tokens.
     */
    data: tokensCreateManyInput | tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens update
   */
  export type tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a tokens.
     */
    data: XOR<tokensUpdateInput, tokensUncheckedUpdateInput>
    /**
     * Choose, which tokens to update.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens updateMany
   */
  export type tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tokens.
     */
    data: XOR<tokensUpdateManyMutationInput, tokensUncheckedUpdateManyInput>
    /**
     * Filter which tokens to update
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to update.
     */
    limit?: number
  }

  /**
   * tokens updateManyAndReturn
   */
  export type tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The data used to update tokens.
     */
    data: XOR<tokensUpdateManyMutationInput, tokensUncheckedUpdateManyInput>
    /**
     * Filter which tokens to update
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to update.
     */
    limit?: number
  }

  /**
   * tokens upsert
   */
  export type tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the tokens to update in case it exists.
     */
    where: tokensWhereUniqueInput
    /**
     * In case the tokens found by the `where` argument doesn't exist, create a new tokens with this data.
     */
    create: XOR<tokensCreateInput, tokensUncheckedCreateInput>
    /**
     * In case the tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokensUpdateInput, tokensUncheckedUpdateInput>
  }

  /**
   * tokens delete
   */
  export type tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter which tokens to delete.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens deleteMany
   */
  export type tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens to delete
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to delete.
     */
    limit?: number
  }

  /**
   * tokens.ammpairsAsToken0
   */
  export type tokens$ammpairsAsToken0Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    where?: AmmpairWhereInput
    orderBy?: AmmpairOrderByWithRelationInput | AmmpairOrderByWithRelationInput[]
    cursor?: AmmpairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmmpairScalarFieldEnum | AmmpairScalarFieldEnum[]
  }

  /**
   * tokens.ammpairsAsToken1
   */
  export type tokens$ammpairsAsToken1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammpair
     */
    select?: AmmpairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammpair
     */
    omit?: AmmpairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmpairInclude<ExtArgs> | null
    where?: AmmpairWhereInput
    orderBy?: AmmpairOrderByWithRelationInput | AmmpairOrderByWithRelationInput[]
    cursor?: AmmpairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmmpairScalarFieldEnum | AmmpairScalarFieldEnum[]
  }

  /**
   * tokens.staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens
   */
  export type tokens$staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    where?: staking_poolsWhereInput
    orderBy?: staking_poolsOrderByWithRelationInput | staking_poolsOrderByWithRelationInput[]
    cursor?: staking_poolsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Staking_poolsScalarFieldEnum | Staking_poolsScalarFieldEnum[]
  }

  /**
   * tokens.staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens
   */
  export type tokens$staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    where?: staking_poolsWhereInput
    orderBy?: staking_poolsOrderByWithRelationInput | staking_poolsOrderByWithRelationInput[]
    cursor?: staking_poolsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Staking_poolsScalarFieldEnum | Staking_poolsScalarFieldEnum[]
  }

  /**
   * tokens without action
   */
  export type tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
  }


  /**
   * Model trust_pools
   */

  export type AggregateTrust_pools = {
    _count: Trust_poolsCountAggregateOutputType | null
    _avg: Trust_poolsAvgAggregateOutputType | null
    _sum: Trust_poolsSumAggregateOutputType | null
    _min: Trust_poolsMinAggregateOutputType | null
    _max: Trust_poolsMaxAggregateOutputType | null
  }

  export type Trust_poolsAvgAggregateOutputType = {
    id: number | null
    poolDbId: number | null
    stakerCount: number | null
  }

  export type Trust_poolsSumAggregateOutputType = {
    id: number | null
    poolDbId: number | null
    stakerCount: number | null
  }

  export type Trust_poolsMinAggregateOutputType = {
    id: number | null
    network: string | null
    poolDbId: number | null
    tokenAddress: string | null
    isActive: boolean | null
    totalStakedAmount: string | null
    stakerCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trust_poolsMaxAggregateOutputType = {
    id: number | null
    network: string | null
    poolDbId: number | null
    tokenAddress: string | null
    isActive: boolean | null
    totalStakedAmount: string | null
    stakerCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trust_poolsCountAggregateOutputType = {
    id: number
    network: number
    poolDbId: number
    tokenAddress: number
    isActive: number
    totalStakedAmount: number
    stakerCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Trust_poolsAvgAggregateInputType = {
    id?: true
    poolDbId?: true
    stakerCount?: true
  }

  export type Trust_poolsSumAggregateInputType = {
    id?: true
    poolDbId?: true
    stakerCount?: true
  }

  export type Trust_poolsMinAggregateInputType = {
    id?: true
    network?: true
    poolDbId?: true
    tokenAddress?: true
    isActive?: true
    totalStakedAmount?: true
    stakerCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trust_poolsMaxAggregateInputType = {
    id?: true
    network?: true
    poolDbId?: true
    tokenAddress?: true
    isActive?: true
    totalStakedAmount?: true
    stakerCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trust_poolsCountAggregateInputType = {
    id?: true
    network?: true
    poolDbId?: true
    tokenAddress?: true
    isActive?: true
    totalStakedAmount?: true
    stakerCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Trust_poolsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trust_pools to aggregate.
     */
    where?: trust_poolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trust_pools to fetch.
     */
    orderBy?: trust_poolsOrderByWithRelationInput | trust_poolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trust_poolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trust_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trust_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trust_pools
    **/
    _count?: true | Trust_poolsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Trust_poolsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Trust_poolsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trust_poolsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trust_poolsMaxAggregateInputType
  }

  export type GetTrust_poolsAggregateType<T extends Trust_poolsAggregateArgs> = {
        [P in keyof T & keyof AggregateTrust_pools]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrust_pools[P]>
      : GetScalarType<T[P], AggregateTrust_pools[P]>
  }




  export type trust_poolsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trust_poolsWhereInput
    orderBy?: trust_poolsOrderByWithAggregationInput | trust_poolsOrderByWithAggregationInput[]
    by: Trust_poolsScalarFieldEnum[] | Trust_poolsScalarFieldEnum
    having?: trust_poolsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trust_poolsCountAggregateInputType | true
    _avg?: Trust_poolsAvgAggregateInputType
    _sum?: Trust_poolsSumAggregateInputType
    _min?: Trust_poolsMinAggregateInputType
    _max?: Trust_poolsMaxAggregateInputType
  }

  export type Trust_poolsGroupByOutputType = {
    id: number
    network: string
    poolDbId: number
    tokenAddress: string
    isActive: boolean
    totalStakedAmount: string
    stakerCount: number
    createdAt: Date
    updatedAt: Date
    _count: Trust_poolsCountAggregateOutputType | null
    _avg: Trust_poolsAvgAggregateOutputType | null
    _sum: Trust_poolsSumAggregateOutputType | null
    _min: Trust_poolsMinAggregateOutputType | null
    _max: Trust_poolsMaxAggregateOutputType | null
  }

  type GetTrust_poolsGroupByPayload<T extends trust_poolsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trust_poolsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trust_poolsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trust_poolsGroupByOutputType[P]>
            : GetScalarType<T[P], Trust_poolsGroupByOutputType[P]>
        }
      >
    >


  export type trust_poolsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    poolDbId?: boolean
    tokenAddress?: boolean
    isActive?: boolean
    totalStakedAmount?: boolean
    stakerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trust_pools"]>

  export type trust_poolsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    poolDbId?: boolean
    tokenAddress?: boolean
    isActive?: boolean
    totalStakedAmount?: boolean
    stakerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trust_pools"]>

  export type trust_poolsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    network?: boolean
    poolDbId?: boolean
    tokenAddress?: boolean
    isActive?: boolean
    totalStakedAmount?: boolean
    stakerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trust_pools"]>

  export type trust_poolsSelectScalar = {
    id?: boolean
    network?: boolean
    poolDbId?: boolean
    tokenAddress?: boolean
    isActive?: boolean
    totalStakedAmount?: boolean
    stakerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type trust_poolsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "network" | "poolDbId" | "tokenAddress" | "isActive" | "totalStakedAmount" | "stakerCount" | "createdAt" | "updatedAt", ExtArgs["result"]["trust_pools"]>
  export type trust_poolsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }
  export type trust_poolsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }
  export type trust_poolsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PoolsDB?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }

  export type $trust_poolsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trust_pools"
    objects: {
      PoolsDB: Prisma.$PoolsDBPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      network: string
      poolDbId: number
      tokenAddress: string
      isActive: boolean
      totalStakedAmount: string
      stakerCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trust_pools"]>
    composites: {}
  }

  type trust_poolsGetPayload<S extends boolean | null | undefined | trust_poolsDefaultArgs> = $Result.GetResult<Prisma.$trust_poolsPayload, S>

  type trust_poolsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trust_poolsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trust_poolsCountAggregateInputType | true
    }

  export interface trust_poolsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trust_pools'], meta: { name: 'trust_pools' } }
    /**
     * Find zero or one Trust_pools that matches the filter.
     * @param {trust_poolsFindUniqueArgs} args - Arguments to find a Trust_pools
     * @example
     * // Get one Trust_pools
     * const trust_pools = await prisma.trust_pools.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trust_poolsFindUniqueArgs>(args: SelectSubset<T, trust_poolsFindUniqueArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trust_pools that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trust_poolsFindUniqueOrThrowArgs} args - Arguments to find a Trust_pools
     * @example
     * // Get one Trust_pools
     * const trust_pools = await prisma.trust_pools.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trust_poolsFindUniqueOrThrowArgs>(args: SelectSubset<T, trust_poolsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trust_pools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trust_poolsFindFirstArgs} args - Arguments to find a Trust_pools
     * @example
     * // Get one Trust_pools
     * const trust_pools = await prisma.trust_pools.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trust_poolsFindFirstArgs>(args?: SelectSubset<T, trust_poolsFindFirstArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trust_pools that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trust_poolsFindFirstOrThrowArgs} args - Arguments to find a Trust_pools
     * @example
     * // Get one Trust_pools
     * const trust_pools = await prisma.trust_pools.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trust_poolsFindFirstOrThrowArgs>(args?: SelectSubset<T, trust_poolsFindFirstOrThrowArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trust_pools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trust_poolsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trust_pools
     * const trust_pools = await prisma.trust_pools.findMany()
     * 
     * // Get first 10 Trust_pools
     * const trust_pools = await prisma.trust_pools.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trust_poolsWithIdOnly = await prisma.trust_pools.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trust_poolsFindManyArgs>(args?: SelectSubset<T, trust_poolsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trust_pools.
     * @param {trust_poolsCreateArgs} args - Arguments to create a Trust_pools.
     * @example
     * // Create one Trust_pools
     * const Trust_pools = await prisma.trust_pools.create({
     *   data: {
     *     // ... data to create a Trust_pools
     *   }
     * })
     * 
     */
    create<T extends trust_poolsCreateArgs>(args: SelectSubset<T, trust_poolsCreateArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trust_pools.
     * @param {trust_poolsCreateManyArgs} args - Arguments to create many Trust_pools.
     * @example
     * // Create many Trust_pools
     * const trust_pools = await prisma.trust_pools.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trust_poolsCreateManyArgs>(args?: SelectSubset<T, trust_poolsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trust_pools and returns the data saved in the database.
     * @param {trust_poolsCreateManyAndReturnArgs} args - Arguments to create many Trust_pools.
     * @example
     * // Create many Trust_pools
     * const trust_pools = await prisma.trust_pools.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trust_pools and only return the `id`
     * const trust_poolsWithIdOnly = await prisma.trust_pools.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends trust_poolsCreateManyAndReturnArgs>(args?: SelectSubset<T, trust_poolsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trust_pools.
     * @param {trust_poolsDeleteArgs} args - Arguments to delete one Trust_pools.
     * @example
     * // Delete one Trust_pools
     * const Trust_pools = await prisma.trust_pools.delete({
     *   where: {
     *     // ... filter to delete one Trust_pools
     *   }
     * })
     * 
     */
    delete<T extends trust_poolsDeleteArgs>(args: SelectSubset<T, trust_poolsDeleteArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trust_pools.
     * @param {trust_poolsUpdateArgs} args - Arguments to update one Trust_pools.
     * @example
     * // Update one Trust_pools
     * const trust_pools = await prisma.trust_pools.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trust_poolsUpdateArgs>(args: SelectSubset<T, trust_poolsUpdateArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trust_pools.
     * @param {trust_poolsDeleteManyArgs} args - Arguments to filter Trust_pools to delete.
     * @example
     * // Delete a few Trust_pools
     * const { count } = await prisma.trust_pools.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trust_poolsDeleteManyArgs>(args?: SelectSubset<T, trust_poolsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trust_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trust_poolsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trust_pools
     * const trust_pools = await prisma.trust_pools.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trust_poolsUpdateManyArgs>(args: SelectSubset<T, trust_poolsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trust_pools and returns the data updated in the database.
     * @param {trust_poolsUpdateManyAndReturnArgs} args - Arguments to update many Trust_pools.
     * @example
     * // Update many Trust_pools
     * const trust_pools = await prisma.trust_pools.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trust_pools and only return the `id`
     * const trust_poolsWithIdOnly = await prisma.trust_pools.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends trust_poolsUpdateManyAndReturnArgs>(args: SelectSubset<T, trust_poolsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trust_pools.
     * @param {trust_poolsUpsertArgs} args - Arguments to update or create a Trust_pools.
     * @example
     * // Update or create a Trust_pools
     * const trust_pools = await prisma.trust_pools.upsert({
     *   create: {
     *     // ... data to create a Trust_pools
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trust_pools we want to update
     *   }
     * })
     */
    upsert<T extends trust_poolsUpsertArgs>(args: SelectSubset<T, trust_poolsUpsertArgs<ExtArgs>>): Prisma__trust_poolsClient<$Result.GetResult<Prisma.$trust_poolsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trust_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trust_poolsCountArgs} args - Arguments to filter Trust_pools to count.
     * @example
     * // Count the number of Trust_pools
     * const count = await prisma.trust_pools.count({
     *   where: {
     *     // ... the filter for the Trust_pools we want to count
     *   }
     * })
    **/
    count<T extends trust_poolsCountArgs>(
      args?: Subset<T, trust_poolsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trust_poolsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trust_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trust_poolsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trust_poolsAggregateArgs>(args: Subset<T, Trust_poolsAggregateArgs>): Prisma.PrismaPromise<GetTrust_poolsAggregateType<T>>

    /**
     * Group by Trust_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trust_poolsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trust_poolsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trust_poolsGroupByArgs['orderBy'] }
        : { orderBy?: trust_poolsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trust_poolsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrust_poolsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trust_pools model
   */
  readonly fields: trust_poolsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trust_pools.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trust_poolsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PoolsDB<T extends PoolsDBDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoolsDBDefaultArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trust_pools model
   */
  interface trust_poolsFieldRefs {
    readonly id: FieldRef<"trust_pools", 'Int'>
    readonly network: FieldRef<"trust_pools", 'String'>
    readonly poolDbId: FieldRef<"trust_pools", 'Int'>
    readonly tokenAddress: FieldRef<"trust_pools", 'String'>
    readonly isActive: FieldRef<"trust_pools", 'Boolean'>
    readonly totalStakedAmount: FieldRef<"trust_pools", 'String'>
    readonly stakerCount: FieldRef<"trust_pools", 'Int'>
    readonly createdAt: FieldRef<"trust_pools", 'DateTime'>
    readonly updatedAt: FieldRef<"trust_pools", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trust_pools findUnique
   */
  export type trust_poolsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * Filter, which trust_pools to fetch.
     */
    where: trust_poolsWhereUniqueInput
  }

  /**
   * trust_pools findUniqueOrThrow
   */
  export type trust_poolsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * Filter, which trust_pools to fetch.
     */
    where: trust_poolsWhereUniqueInput
  }

  /**
   * trust_pools findFirst
   */
  export type trust_poolsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * Filter, which trust_pools to fetch.
     */
    where?: trust_poolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trust_pools to fetch.
     */
    orderBy?: trust_poolsOrderByWithRelationInput | trust_poolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trust_pools.
     */
    cursor?: trust_poolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trust_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trust_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trust_pools.
     */
    distinct?: Trust_poolsScalarFieldEnum | Trust_poolsScalarFieldEnum[]
  }

  /**
   * trust_pools findFirstOrThrow
   */
  export type trust_poolsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * Filter, which trust_pools to fetch.
     */
    where?: trust_poolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trust_pools to fetch.
     */
    orderBy?: trust_poolsOrderByWithRelationInput | trust_poolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trust_pools.
     */
    cursor?: trust_poolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trust_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trust_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trust_pools.
     */
    distinct?: Trust_poolsScalarFieldEnum | Trust_poolsScalarFieldEnum[]
  }

  /**
   * trust_pools findMany
   */
  export type trust_poolsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * Filter, which trust_pools to fetch.
     */
    where?: trust_poolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trust_pools to fetch.
     */
    orderBy?: trust_poolsOrderByWithRelationInput | trust_poolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trust_pools.
     */
    cursor?: trust_poolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trust_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trust_pools.
     */
    skip?: number
    distinct?: Trust_poolsScalarFieldEnum | Trust_poolsScalarFieldEnum[]
  }

  /**
   * trust_pools create
   */
  export type trust_poolsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * The data needed to create a trust_pools.
     */
    data: XOR<trust_poolsCreateInput, trust_poolsUncheckedCreateInput>
  }

  /**
   * trust_pools createMany
   */
  export type trust_poolsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trust_pools.
     */
    data: trust_poolsCreateManyInput | trust_poolsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trust_pools createManyAndReturn
   */
  export type trust_poolsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * The data used to create many trust_pools.
     */
    data: trust_poolsCreateManyInput | trust_poolsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * trust_pools update
   */
  export type trust_poolsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * The data needed to update a trust_pools.
     */
    data: XOR<trust_poolsUpdateInput, trust_poolsUncheckedUpdateInput>
    /**
     * Choose, which trust_pools to update.
     */
    where: trust_poolsWhereUniqueInput
  }

  /**
   * trust_pools updateMany
   */
  export type trust_poolsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trust_pools.
     */
    data: XOR<trust_poolsUpdateManyMutationInput, trust_poolsUncheckedUpdateManyInput>
    /**
     * Filter which trust_pools to update
     */
    where?: trust_poolsWhereInput
    /**
     * Limit how many trust_pools to update.
     */
    limit?: number
  }

  /**
   * trust_pools updateManyAndReturn
   */
  export type trust_poolsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * The data used to update trust_pools.
     */
    data: XOR<trust_poolsUpdateManyMutationInput, trust_poolsUncheckedUpdateManyInput>
    /**
     * Filter which trust_pools to update
     */
    where?: trust_poolsWhereInput
    /**
     * Limit how many trust_pools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * trust_pools upsert
   */
  export type trust_poolsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * The filter to search for the trust_pools to update in case it exists.
     */
    where: trust_poolsWhereUniqueInput
    /**
     * In case the trust_pools found by the `where` argument doesn't exist, create a new trust_pools with this data.
     */
    create: XOR<trust_poolsCreateInput, trust_poolsUncheckedCreateInput>
    /**
     * In case the trust_pools was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trust_poolsUpdateInput, trust_poolsUncheckedUpdateInput>
  }

  /**
   * trust_pools delete
   */
  export type trust_poolsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
    /**
     * Filter which trust_pools to delete.
     */
    where: trust_poolsWhereUniqueInput
  }

  /**
   * trust_pools deleteMany
   */
  export type trust_poolsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trust_pools to delete
     */
    where?: trust_poolsWhereInput
    /**
     * Limit how many trust_pools to delete.
     */
    limit?: number
  }

  /**
   * trust_pools without action
   */
  export type trust_poolsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trust_pools
     */
    select?: trust_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trust_pools
     */
    omit?: trust_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trust_poolsInclude<ExtArgs> | null
  }


  /**
   * Model user_stakes
   */

  export type AggregateUser_stakes = {
    _count: User_stakesCountAggregateOutputType | null
    _avg: User_stakesAvgAggregateOutputType | null
    _sum: User_stakesSumAggregateOutputType | null
    _min: User_stakesMinAggregateOutputType | null
    _max: User_stakesMaxAggregateOutputType | null
  }

  export type User_stakesAvgAggregateOutputType = {
    id: number | null
    poolId: number | null
    lastClaimTimestamp: number | null
  }

  export type User_stakesSumAggregateOutputType = {
    id: number | null
    poolId: number | null
    lastClaimTimestamp: bigint | null
  }

  export type User_stakesMinAggregateOutputType = {
    id: number | null
    poolId: number | null
    userNetwork: string | null
    userAddress: string | null
    stakedAmount: string | null
    rewardDebt: string | null
    lastClaimTimestamp: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_stakesMaxAggregateOutputType = {
    id: number | null
    poolId: number | null
    userNetwork: string | null
    userAddress: string | null
    stakedAmount: string | null
    rewardDebt: string | null
    lastClaimTimestamp: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_stakesCountAggregateOutputType = {
    id: number
    poolId: number
    userNetwork: number
    userAddress: number
    stakedAmount: number
    rewardDebt: number
    lastClaimTimestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_stakesAvgAggregateInputType = {
    id?: true
    poolId?: true
    lastClaimTimestamp?: true
  }

  export type User_stakesSumAggregateInputType = {
    id?: true
    poolId?: true
    lastClaimTimestamp?: true
  }

  export type User_stakesMinAggregateInputType = {
    id?: true
    poolId?: true
    userNetwork?: true
    userAddress?: true
    stakedAmount?: true
    rewardDebt?: true
    lastClaimTimestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_stakesMaxAggregateInputType = {
    id?: true
    poolId?: true
    userNetwork?: true
    userAddress?: true
    stakedAmount?: true
    rewardDebt?: true
    lastClaimTimestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_stakesCountAggregateInputType = {
    id?: true
    poolId?: true
    userNetwork?: true
    userAddress?: true
    stakedAmount?: true
    rewardDebt?: true
    lastClaimTimestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_stakesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_stakes to aggregate.
     */
    where?: user_stakesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_stakes to fetch.
     */
    orderBy?: user_stakesOrderByWithRelationInput | user_stakesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_stakesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_stakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_stakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_stakes
    **/
    _count?: true | User_stakesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_stakesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_stakesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_stakesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_stakesMaxAggregateInputType
  }

  export type GetUser_stakesAggregateType<T extends User_stakesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_stakes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_stakes[P]>
      : GetScalarType<T[P], AggregateUser_stakes[P]>
  }




  export type user_stakesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_stakesWhereInput
    orderBy?: user_stakesOrderByWithAggregationInput | user_stakesOrderByWithAggregationInput[]
    by: User_stakesScalarFieldEnum[] | User_stakesScalarFieldEnum
    having?: user_stakesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_stakesCountAggregateInputType | true
    _avg?: User_stakesAvgAggregateInputType
    _sum?: User_stakesSumAggregateInputType
    _min?: User_stakesMinAggregateInputType
    _max?: User_stakesMaxAggregateInputType
  }

  export type User_stakesGroupByOutputType = {
    id: number
    poolId: number
    userNetwork: string
    userAddress: string
    stakedAmount: string
    rewardDebt: string
    lastClaimTimestamp: bigint | null
    createdAt: Date
    updatedAt: Date
    _count: User_stakesCountAggregateOutputType | null
    _avg: User_stakesAvgAggregateOutputType | null
    _sum: User_stakesSumAggregateOutputType | null
    _min: User_stakesMinAggregateOutputType | null
    _max: User_stakesMaxAggregateOutputType | null
  }

  type GetUser_stakesGroupByPayload<T extends user_stakesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_stakesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_stakesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_stakesGroupByOutputType[P]>
            : GetScalarType<T[P], User_stakesGroupByOutputType[P]>
        }
      >
    >


  export type user_stakesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolId?: boolean
    userNetwork?: boolean
    userAddress?: boolean
    stakedAmount?: boolean
    rewardDebt?: boolean
    lastClaimTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staking_pools?: boolean | staking_poolsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_stakes"]>

  export type user_stakesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolId?: boolean
    userNetwork?: boolean
    userAddress?: boolean
    stakedAmount?: boolean
    rewardDebt?: boolean
    lastClaimTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staking_pools?: boolean | staking_poolsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_stakes"]>

  export type user_stakesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolId?: boolean
    userNetwork?: boolean
    userAddress?: boolean
    stakedAmount?: boolean
    rewardDebt?: boolean
    lastClaimTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staking_pools?: boolean | staking_poolsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_stakes"]>

  export type user_stakesSelectScalar = {
    id?: boolean
    poolId?: boolean
    userNetwork?: boolean
    userAddress?: boolean
    stakedAmount?: boolean
    rewardDebt?: boolean
    lastClaimTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_stakesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poolId" | "userNetwork" | "userAddress" | "stakedAmount" | "rewardDebt" | "lastClaimTimestamp" | "createdAt" | "updatedAt", ExtArgs["result"]["user_stakes"]>
  export type user_stakesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staking_pools?: boolean | staking_poolsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_stakesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staking_pools?: boolean | staking_poolsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_stakesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staking_pools?: boolean | staking_poolsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_stakesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_stakes"
    objects: {
      staking_pools: Prisma.$staking_poolsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      poolId: number
      userNetwork: string
      userAddress: string
      stakedAmount: string
      rewardDebt: string
      lastClaimTimestamp: bigint | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_stakes"]>
    composites: {}
  }

  type user_stakesGetPayload<S extends boolean | null | undefined | user_stakesDefaultArgs> = $Result.GetResult<Prisma.$user_stakesPayload, S>

  type user_stakesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_stakesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_stakesCountAggregateInputType | true
    }

  export interface user_stakesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_stakes'], meta: { name: 'user_stakes' } }
    /**
     * Find zero or one User_stakes that matches the filter.
     * @param {user_stakesFindUniqueArgs} args - Arguments to find a User_stakes
     * @example
     * // Get one User_stakes
     * const user_stakes = await prisma.user_stakes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_stakesFindUniqueArgs>(args: SelectSubset<T, user_stakesFindUniqueArgs<ExtArgs>>): Prisma__user_stakesClient<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_stakes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_stakesFindUniqueOrThrowArgs} args - Arguments to find a User_stakes
     * @example
     * // Get one User_stakes
     * const user_stakes = await prisma.user_stakes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_stakesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_stakesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_stakesClient<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_stakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_stakesFindFirstArgs} args - Arguments to find a User_stakes
     * @example
     * // Get one User_stakes
     * const user_stakes = await prisma.user_stakes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_stakesFindFirstArgs>(args?: SelectSubset<T, user_stakesFindFirstArgs<ExtArgs>>): Prisma__user_stakesClient<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_stakes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_stakesFindFirstOrThrowArgs} args - Arguments to find a User_stakes
     * @example
     * // Get one User_stakes
     * const user_stakes = await prisma.user_stakes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_stakesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_stakesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_stakesClient<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_stakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_stakesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_stakes
     * const user_stakes = await prisma.user_stakes.findMany()
     * 
     * // Get first 10 User_stakes
     * const user_stakes = await prisma.user_stakes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_stakesWithIdOnly = await prisma.user_stakes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_stakesFindManyArgs>(args?: SelectSubset<T, user_stakesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_stakes.
     * @param {user_stakesCreateArgs} args - Arguments to create a User_stakes.
     * @example
     * // Create one User_stakes
     * const User_stakes = await prisma.user_stakes.create({
     *   data: {
     *     // ... data to create a User_stakes
     *   }
     * })
     * 
     */
    create<T extends user_stakesCreateArgs>(args: SelectSubset<T, user_stakesCreateArgs<ExtArgs>>): Prisma__user_stakesClient<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_stakes.
     * @param {user_stakesCreateManyArgs} args - Arguments to create many User_stakes.
     * @example
     * // Create many User_stakes
     * const user_stakes = await prisma.user_stakes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_stakesCreateManyArgs>(args?: SelectSubset<T, user_stakesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_stakes and returns the data saved in the database.
     * @param {user_stakesCreateManyAndReturnArgs} args - Arguments to create many User_stakes.
     * @example
     * // Create many User_stakes
     * const user_stakes = await prisma.user_stakes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_stakes and only return the `id`
     * const user_stakesWithIdOnly = await prisma.user_stakes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_stakesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_stakesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_stakes.
     * @param {user_stakesDeleteArgs} args - Arguments to delete one User_stakes.
     * @example
     * // Delete one User_stakes
     * const User_stakes = await prisma.user_stakes.delete({
     *   where: {
     *     // ... filter to delete one User_stakes
     *   }
     * })
     * 
     */
    delete<T extends user_stakesDeleteArgs>(args: SelectSubset<T, user_stakesDeleteArgs<ExtArgs>>): Prisma__user_stakesClient<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_stakes.
     * @param {user_stakesUpdateArgs} args - Arguments to update one User_stakes.
     * @example
     * // Update one User_stakes
     * const user_stakes = await prisma.user_stakes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_stakesUpdateArgs>(args: SelectSubset<T, user_stakesUpdateArgs<ExtArgs>>): Prisma__user_stakesClient<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_stakes.
     * @param {user_stakesDeleteManyArgs} args - Arguments to filter User_stakes to delete.
     * @example
     * // Delete a few User_stakes
     * const { count } = await prisma.user_stakes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_stakesDeleteManyArgs>(args?: SelectSubset<T, user_stakesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_stakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_stakesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_stakes
     * const user_stakes = await prisma.user_stakes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_stakesUpdateManyArgs>(args: SelectSubset<T, user_stakesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_stakes and returns the data updated in the database.
     * @param {user_stakesUpdateManyAndReturnArgs} args - Arguments to update many User_stakes.
     * @example
     * // Update many User_stakes
     * const user_stakes = await prisma.user_stakes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_stakes and only return the `id`
     * const user_stakesWithIdOnly = await prisma.user_stakes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_stakesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_stakesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_stakes.
     * @param {user_stakesUpsertArgs} args - Arguments to update or create a User_stakes.
     * @example
     * // Update or create a User_stakes
     * const user_stakes = await prisma.user_stakes.upsert({
     *   create: {
     *     // ... data to create a User_stakes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_stakes we want to update
     *   }
     * })
     */
    upsert<T extends user_stakesUpsertArgs>(args: SelectSubset<T, user_stakesUpsertArgs<ExtArgs>>): Prisma__user_stakesClient<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_stakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_stakesCountArgs} args - Arguments to filter User_stakes to count.
     * @example
     * // Count the number of User_stakes
     * const count = await prisma.user_stakes.count({
     *   where: {
     *     // ... the filter for the User_stakes we want to count
     *   }
     * })
    **/
    count<T extends user_stakesCountArgs>(
      args?: Subset<T, user_stakesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_stakesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_stakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_stakesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_stakesAggregateArgs>(args: Subset<T, User_stakesAggregateArgs>): Prisma.PrismaPromise<GetUser_stakesAggregateType<T>>

    /**
     * Group by User_stakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_stakesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_stakesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_stakesGroupByArgs['orderBy'] }
        : { orderBy?: user_stakesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_stakesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_stakesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_stakes model
   */
  readonly fields: user_stakesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_stakes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_stakesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staking_pools<T extends staking_poolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, staking_poolsDefaultArgs<ExtArgs>>): Prisma__staking_poolsClient<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_stakes model
   */
  interface user_stakesFieldRefs {
    readonly id: FieldRef<"user_stakes", 'Int'>
    readonly poolId: FieldRef<"user_stakes", 'Int'>
    readonly userNetwork: FieldRef<"user_stakes", 'String'>
    readonly userAddress: FieldRef<"user_stakes", 'String'>
    readonly stakedAmount: FieldRef<"user_stakes", 'String'>
    readonly rewardDebt: FieldRef<"user_stakes", 'String'>
    readonly lastClaimTimestamp: FieldRef<"user_stakes", 'BigInt'>
    readonly createdAt: FieldRef<"user_stakes", 'DateTime'>
    readonly updatedAt: FieldRef<"user_stakes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_stakes findUnique
   */
  export type user_stakesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * Filter, which user_stakes to fetch.
     */
    where: user_stakesWhereUniqueInput
  }

  /**
   * user_stakes findUniqueOrThrow
   */
  export type user_stakesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * Filter, which user_stakes to fetch.
     */
    where: user_stakesWhereUniqueInput
  }

  /**
   * user_stakes findFirst
   */
  export type user_stakesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * Filter, which user_stakes to fetch.
     */
    where?: user_stakesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_stakes to fetch.
     */
    orderBy?: user_stakesOrderByWithRelationInput | user_stakesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_stakes.
     */
    cursor?: user_stakesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_stakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_stakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_stakes.
     */
    distinct?: User_stakesScalarFieldEnum | User_stakesScalarFieldEnum[]
  }

  /**
   * user_stakes findFirstOrThrow
   */
  export type user_stakesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * Filter, which user_stakes to fetch.
     */
    where?: user_stakesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_stakes to fetch.
     */
    orderBy?: user_stakesOrderByWithRelationInput | user_stakesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_stakes.
     */
    cursor?: user_stakesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_stakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_stakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_stakes.
     */
    distinct?: User_stakesScalarFieldEnum | User_stakesScalarFieldEnum[]
  }

  /**
   * user_stakes findMany
   */
  export type user_stakesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * Filter, which user_stakes to fetch.
     */
    where?: user_stakesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_stakes to fetch.
     */
    orderBy?: user_stakesOrderByWithRelationInput | user_stakesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_stakes.
     */
    cursor?: user_stakesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_stakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_stakes.
     */
    skip?: number
    distinct?: User_stakesScalarFieldEnum | User_stakesScalarFieldEnum[]
  }

  /**
   * user_stakes create
   */
  export type user_stakesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_stakes.
     */
    data: XOR<user_stakesCreateInput, user_stakesUncheckedCreateInput>
  }

  /**
   * user_stakes createMany
   */
  export type user_stakesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_stakes.
     */
    data: user_stakesCreateManyInput | user_stakesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_stakes createManyAndReturn
   */
  export type user_stakesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * The data used to create many user_stakes.
     */
    data: user_stakesCreateManyInput | user_stakesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_stakes update
   */
  export type user_stakesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_stakes.
     */
    data: XOR<user_stakesUpdateInput, user_stakesUncheckedUpdateInput>
    /**
     * Choose, which user_stakes to update.
     */
    where: user_stakesWhereUniqueInput
  }

  /**
   * user_stakes updateMany
   */
  export type user_stakesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_stakes.
     */
    data: XOR<user_stakesUpdateManyMutationInput, user_stakesUncheckedUpdateManyInput>
    /**
     * Filter which user_stakes to update
     */
    where?: user_stakesWhereInput
    /**
     * Limit how many user_stakes to update.
     */
    limit?: number
  }

  /**
   * user_stakes updateManyAndReturn
   */
  export type user_stakesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * The data used to update user_stakes.
     */
    data: XOR<user_stakesUpdateManyMutationInput, user_stakesUncheckedUpdateManyInput>
    /**
     * Filter which user_stakes to update
     */
    where?: user_stakesWhereInput
    /**
     * Limit how many user_stakes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_stakes upsert
   */
  export type user_stakesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_stakes to update in case it exists.
     */
    where: user_stakesWhereUniqueInput
    /**
     * In case the user_stakes found by the `where` argument doesn't exist, create a new user_stakes with this data.
     */
    create: XOR<user_stakesCreateInput, user_stakesUncheckedCreateInput>
    /**
     * In case the user_stakes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_stakesUpdateInput, user_stakesUncheckedUpdateInput>
  }

  /**
   * user_stakes delete
   */
  export type user_stakesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    /**
     * Filter which user_stakes to delete.
     */
    where: user_stakesWhereUniqueInput
  }

  /**
   * user_stakes deleteMany
   */
  export type user_stakesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_stakes to delete
     */
    where?: user_stakesWhereInput
    /**
     * Limit how many user_stakes to delete.
     */
    limit?: number
  }

  /**
   * user_stakes without action
   */
  export type user_stakesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    nonce: number | null
  }

  export type UsersSumAggregateOutputType = {
    nonce: number | null
  }

  export type UsersMinAggregateOutputType = {
    walletAddress: string | null
    username: string | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    nonce: number | null
    network: string | null
  }

  export type UsersMaxAggregateOutputType = {
    walletAddress: string | null
    username: string | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    nonce: number | null
    network: string | null
  }

  export type UsersCountAggregateOutputType = {
    walletAddress: number
    username: number
    avatarUrl: number
    createdAt: number
    updatedAt: number
    nonce: number
    network: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    nonce?: true
  }

  export type UsersSumAggregateInputType = {
    nonce?: true
  }

  export type UsersMinAggregateInputType = {
    walletAddress?: true
    username?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    nonce?: true
    network?: true
  }

  export type UsersMaxAggregateInputType = {
    walletAddress?: true
    username?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    nonce?: true
    network?: true
  }

  export type UsersCountAggregateInputType = {
    walletAddress?: true
    username?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    nonce?: true
    network?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    walletAddress: string
    username: string | null
    avatarUrl: string | null
    createdAt: Date
    updatedAt: Date
    nonce: number | null
    network: string
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    walletAddress?: boolean
    username?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nonce?: boolean
    network?: boolean
    comments?: boolean | users$commentsArgs<ExtArgs>
    likes?: boolean | users$likesArgs<ExtArgs>
    staking_pools?: boolean | users$staking_poolsArgs<ExtArgs>
    user_stakes?: boolean | users$user_stakesArgs<ExtArgs>
    token_balances?: boolean | users$token_balancesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    walletAddress?: boolean
    username?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nonce?: boolean
    network?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    walletAddress?: boolean
    username?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nonce?: boolean
    network?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    walletAddress?: boolean
    username?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nonce?: boolean
    network?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"walletAddress" | "username" | "avatarUrl" | "createdAt" | "updatedAt" | "nonce" | "network", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | users$commentsArgs<ExtArgs>
    likes?: boolean | users$likesArgs<ExtArgs>
    staking_pools?: boolean | users$staking_poolsArgs<ExtArgs>
    user_stakes?: boolean | users$user_stakesArgs<ExtArgs>
    token_balances?: boolean | users$token_balancesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      comments: Prisma.$commentsPayload<ExtArgs>[]
      likes: Prisma.$likesPayload<ExtArgs>[]
      staking_pools: Prisma.$staking_poolsPayload<ExtArgs>[]
      user_stakes: Prisma.$user_stakesPayload<ExtArgs>[]
      token_balances: Prisma.$token_holdersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      walletAddress: string
      username: string | null
      avatarUrl: string | null
      createdAt: Date
      updatedAt: Date
      nonce: number | null
      network: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `walletAddress`
     * const usersWithWalletAddressOnly = await prisma.users.findMany({ select: { walletAddress: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `walletAddress`
     * const usersWithWalletAddressOnly = await prisma.users.createManyAndReturn({
     *   select: { walletAddress: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `walletAddress`
     * const usersWithWalletAddressOnly = await prisma.users.updateManyAndReturn({
     *   select: { walletAddress: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends users$commentsArgs<ExtArgs> = {}>(args?: Subset<T, users$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends users$likesArgs<ExtArgs> = {}>(args?: Subset<T, users$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staking_pools<T extends users$staking_poolsArgs<ExtArgs> = {}>(args?: Subset<T, users$staking_poolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staking_poolsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_stakes<T extends users$user_stakesArgs<ExtArgs> = {}>(args?: Subset<T, users$user_stakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_stakesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    token_balances<T extends users$token_balancesArgs<ExtArgs> = {}>(args?: Subset<T, users$token_balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly walletAddress: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly avatarUrl: FieldRef<"users", 'String'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly nonce: FieldRef<"users", 'Int'>
    readonly network: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.comments
   */
  export type users$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * users.likes
   */
  export type users$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the likes
     */
    omit?: likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    where?: likesWhereInput
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    cursor?: likesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * users.staking_pools
   */
  export type users$staking_poolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staking_pools
     */
    select?: staking_poolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staking_pools
     */
    omit?: staking_poolsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staking_poolsInclude<ExtArgs> | null
    where?: staking_poolsWhereInput
    orderBy?: staking_poolsOrderByWithRelationInput | staking_poolsOrderByWithRelationInput[]
    cursor?: staking_poolsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Staking_poolsScalarFieldEnum | Staking_poolsScalarFieldEnum[]
  }

  /**
   * users.user_stakes
   */
  export type users$user_stakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_stakes
     */
    select?: user_stakesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_stakes
     */
    omit?: user_stakesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_stakesInclude<ExtArgs> | null
    where?: user_stakesWhereInput
    orderBy?: user_stakesOrderByWithRelationInput | user_stakesOrderByWithRelationInput[]
    cursor?: user_stakesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_stakesScalarFieldEnum | User_stakesScalarFieldEnum[]
  }

  /**
   * users.token_balances
   */
  export type users$token_balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    where?: token_holdersWhereInput
    orderBy?: token_holdersOrderByWithRelationInput | token_holdersOrderByWithRelationInput[]
    cursor?: token_holdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Token_holdersScalarFieldEnum | Token_holdersScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model token_holders
   */

  export type AggregateToken_holders = {
    _count: Token_holdersCountAggregateOutputType | null
    _avg: Token_holdersAvgAggregateOutputType | null
    _sum: Token_holdersSumAggregateOutputType | null
    _min: Token_holdersMinAggregateOutputType | null
    _max: Token_holdersMaxAggregateOutputType | null
  }

  export type Token_holdersAvgAggregateOutputType = {
    balance: number | null
  }

  export type Token_holdersSumAggregateOutputType = {
    balance: bigint | null
  }

  export type Token_holdersMinAggregateOutputType = {
    network: string | null
    userWalletAddress: string | null
    tokenAddress: string | null
    balance: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Token_holdersMaxAggregateOutputType = {
    network: string | null
    userWalletAddress: string | null
    tokenAddress: string | null
    balance: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Token_holdersCountAggregateOutputType = {
    network: number
    userWalletAddress: number
    tokenAddress: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Token_holdersAvgAggregateInputType = {
    balance?: true
  }

  export type Token_holdersSumAggregateInputType = {
    balance?: true
  }

  export type Token_holdersMinAggregateInputType = {
    network?: true
    userWalletAddress?: true
    tokenAddress?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Token_holdersMaxAggregateInputType = {
    network?: true
    userWalletAddress?: true
    tokenAddress?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Token_holdersCountAggregateInputType = {
    network?: true
    userWalletAddress?: true
    tokenAddress?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Token_holdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which token_holders to aggregate.
     */
    where?: token_holdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_holders to fetch.
     */
    orderBy?: token_holdersOrderByWithRelationInput | token_holdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: token_holdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_holders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_holders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned token_holders
    **/
    _count?: true | Token_holdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Token_holdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Token_holdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Token_holdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Token_holdersMaxAggregateInputType
  }

  export type GetToken_holdersAggregateType<T extends Token_holdersAggregateArgs> = {
        [P in keyof T & keyof AggregateToken_holders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken_holders[P]>
      : GetScalarType<T[P], AggregateToken_holders[P]>
  }




  export type token_holdersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: token_holdersWhereInput
    orderBy?: token_holdersOrderByWithAggregationInput | token_holdersOrderByWithAggregationInput[]
    by: Token_holdersScalarFieldEnum[] | Token_holdersScalarFieldEnum
    having?: token_holdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Token_holdersCountAggregateInputType | true
    _avg?: Token_holdersAvgAggregateInputType
    _sum?: Token_holdersSumAggregateInputType
    _min?: Token_holdersMinAggregateInputType
    _max?: Token_holdersMaxAggregateInputType
  }

  export type Token_holdersGroupByOutputType = {
    network: string
    userWalletAddress: string
    tokenAddress: string
    balance: bigint
    createdAt: Date
    updatedAt: Date
    _count: Token_holdersCountAggregateOutputType | null
    _avg: Token_holdersAvgAggregateOutputType | null
    _sum: Token_holdersSumAggregateOutputType | null
    _min: Token_holdersMinAggregateOutputType | null
    _max: Token_holdersMaxAggregateOutputType | null
  }

  type GetToken_holdersGroupByPayload<T extends token_holdersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Token_holdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Token_holdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Token_holdersGroupByOutputType[P]>
            : GetScalarType<T[P], Token_holdersGroupByOutputType[P]>
        }
      >
    >


  export type token_holdersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    network?: boolean
    userWalletAddress?: boolean
    tokenAddress?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    pool?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token_holders"]>

  export type token_holdersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    network?: boolean
    userWalletAddress?: boolean
    tokenAddress?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    pool?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token_holders"]>

  export type token_holdersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    network?: boolean
    userWalletAddress?: boolean
    tokenAddress?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    pool?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token_holders"]>

  export type token_holdersSelectScalar = {
    network?: boolean
    userWalletAddress?: boolean
    tokenAddress?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type token_holdersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"network" | "userWalletAddress" | "tokenAddress" | "balance" | "createdAt" | "updatedAt", ExtArgs["result"]["token_holders"]>
  export type token_holdersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    pool?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }
  export type token_holdersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    pool?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }
  export type token_holdersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    pool?: boolean | PoolsDBDefaultArgs<ExtArgs>
  }

  export type $token_holdersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "token_holders"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      pool: Prisma.$PoolsDBPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      network: string
      userWalletAddress: string
      tokenAddress: string
      balance: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["token_holders"]>
    composites: {}
  }

  type token_holdersGetPayload<S extends boolean | null | undefined | token_holdersDefaultArgs> = $Result.GetResult<Prisma.$token_holdersPayload, S>

  type token_holdersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<token_holdersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Token_holdersCountAggregateInputType | true
    }

  export interface token_holdersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['token_holders'], meta: { name: 'token_holders' } }
    /**
     * Find zero or one Token_holders that matches the filter.
     * @param {token_holdersFindUniqueArgs} args - Arguments to find a Token_holders
     * @example
     * // Get one Token_holders
     * const token_holders = await prisma.token_holders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends token_holdersFindUniqueArgs>(args: SelectSubset<T, token_holdersFindUniqueArgs<ExtArgs>>): Prisma__token_holdersClient<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token_holders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {token_holdersFindUniqueOrThrowArgs} args - Arguments to find a Token_holders
     * @example
     * // Get one Token_holders
     * const token_holders = await prisma.token_holders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends token_holdersFindUniqueOrThrowArgs>(args: SelectSubset<T, token_holdersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__token_holdersClient<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token_holders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_holdersFindFirstArgs} args - Arguments to find a Token_holders
     * @example
     * // Get one Token_holders
     * const token_holders = await prisma.token_holders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends token_holdersFindFirstArgs>(args?: SelectSubset<T, token_holdersFindFirstArgs<ExtArgs>>): Prisma__token_holdersClient<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token_holders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_holdersFindFirstOrThrowArgs} args - Arguments to find a Token_holders
     * @example
     * // Get one Token_holders
     * const token_holders = await prisma.token_holders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends token_holdersFindFirstOrThrowArgs>(args?: SelectSubset<T, token_holdersFindFirstOrThrowArgs<ExtArgs>>): Prisma__token_holdersClient<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Token_holders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_holdersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Token_holders
     * const token_holders = await prisma.token_holders.findMany()
     * 
     * // Get first 10 Token_holders
     * const token_holders = await prisma.token_holders.findMany({ take: 10 })
     * 
     * // Only select the `network`
     * const token_holdersWithNetworkOnly = await prisma.token_holders.findMany({ select: { network: true } })
     * 
     */
    findMany<T extends token_holdersFindManyArgs>(args?: SelectSubset<T, token_holdersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token_holders.
     * @param {token_holdersCreateArgs} args - Arguments to create a Token_holders.
     * @example
     * // Create one Token_holders
     * const Token_holders = await prisma.token_holders.create({
     *   data: {
     *     // ... data to create a Token_holders
     *   }
     * })
     * 
     */
    create<T extends token_holdersCreateArgs>(args: SelectSubset<T, token_holdersCreateArgs<ExtArgs>>): Prisma__token_holdersClient<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Token_holders.
     * @param {token_holdersCreateManyArgs} args - Arguments to create many Token_holders.
     * @example
     * // Create many Token_holders
     * const token_holders = await prisma.token_holders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends token_holdersCreateManyArgs>(args?: SelectSubset<T, token_holdersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Token_holders and returns the data saved in the database.
     * @param {token_holdersCreateManyAndReturnArgs} args - Arguments to create many Token_holders.
     * @example
     * // Create many Token_holders
     * const token_holders = await prisma.token_holders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Token_holders and only return the `network`
     * const token_holdersWithNetworkOnly = await prisma.token_holders.createManyAndReturn({
     *   select: { network: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends token_holdersCreateManyAndReturnArgs>(args?: SelectSubset<T, token_holdersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token_holders.
     * @param {token_holdersDeleteArgs} args - Arguments to delete one Token_holders.
     * @example
     * // Delete one Token_holders
     * const Token_holders = await prisma.token_holders.delete({
     *   where: {
     *     // ... filter to delete one Token_holders
     *   }
     * })
     * 
     */
    delete<T extends token_holdersDeleteArgs>(args: SelectSubset<T, token_holdersDeleteArgs<ExtArgs>>): Prisma__token_holdersClient<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token_holders.
     * @param {token_holdersUpdateArgs} args - Arguments to update one Token_holders.
     * @example
     * // Update one Token_holders
     * const token_holders = await prisma.token_holders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends token_holdersUpdateArgs>(args: SelectSubset<T, token_holdersUpdateArgs<ExtArgs>>): Prisma__token_holdersClient<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Token_holders.
     * @param {token_holdersDeleteManyArgs} args - Arguments to filter Token_holders to delete.
     * @example
     * // Delete a few Token_holders
     * const { count } = await prisma.token_holders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends token_holdersDeleteManyArgs>(args?: SelectSubset<T, token_holdersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_holders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_holdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Token_holders
     * const token_holders = await prisma.token_holders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends token_holdersUpdateManyArgs>(args: SelectSubset<T, token_holdersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_holders and returns the data updated in the database.
     * @param {token_holdersUpdateManyAndReturnArgs} args - Arguments to update many Token_holders.
     * @example
     * // Update many Token_holders
     * const token_holders = await prisma.token_holders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Token_holders and only return the `network`
     * const token_holdersWithNetworkOnly = await prisma.token_holders.updateManyAndReturn({
     *   select: { network: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends token_holdersUpdateManyAndReturnArgs>(args: SelectSubset<T, token_holdersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token_holders.
     * @param {token_holdersUpsertArgs} args - Arguments to update or create a Token_holders.
     * @example
     * // Update or create a Token_holders
     * const token_holders = await prisma.token_holders.upsert({
     *   create: {
     *     // ... data to create a Token_holders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token_holders we want to update
     *   }
     * })
     */
    upsert<T extends token_holdersUpsertArgs>(args: SelectSubset<T, token_holdersUpsertArgs<ExtArgs>>): Prisma__token_holdersClient<$Result.GetResult<Prisma.$token_holdersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Token_holders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_holdersCountArgs} args - Arguments to filter Token_holders to count.
     * @example
     * // Count the number of Token_holders
     * const count = await prisma.token_holders.count({
     *   where: {
     *     // ... the filter for the Token_holders we want to count
     *   }
     * })
    **/
    count<T extends token_holdersCountArgs>(
      args?: Subset<T, token_holdersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Token_holdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token_holders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_holdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Token_holdersAggregateArgs>(args: Subset<T, Token_holdersAggregateArgs>): Prisma.PrismaPromise<GetToken_holdersAggregateType<T>>

    /**
     * Group by Token_holders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_holdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends token_holdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: token_holdersGroupByArgs['orderBy'] }
        : { orderBy?: token_holdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, token_holdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToken_holdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the token_holders model
   */
  readonly fields: token_holdersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for token_holders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__token_holdersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pool<T extends PoolsDBDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoolsDBDefaultArgs<ExtArgs>>): Prisma__PoolsDBClient<$Result.GetResult<Prisma.$PoolsDBPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the token_holders model
   */
  interface token_holdersFieldRefs {
    readonly network: FieldRef<"token_holders", 'String'>
    readonly userWalletAddress: FieldRef<"token_holders", 'String'>
    readonly tokenAddress: FieldRef<"token_holders", 'String'>
    readonly balance: FieldRef<"token_holders", 'BigInt'>
    readonly createdAt: FieldRef<"token_holders", 'DateTime'>
    readonly updatedAt: FieldRef<"token_holders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * token_holders findUnique
   */
  export type token_holdersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * Filter, which token_holders to fetch.
     */
    where: token_holdersWhereUniqueInput
  }

  /**
   * token_holders findUniqueOrThrow
   */
  export type token_holdersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * Filter, which token_holders to fetch.
     */
    where: token_holdersWhereUniqueInput
  }

  /**
   * token_holders findFirst
   */
  export type token_holdersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * Filter, which token_holders to fetch.
     */
    where?: token_holdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_holders to fetch.
     */
    orderBy?: token_holdersOrderByWithRelationInput | token_holdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_holders.
     */
    cursor?: token_holdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_holders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_holders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_holders.
     */
    distinct?: Token_holdersScalarFieldEnum | Token_holdersScalarFieldEnum[]
  }

  /**
   * token_holders findFirstOrThrow
   */
  export type token_holdersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * Filter, which token_holders to fetch.
     */
    where?: token_holdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_holders to fetch.
     */
    orderBy?: token_holdersOrderByWithRelationInput | token_holdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_holders.
     */
    cursor?: token_holdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_holders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_holders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_holders.
     */
    distinct?: Token_holdersScalarFieldEnum | Token_holdersScalarFieldEnum[]
  }

  /**
   * token_holders findMany
   */
  export type token_holdersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * Filter, which token_holders to fetch.
     */
    where?: token_holdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_holders to fetch.
     */
    orderBy?: token_holdersOrderByWithRelationInput | token_holdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing token_holders.
     */
    cursor?: token_holdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_holders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_holders.
     */
    skip?: number
    distinct?: Token_holdersScalarFieldEnum | Token_holdersScalarFieldEnum[]
  }

  /**
   * token_holders create
   */
  export type token_holdersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * The data needed to create a token_holders.
     */
    data: XOR<token_holdersCreateInput, token_holdersUncheckedCreateInput>
  }

  /**
   * token_holders createMany
   */
  export type token_holdersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many token_holders.
     */
    data: token_holdersCreateManyInput | token_holdersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * token_holders createManyAndReturn
   */
  export type token_holdersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * The data used to create many token_holders.
     */
    data: token_holdersCreateManyInput | token_holdersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * token_holders update
   */
  export type token_holdersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * The data needed to update a token_holders.
     */
    data: XOR<token_holdersUpdateInput, token_holdersUncheckedUpdateInput>
    /**
     * Choose, which token_holders to update.
     */
    where: token_holdersWhereUniqueInput
  }

  /**
   * token_holders updateMany
   */
  export type token_holdersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update token_holders.
     */
    data: XOR<token_holdersUpdateManyMutationInput, token_holdersUncheckedUpdateManyInput>
    /**
     * Filter which token_holders to update
     */
    where?: token_holdersWhereInput
    /**
     * Limit how many token_holders to update.
     */
    limit?: number
  }

  /**
   * token_holders updateManyAndReturn
   */
  export type token_holdersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * The data used to update token_holders.
     */
    data: XOR<token_holdersUpdateManyMutationInput, token_holdersUncheckedUpdateManyInput>
    /**
     * Filter which token_holders to update
     */
    where?: token_holdersWhereInput
    /**
     * Limit how many token_holders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * token_holders upsert
   */
  export type token_holdersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * The filter to search for the token_holders to update in case it exists.
     */
    where: token_holdersWhereUniqueInput
    /**
     * In case the token_holders found by the `where` argument doesn't exist, create a new token_holders with this data.
     */
    create: XOR<token_holdersCreateInput, token_holdersUncheckedCreateInput>
    /**
     * In case the token_holders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<token_holdersUpdateInput, token_holdersUncheckedUpdateInput>
  }

  /**
   * token_holders delete
   */
  export type token_holdersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
    /**
     * Filter which token_holders to delete.
     */
    where: token_holdersWhereUniqueInput
  }

  /**
   * token_holders deleteMany
   */
  export type token_holdersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which token_holders to delete
     */
    where?: token_holdersWhereInput
    /**
     * Limit how many token_holders to delete.
     */
    limit?: number
  }

  /**
   * token_holders without action
   */
  export type token_holdersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_holders
     */
    select?: token_holdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the token_holders
     */
    omit?: token_holdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: token_holdersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AmmpairScalarFieldEnum: {
    id: 'id',
    pair: 'pair',
    creator: 'creator',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    version: 'version',
    token0Address: 'token0Address',
    token1Address: 'token1Address',
    network: 'network',
    token0Network: 'token0Network',
    token1Network: 'token1Network',
    verified: 'verified',
    displayOrder: 'displayOrder',
    apr24h: 'apr24h',
    apr7d: 'apr7d',
    apyCalculated: 'apyCalculated',
    lastStatsUpdate: 'lastStatsUpdate',
    lpFeePercent: 'lpFeePercent',
    reserve0: 'reserve0',
    reserve1: 'reserve1',
    tvlUsd: 'tvlUsd',
    volumeToken0_24h: 'volumeToken0_24h',
    volumeToken1_24h: 'volumeToken1_24h',
    volumeUsd24h: 'volumeUsd24h',
    volumeUsd7d: 'volumeUsd7d',
    volumeUsd30d: 'volumeUsd30d',
    feesUsd24h: 'feesUsd24h',
    feesUsd7d: 'feesUsd7d',
    feesUsd30d: 'feesUsd30d'
  };

  export type AmmpairScalarFieldEnum = (typeof AmmpairScalarFieldEnum)[keyof typeof AmmpairScalarFieldEnum]


  export const EventTrackingScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    blockHeight: 'blockHeight',
    transactionHash: 'transactionHash',
    processed: 'processed',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    network: 'network',
    sequenceNumber: 'sequenceNumber'
  };

  export type EventTrackingScalarFieldEnum = (typeof EventTrackingScalarFieldEnum)[keyof typeof EventTrackingScalarFieldEnum]


  export const GameResultScalarFieldEnum: {
    id: 'id',
    nonce: 'nonce',
    player: 'player',
    playerMove: 'playerMove',
    houseMove: 'houseMove',
    betAmount: 'betAmount',
    outcome: 'outcome',
    payoutAmount: 'payoutAmount',
    coinTypeName: 'coinTypeName',
    season: 'season',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    network: 'network'
  };

  export type GameResultScalarFieldEnum = (typeof GameResultScalarFieldEnum)[keyof typeof GameResultScalarFieldEnum]


  export const PoolsDBScalarFieldEnum: {
    id: 'id',
    description: 'description',
    dev: 'dev',
    initialVirtualSupraReserves: 'initialVirtualSupraReserves',
    initialVirtualTokenReserves: 'initialVirtualTokenReserves',
    name: 'name',
    platformFee: 'platformFee',
    pool: 'pool',
    symbol: 'symbol',
    telegram: 'telegram',
    tokenAddress: 'tokenAddress',
    tokenDecimals: 'tokenDecimals',
    twitter: 'twitter',
    uri: 'uri',
    website: 'website',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    network: 'network',
    displayOrder: 'displayOrder',
    github: 'github',
    stream: 'stream',
    unstakePeriodSeconds: 'unstakePeriodSeconds',
    project_type: 'project_type'
  };

  export type PoolsDBScalarFieldEnum = (typeof PoolsDBScalarFieldEnum)[keyof typeof PoolsDBScalarFieldEnum]


  export const TradeEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    creationNumber: 'creationNumber',
    accountAddress: 'accountAddress',
    sequenceNumber: 'sequenceNumber',
    timestamp: 'timestamp',
    isBuy: 'isBuy',
    supraAmount: 'supraAmount',
    tokenAddress: 'tokenAddress',
    tokenAmount: 'tokenAmount',
    user: 'user',
    virtualSupraReserves: 'virtualSupraReserves',
    virtualTokenReserves: 'virtualTokenReserves',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    network: 'network',
    processedForOHLC: 'processedForOHLC'
  };

  export type TradeEventScalarFieldEnum = (typeof TradeEventScalarFieldEnum)[keyof typeof TradeEventScalarFieldEnum]


  export const VRFCallbackScalarFieldEnum: {
    id: 'id',
    callerAddress: 'callerAddress',
    nonce: 'nonce',
    randomNumbers: 'randomNumbers',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    network: 'network'
  };

  export type VRFCallbackScalarFieldEnum = (typeof VRFCallbackScalarFieldEnum)[keyof typeof VRFCallbackScalarFieldEnum]


  export const Block_progressScalarFieldEnum: {
    network: 'network',
    lastBlockHeight: 'lastBlockHeight',
    updatedAt: 'updatedAt'
  };

  export type Block_progressScalarFieldEnum = (typeof Block_progressScalarFieldEnum)[keyof typeof Block_progressScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    text: 'text',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    poolId: 'poolId',
    network: 'network',
    userNetwork: 'userNetwork',
    userWalletAddress: 'userWalletAddress',
    displayOrder: 'displayOrder',
    likeCount: 'likeCount',
    poolNetwork: 'poolNetwork'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const ImagesScalarFieldEnum: {
    id: 'id',
    url: 'url',
    altText: 'altText',
    createdAt: 'createdAt',
    commentId: 'commentId'
  };

  export type ImagesScalarFieldEnum = (typeof ImagesScalarFieldEnum)[keyof typeof ImagesScalarFieldEnum]


  export const LikesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    commentId: 'commentId',
    network: 'network',
    userNetwork: 'userNetwork',
    userWalletAddress: 'userWalletAddress'
  };

  export type LikesScalarFieldEnum = (typeof LikesScalarFieldEnum)[keyof typeof LikesScalarFieldEnum]


  export const Migration_eventsScalarFieldEnum: {
    id: 'id',
    network: 'network',
    transactionHash: 'transactionHash',
    sequenceNumber: 'sequenceNumber',
    token_address: 'token_address',
    migrator: 'migrator',
    supra_sent_to_lp: 'supra_sent_to_lp',
    tokens_sent_to_lp: 'tokens_sent_to_lp',
    dev_reward_staked: 'dev_reward_staked',
    staking_pool_reward: 'staking_pool_reward',
    migrator_reward: 'migrator_reward',
    excess_supra_collected: 'excess_supra_collected',
    createdAt: 'createdAt'
  };

  export type Migration_eventsScalarFieldEnum = (typeof Migration_eventsScalarFieldEnum)[keyof typeof Migration_eventsScalarFieldEnum]


  export const Protocol_statsScalarFieldEnum: {
    id: 'id',
    network: 'network',
    timestamp: 'timestamp',
    totalTvlUsd: 'totalTvlUsd',
    ammTvlUsd: 'ammTvlUsd',
    virtualPoolsTvlUsd: 'virtualPoolsTvlUsd',
    stakingTvlUsd: 'stakingTvlUsd',
    totalVolume24hUsd: 'totalVolume24hUsd',
    ammVolume24hUsd: 'ammVolume24hUsd',
    totalUniqueUsers: 'totalUniqueUsers',
    totalFeesEarnedUsd24h: 'totalFeesEarnedUsd24h'
  };

  export type Protocol_statsScalarFieldEnum = (typeof Protocol_statsScalarFieldEnum)[keyof typeof Protocol_statsScalarFieldEnum]


  export const Staking_poolsScalarFieldEnum: {
    id: 'id',
    creatorAddress: 'creatorAddress',
    stakeTokenAddress: 'stakeTokenAddress',
    rewardTokenAddress: 'rewardTokenAddress',
    isDynamicPool: 'isDynamicPool',
    rewardPerSec: 'rewardPerSec',
    accumReward: 'accumReward',
    lastUpdatedTimestamp: 'lastUpdatedTimestamp',
    startTimestamp: 'startTimestamp',
    endTimestamp: 'endTimestamp',
    emergencyLocked: 'emergencyLocked',
    stakesClosed: 'stakesClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorNetwork: 'creatorNetwork',
    network: 'network',
    rewardTokenNetwork: 'rewardTokenNetwork',
    stakeTokenNetwork: 'stakeTokenNetwork',
    boostEnabled: 'boostEnabled',
    initialEndTimestamp: 'initialEndTimestamp',
    initialRewardPerSec: 'initialRewardPerSec',
    verified: 'verified',
    totalBoosted: 'totalBoosted',
    displayOrder: 'displayOrder',
    cachedApy: 'cachedApy',
    cachedStakerCount: 'cachedStakerCount',
    cachedTvlUsd: 'cachedTvlUsd',
    poolType: 'poolType',
    totalStakedAmount: 'totalStakedAmount',
    boostConfigCollectionName: 'boostConfigCollectionName',
    boostConfigCollectionOwner: 'boostConfigCollectionOwner',
    boostConfigPercent: 'boostConfigPercent'
  };

  export type Staking_poolsScalarFieldEnum = (typeof Staking_poolsScalarFieldEnum)[keyof typeof Staking_poolsScalarFieldEnum]


  export const Token_price_historyScalarFieldEnum: {
    id: 'id',
    network: 'network',
    tokenAddress: 'tokenAddress',
    timestamp: 'timestamp',
    granularity: 'granularity',
    open: 'open',
    high: 'high',
    low: 'low',
    close: 'close',
    volume: 'volume'
  };

  export type Token_price_historyScalarFieldEnum = (typeof Token_price_historyScalarFieldEnum)[keyof typeof Token_price_historyScalarFieldEnum]


  export const Token_pricesScalarFieldEnum: {
    id: 'id',
    network: 'network',
    tokenAddress: 'tokenAddress',
    priceUsd: 'priceUsd',
    priceAnchor: 'priceAnchor',
    source: 'source',
    lastUpdatedAt: 'lastUpdatedAt'
  };

  export type Token_pricesScalarFieldEnum = (typeof Token_pricesScalarFieldEnum)[keyof typeof Token_pricesScalarFieldEnum]


  export const TokensScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    decimals: 'decimals',
    iconUri: 'iconUri',
    projectUri: 'projectUri',
    network: 'network',
    lastMetadataAttempt: 'lastMetadataAttempt',
    metadataFetched: 'metadataFetched',
    metadataStandard: 'metadataStandard',
    verified: 'verified',
    displayOrder: 'displayOrder',
    originalCoinType: 'originalCoinType',
    circulatingSupply: 'circulatingSupply',
    createdAt: 'createdAt',
    marketCapUsd: 'marketCapUsd',
    priceChange24hPercent: 'priceChange24hPercent',
    priceUsdCurrent: 'priceUsdCurrent',
    priceAnchor: 'priceAnchor',
    lastPriceUpdate: 'lastPriceUpdate',
    totalSupply: 'totalSupply',
    updatedAt: 'updatedAt',
    volume24hUsd: 'volume24hUsd'
  };

  export type TokensScalarFieldEnum = (typeof TokensScalarFieldEnum)[keyof typeof TokensScalarFieldEnum]


  export const Trust_poolsScalarFieldEnum: {
    id: 'id',
    network: 'network',
    poolDbId: 'poolDbId',
    tokenAddress: 'tokenAddress',
    isActive: 'isActive',
    totalStakedAmount: 'totalStakedAmount',
    stakerCount: 'stakerCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Trust_poolsScalarFieldEnum = (typeof Trust_poolsScalarFieldEnum)[keyof typeof Trust_poolsScalarFieldEnum]


  export const User_stakesScalarFieldEnum: {
    id: 'id',
    poolId: 'poolId',
    userNetwork: 'userNetwork',
    userAddress: 'userAddress',
    stakedAmount: 'stakedAmount',
    rewardDebt: 'rewardDebt',
    lastClaimTimestamp: 'lastClaimTimestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_stakesScalarFieldEnum = (typeof User_stakesScalarFieldEnum)[keyof typeof User_stakesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    walletAddress: 'walletAddress',
    username: 'username',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nonce: 'nonce',
    network: 'network'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Token_holdersScalarFieldEnum: {
    network: 'network',
    userWalletAddress: 'userWalletAddress',
    tokenAddress: 'tokenAddress',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Token_holdersScalarFieldEnum = (typeof Token_holdersScalarFieldEnum)[keyof typeof Token_holdersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AmmVersion'
   */
  export type EnumAmmVersionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AmmVersion'>
    


  /**
   * Reference to a field of type 'AmmVersion[]'
   */
  export type ListEnumAmmVersionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AmmVersion[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PoolType'
   */
  export type EnumPoolTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoolType'>
    


  /**
   * Reference to a field of type 'PoolType[]'
   */
  export type ListEnumPoolTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoolType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AmmpairWhereInput = {
    AND?: AmmpairWhereInput | AmmpairWhereInput[]
    OR?: AmmpairWhereInput[]
    NOT?: AmmpairWhereInput | AmmpairWhereInput[]
    id?: IntFilter<"Ammpair"> | number
    pair?: StringFilter<"Ammpair"> | string
    creator?: StringFilter<"Ammpair"> | string
    createdAt?: DateTimeFilter<"Ammpair"> | Date | string
    updatedAt?: DateTimeFilter<"Ammpair"> | Date | string
    version?: EnumAmmVersionFilter<"Ammpair"> | $Enums.AmmVersion
    token0Address?: StringFilter<"Ammpair"> | string
    token1Address?: StringFilter<"Ammpair"> | string
    network?: StringFilter<"Ammpair"> | string
    token0Network?: StringFilter<"Ammpair"> | string
    token1Network?: StringFilter<"Ammpair"> | string
    verified?: BoolFilter<"Ammpair"> | boolean
    displayOrder?: IntNullableFilter<"Ammpair"> | number | null
    apr24h?: StringNullableFilter<"Ammpair"> | string | null
    apr7d?: StringNullableFilter<"Ammpair"> | string | null
    apyCalculated?: StringNullableFilter<"Ammpair"> | string | null
    lastStatsUpdate?: DateTimeNullableFilter<"Ammpair"> | Date | string | null
    lpFeePercent?: StringNullableFilter<"Ammpair"> | string | null
    reserve0?: StringNullableFilter<"Ammpair"> | string | null
    reserve1?: StringNullableFilter<"Ammpair"> | string | null
    tvlUsd?: StringNullableFilter<"Ammpair"> | string | null
    volumeToken0_24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeToken1_24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd7d?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd30d?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd24h?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd7d?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd30d?: StringNullableFilter<"Ammpair"> | string | null
    token0?: XOR<TokensScalarRelationFilter, tokensWhereInput>
    token1?: XOR<TokensScalarRelationFilter, tokensWhereInput>
  }

  export type AmmpairOrderByWithRelationInput = {
    id?: SortOrder
    pair?: SortOrder
    creator?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    token0Address?: SortOrder
    token1Address?: SortOrder
    network?: SortOrder
    token0Network?: SortOrder
    token1Network?: SortOrder
    verified?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    apr24h?: SortOrderInput | SortOrder
    apr7d?: SortOrderInput | SortOrder
    apyCalculated?: SortOrderInput | SortOrder
    lastStatsUpdate?: SortOrderInput | SortOrder
    lpFeePercent?: SortOrderInput | SortOrder
    reserve0?: SortOrderInput | SortOrder
    reserve1?: SortOrderInput | SortOrder
    tvlUsd?: SortOrderInput | SortOrder
    volumeToken0_24h?: SortOrderInput | SortOrder
    volumeToken1_24h?: SortOrderInput | SortOrder
    volumeUsd24h?: SortOrderInput | SortOrder
    volumeUsd7d?: SortOrderInput | SortOrder
    volumeUsd30d?: SortOrderInput | SortOrder
    feesUsd24h?: SortOrderInput | SortOrder
    feesUsd7d?: SortOrderInput | SortOrder
    feesUsd30d?: SortOrderInput | SortOrder
    token0?: tokensOrderByWithRelationInput
    token1?: tokensOrderByWithRelationInput
  }

  export type AmmpairWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_pair?: AmmpairNetworkPairCompoundUniqueInput
    AND?: AmmpairWhereInput | AmmpairWhereInput[]
    OR?: AmmpairWhereInput[]
    NOT?: AmmpairWhereInput | AmmpairWhereInput[]
    pair?: StringFilter<"Ammpair"> | string
    creator?: StringFilter<"Ammpair"> | string
    createdAt?: DateTimeFilter<"Ammpair"> | Date | string
    updatedAt?: DateTimeFilter<"Ammpair"> | Date | string
    version?: EnumAmmVersionFilter<"Ammpair"> | $Enums.AmmVersion
    token0Address?: StringFilter<"Ammpair"> | string
    token1Address?: StringFilter<"Ammpair"> | string
    network?: StringFilter<"Ammpair"> | string
    token0Network?: StringFilter<"Ammpair"> | string
    token1Network?: StringFilter<"Ammpair"> | string
    verified?: BoolFilter<"Ammpair"> | boolean
    displayOrder?: IntNullableFilter<"Ammpair"> | number | null
    apr24h?: StringNullableFilter<"Ammpair"> | string | null
    apr7d?: StringNullableFilter<"Ammpair"> | string | null
    apyCalculated?: StringNullableFilter<"Ammpair"> | string | null
    lastStatsUpdate?: DateTimeNullableFilter<"Ammpair"> | Date | string | null
    lpFeePercent?: StringNullableFilter<"Ammpair"> | string | null
    reserve0?: StringNullableFilter<"Ammpair"> | string | null
    reserve1?: StringNullableFilter<"Ammpair"> | string | null
    tvlUsd?: StringNullableFilter<"Ammpair"> | string | null
    volumeToken0_24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeToken1_24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd7d?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd30d?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd24h?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd7d?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd30d?: StringNullableFilter<"Ammpair"> | string | null
    token0?: XOR<TokensScalarRelationFilter, tokensWhereInput>
    token1?: XOR<TokensScalarRelationFilter, tokensWhereInput>
  }, "id" | "network_pair">

  export type AmmpairOrderByWithAggregationInput = {
    id?: SortOrder
    pair?: SortOrder
    creator?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    token0Address?: SortOrder
    token1Address?: SortOrder
    network?: SortOrder
    token0Network?: SortOrder
    token1Network?: SortOrder
    verified?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    apr24h?: SortOrderInput | SortOrder
    apr7d?: SortOrderInput | SortOrder
    apyCalculated?: SortOrderInput | SortOrder
    lastStatsUpdate?: SortOrderInput | SortOrder
    lpFeePercent?: SortOrderInput | SortOrder
    reserve0?: SortOrderInput | SortOrder
    reserve1?: SortOrderInput | SortOrder
    tvlUsd?: SortOrderInput | SortOrder
    volumeToken0_24h?: SortOrderInput | SortOrder
    volumeToken1_24h?: SortOrderInput | SortOrder
    volumeUsd24h?: SortOrderInput | SortOrder
    volumeUsd7d?: SortOrderInput | SortOrder
    volumeUsd30d?: SortOrderInput | SortOrder
    feesUsd24h?: SortOrderInput | SortOrder
    feesUsd7d?: SortOrderInput | SortOrder
    feesUsd30d?: SortOrderInput | SortOrder
    _count?: AmmpairCountOrderByAggregateInput
    _avg?: AmmpairAvgOrderByAggregateInput
    _max?: AmmpairMaxOrderByAggregateInput
    _min?: AmmpairMinOrderByAggregateInput
    _sum?: AmmpairSumOrderByAggregateInput
  }

  export type AmmpairScalarWhereWithAggregatesInput = {
    AND?: AmmpairScalarWhereWithAggregatesInput | AmmpairScalarWhereWithAggregatesInput[]
    OR?: AmmpairScalarWhereWithAggregatesInput[]
    NOT?: AmmpairScalarWhereWithAggregatesInput | AmmpairScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ammpair"> | number
    pair?: StringWithAggregatesFilter<"Ammpair"> | string
    creator?: StringWithAggregatesFilter<"Ammpair"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ammpair"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ammpair"> | Date | string
    version?: EnumAmmVersionWithAggregatesFilter<"Ammpair"> | $Enums.AmmVersion
    token0Address?: StringWithAggregatesFilter<"Ammpair"> | string
    token1Address?: StringWithAggregatesFilter<"Ammpair"> | string
    network?: StringWithAggregatesFilter<"Ammpair"> | string
    token0Network?: StringWithAggregatesFilter<"Ammpair"> | string
    token1Network?: StringWithAggregatesFilter<"Ammpair"> | string
    verified?: BoolWithAggregatesFilter<"Ammpair"> | boolean
    displayOrder?: IntNullableWithAggregatesFilter<"Ammpair"> | number | null
    apr24h?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    apr7d?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    apyCalculated?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    lastStatsUpdate?: DateTimeNullableWithAggregatesFilter<"Ammpair"> | Date | string | null
    lpFeePercent?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    reserve0?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    reserve1?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    tvlUsd?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    volumeToken0_24h?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    volumeToken1_24h?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    volumeUsd24h?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    volumeUsd7d?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    volumeUsd30d?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    feesUsd24h?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    feesUsd7d?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
    feesUsd30d?: StringNullableWithAggregatesFilter<"Ammpair"> | string | null
  }

  export type EventTrackingWhereInput = {
    AND?: EventTrackingWhereInput | EventTrackingWhereInput[]
    OR?: EventTrackingWhereInput[]
    NOT?: EventTrackingWhereInput | EventTrackingWhereInput[]
    id?: IntFilter<"EventTracking"> | number
    eventType?: StringFilter<"EventTracking"> | string
    blockHeight?: BigIntFilter<"EventTracking"> | bigint | number
    transactionHash?: StringFilter<"EventTracking"> | string
    processed?: BoolFilter<"EventTracking"> | boolean
    error?: StringNullableFilter<"EventTracking"> | string | null
    createdAt?: DateTimeFilter<"EventTracking"> | Date | string
    updatedAt?: DateTimeFilter<"EventTracking"> | Date | string
    network?: StringFilter<"EventTracking"> | string
    sequenceNumber?: StringNullableFilter<"EventTracking"> | string | null
  }

  export type EventTrackingOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    blockHeight?: SortOrder
    transactionHash?: SortOrder
    processed?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    sequenceNumber?: SortOrderInput | SortOrder
  }

  export type EventTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_transactionHash_sequenceNumber_eventType?: EventTrackingNetworkTransactionHashSequenceNumberEventTypeCompoundUniqueInput
    AND?: EventTrackingWhereInput | EventTrackingWhereInput[]
    OR?: EventTrackingWhereInput[]
    NOT?: EventTrackingWhereInput | EventTrackingWhereInput[]
    eventType?: StringFilter<"EventTracking"> | string
    blockHeight?: BigIntFilter<"EventTracking"> | bigint | number
    transactionHash?: StringFilter<"EventTracking"> | string
    processed?: BoolFilter<"EventTracking"> | boolean
    error?: StringNullableFilter<"EventTracking"> | string | null
    createdAt?: DateTimeFilter<"EventTracking"> | Date | string
    updatedAt?: DateTimeFilter<"EventTracking"> | Date | string
    network?: StringFilter<"EventTracking"> | string
    sequenceNumber?: StringNullableFilter<"EventTracking"> | string | null
  }, "id" | "network_transactionHash_sequenceNumber_eventType">

  export type EventTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    blockHeight?: SortOrder
    transactionHash?: SortOrder
    processed?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    sequenceNumber?: SortOrderInput | SortOrder
    _count?: EventTrackingCountOrderByAggregateInput
    _avg?: EventTrackingAvgOrderByAggregateInput
    _max?: EventTrackingMaxOrderByAggregateInput
    _min?: EventTrackingMinOrderByAggregateInput
    _sum?: EventTrackingSumOrderByAggregateInput
  }

  export type EventTrackingScalarWhereWithAggregatesInput = {
    AND?: EventTrackingScalarWhereWithAggregatesInput | EventTrackingScalarWhereWithAggregatesInput[]
    OR?: EventTrackingScalarWhereWithAggregatesInput[]
    NOT?: EventTrackingScalarWhereWithAggregatesInput | EventTrackingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EventTracking"> | number
    eventType?: StringWithAggregatesFilter<"EventTracking"> | string
    blockHeight?: BigIntWithAggregatesFilter<"EventTracking"> | bigint | number
    transactionHash?: StringWithAggregatesFilter<"EventTracking"> | string
    processed?: BoolWithAggregatesFilter<"EventTracking"> | boolean
    error?: StringNullableWithAggregatesFilter<"EventTracking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EventTracking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventTracking"> | Date | string
    network?: StringWithAggregatesFilter<"EventTracking"> | string
    sequenceNumber?: StringNullableWithAggregatesFilter<"EventTracking"> | string | null
  }

  export type GameResultWhereInput = {
    AND?: GameResultWhereInput | GameResultWhereInput[]
    OR?: GameResultWhereInput[]
    NOT?: GameResultWhereInput | GameResultWhereInput[]
    id?: IntFilter<"GameResult"> | number
    nonce?: BigIntFilter<"GameResult"> | bigint | number
    player?: StringFilter<"GameResult"> | string
    playerMove?: IntFilter<"GameResult"> | number
    houseMove?: IntFilter<"GameResult"> | number
    betAmount?: BigIntFilter<"GameResult"> | bigint | number
    outcome?: IntFilter<"GameResult"> | number
    payoutAmount?: BigIntFilter<"GameResult"> | bigint | number
    coinTypeName?: StringFilter<"GameResult"> | string
    season?: BigIntFilter<"GameResult"> | bigint | number
    timestamp?: BigIntFilter<"GameResult"> | bigint | number
    createdAt?: DateTimeFilter<"GameResult"> | Date | string
    updatedAt?: DateTimeFilter<"GameResult"> | Date | string
    network?: StringFilter<"GameResult"> | string
  }

  export type GameResultOrderByWithRelationInput = {
    id?: SortOrder
    nonce?: SortOrder
    player?: SortOrder
    playerMove?: SortOrder
    houseMove?: SortOrder
    betAmount?: SortOrder
    outcome?: SortOrder
    payoutAmount?: SortOrder
    coinTypeName?: SortOrder
    season?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
  }

  export type GameResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_nonce?: GameResultNetworkNonceCompoundUniqueInput
    AND?: GameResultWhereInput | GameResultWhereInput[]
    OR?: GameResultWhereInput[]
    NOT?: GameResultWhereInput | GameResultWhereInput[]
    nonce?: BigIntFilter<"GameResult"> | bigint | number
    player?: StringFilter<"GameResult"> | string
    playerMove?: IntFilter<"GameResult"> | number
    houseMove?: IntFilter<"GameResult"> | number
    betAmount?: BigIntFilter<"GameResult"> | bigint | number
    outcome?: IntFilter<"GameResult"> | number
    payoutAmount?: BigIntFilter<"GameResult"> | bigint | number
    coinTypeName?: StringFilter<"GameResult"> | string
    season?: BigIntFilter<"GameResult"> | bigint | number
    timestamp?: BigIntFilter<"GameResult"> | bigint | number
    createdAt?: DateTimeFilter<"GameResult"> | Date | string
    updatedAt?: DateTimeFilter<"GameResult"> | Date | string
    network?: StringFilter<"GameResult"> | string
  }, "id" | "network_nonce">

  export type GameResultOrderByWithAggregationInput = {
    id?: SortOrder
    nonce?: SortOrder
    player?: SortOrder
    playerMove?: SortOrder
    houseMove?: SortOrder
    betAmount?: SortOrder
    outcome?: SortOrder
    payoutAmount?: SortOrder
    coinTypeName?: SortOrder
    season?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    _count?: GameResultCountOrderByAggregateInput
    _avg?: GameResultAvgOrderByAggregateInput
    _max?: GameResultMaxOrderByAggregateInput
    _min?: GameResultMinOrderByAggregateInput
    _sum?: GameResultSumOrderByAggregateInput
  }

  export type GameResultScalarWhereWithAggregatesInput = {
    AND?: GameResultScalarWhereWithAggregatesInput | GameResultScalarWhereWithAggregatesInput[]
    OR?: GameResultScalarWhereWithAggregatesInput[]
    NOT?: GameResultScalarWhereWithAggregatesInput | GameResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GameResult"> | number
    nonce?: BigIntWithAggregatesFilter<"GameResult"> | bigint | number
    player?: StringWithAggregatesFilter<"GameResult"> | string
    playerMove?: IntWithAggregatesFilter<"GameResult"> | number
    houseMove?: IntWithAggregatesFilter<"GameResult"> | number
    betAmount?: BigIntWithAggregatesFilter<"GameResult"> | bigint | number
    outcome?: IntWithAggregatesFilter<"GameResult"> | number
    payoutAmount?: BigIntWithAggregatesFilter<"GameResult"> | bigint | number
    coinTypeName?: StringWithAggregatesFilter<"GameResult"> | string
    season?: BigIntWithAggregatesFilter<"GameResult"> | bigint | number
    timestamp?: BigIntWithAggregatesFilter<"GameResult"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"GameResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameResult"> | Date | string
    network?: StringWithAggregatesFilter<"GameResult"> | string
  }

  export type PoolsDBWhereInput = {
    AND?: PoolsDBWhereInput | PoolsDBWhereInput[]
    OR?: PoolsDBWhereInput[]
    NOT?: PoolsDBWhereInput | PoolsDBWhereInput[]
    id?: IntFilter<"PoolsDB"> | number
    description?: StringFilter<"PoolsDB"> | string
    dev?: StringFilter<"PoolsDB"> | string
    initialVirtualSupraReserves?: BigIntFilter<"PoolsDB"> | bigint | number
    initialVirtualTokenReserves?: BigIntFilter<"PoolsDB"> | bigint | number
    name?: StringFilter<"PoolsDB"> | string
    platformFee?: IntFilter<"PoolsDB"> | number
    pool?: StringFilter<"PoolsDB"> | string
    symbol?: StringFilter<"PoolsDB"> | string
    telegram?: StringFilter<"PoolsDB"> | string
    tokenAddress?: StringFilter<"PoolsDB"> | string
    tokenDecimals?: IntFilter<"PoolsDB"> | number
    twitter?: StringFilter<"PoolsDB"> | string
    uri?: StringFilter<"PoolsDB"> | string
    website?: StringFilter<"PoolsDB"> | string
    createdAt?: DateTimeFilter<"PoolsDB"> | Date | string
    updatedAt?: DateTimeFilter<"PoolsDB"> | Date | string
    network?: StringFilter<"PoolsDB"> | string
    displayOrder?: IntNullableFilter<"PoolsDB"> | number | null
    github?: StringNullableFilter<"PoolsDB"> | string | null
    stream?: StringNullableFilter<"PoolsDB"> | string | null
    unstakePeriodSeconds?: BigIntNullableFilter<"PoolsDB"> | bigint | number | null
    project_type?: StringNullableFilter<"PoolsDB"> | string | null
    comments?: CommentsListRelationFilter
    trust_pools?: XOR<Trust_poolsNullableScalarRelationFilter, trust_poolsWhereInput> | null
    holders?: Token_holdersListRelationFilter
  }

  export type PoolsDBOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    dev?: SortOrder
    initialVirtualSupraReserves?: SortOrder
    initialVirtualTokenReserves?: SortOrder
    name?: SortOrder
    platformFee?: SortOrder
    pool?: SortOrder
    symbol?: SortOrder
    telegram?: SortOrder
    tokenAddress?: SortOrder
    tokenDecimals?: SortOrder
    twitter?: SortOrder
    uri?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    stream?: SortOrderInput | SortOrder
    unstakePeriodSeconds?: SortOrderInput | SortOrder
    project_type?: SortOrderInput | SortOrder
    comments?: commentsOrderByRelationAggregateInput
    trust_pools?: trust_poolsOrderByWithRelationInput
    holders?: token_holdersOrderByRelationAggregateInput
  }

  export type PoolsDBWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_id?: PoolsDBNetworkIdCompoundUniqueInput
    network_tokenAddress?: PoolsDBNetworkTokenAddressCompoundUniqueInput
    AND?: PoolsDBWhereInput | PoolsDBWhereInput[]
    OR?: PoolsDBWhereInput[]
    NOT?: PoolsDBWhereInput | PoolsDBWhereInput[]
    description?: StringFilter<"PoolsDB"> | string
    dev?: StringFilter<"PoolsDB"> | string
    initialVirtualSupraReserves?: BigIntFilter<"PoolsDB"> | bigint | number
    initialVirtualTokenReserves?: BigIntFilter<"PoolsDB"> | bigint | number
    name?: StringFilter<"PoolsDB"> | string
    platformFee?: IntFilter<"PoolsDB"> | number
    pool?: StringFilter<"PoolsDB"> | string
    symbol?: StringFilter<"PoolsDB"> | string
    telegram?: StringFilter<"PoolsDB"> | string
    tokenAddress?: StringFilter<"PoolsDB"> | string
    tokenDecimals?: IntFilter<"PoolsDB"> | number
    twitter?: StringFilter<"PoolsDB"> | string
    uri?: StringFilter<"PoolsDB"> | string
    website?: StringFilter<"PoolsDB"> | string
    createdAt?: DateTimeFilter<"PoolsDB"> | Date | string
    updatedAt?: DateTimeFilter<"PoolsDB"> | Date | string
    network?: StringFilter<"PoolsDB"> | string
    displayOrder?: IntNullableFilter<"PoolsDB"> | number | null
    github?: StringNullableFilter<"PoolsDB"> | string | null
    stream?: StringNullableFilter<"PoolsDB"> | string | null
    unstakePeriodSeconds?: BigIntNullableFilter<"PoolsDB"> | bigint | number | null
    project_type?: StringNullableFilter<"PoolsDB"> | string | null
    comments?: CommentsListRelationFilter
    trust_pools?: XOR<Trust_poolsNullableScalarRelationFilter, trust_poolsWhereInput> | null
    holders?: Token_holdersListRelationFilter
  }, "id" | "network_id" | "network_tokenAddress">

  export type PoolsDBOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    dev?: SortOrder
    initialVirtualSupraReserves?: SortOrder
    initialVirtualTokenReserves?: SortOrder
    name?: SortOrder
    platformFee?: SortOrder
    pool?: SortOrder
    symbol?: SortOrder
    telegram?: SortOrder
    tokenAddress?: SortOrder
    tokenDecimals?: SortOrder
    twitter?: SortOrder
    uri?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    stream?: SortOrderInput | SortOrder
    unstakePeriodSeconds?: SortOrderInput | SortOrder
    project_type?: SortOrderInput | SortOrder
    _count?: PoolsDBCountOrderByAggregateInput
    _avg?: PoolsDBAvgOrderByAggregateInput
    _max?: PoolsDBMaxOrderByAggregateInput
    _min?: PoolsDBMinOrderByAggregateInput
    _sum?: PoolsDBSumOrderByAggregateInput
  }

  export type PoolsDBScalarWhereWithAggregatesInput = {
    AND?: PoolsDBScalarWhereWithAggregatesInput | PoolsDBScalarWhereWithAggregatesInput[]
    OR?: PoolsDBScalarWhereWithAggregatesInput[]
    NOT?: PoolsDBScalarWhereWithAggregatesInput | PoolsDBScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PoolsDB"> | number
    description?: StringWithAggregatesFilter<"PoolsDB"> | string
    dev?: StringWithAggregatesFilter<"PoolsDB"> | string
    initialVirtualSupraReserves?: BigIntWithAggregatesFilter<"PoolsDB"> | bigint | number
    initialVirtualTokenReserves?: BigIntWithAggregatesFilter<"PoolsDB"> | bigint | number
    name?: StringWithAggregatesFilter<"PoolsDB"> | string
    platformFee?: IntWithAggregatesFilter<"PoolsDB"> | number
    pool?: StringWithAggregatesFilter<"PoolsDB"> | string
    symbol?: StringWithAggregatesFilter<"PoolsDB"> | string
    telegram?: StringWithAggregatesFilter<"PoolsDB"> | string
    tokenAddress?: StringWithAggregatesFilter<"PoolsDB"> | string
    tokenDecimals?: IntWithAggregatesFilter<"PoolsDB"> | number
    twitter?: StringWithAggregatesFilter<"PoolsDB"> | string
    uri?: StringWithAggregatesFilter<"PoolsDB"> | string
    website?: StringWithAggregatesFilter<"PoolsDB"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PoolsDB"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PoolsDB"> | Date | string
    network?: StringWithAggregatesFilter<"PoolsDB"> | string
    displayOrder?: IntNullableWithAggregatesFilter<"PoolsDB"> | number | null
    github?: StringNullableWithAggregatesFilter<"PoolsDB"> | string | null
    stream?: StringNullableWithAggregatesFilter<"PoolsDB"> | string | null
    unstakePeriodSeconds?: BigIntNullableWithAggregatesFilter<"PoolsDB"> | bigint | number | null
    project_type?: StringNullableWithAggregatesFilter<"PoolsDB"> | string | null
  }

  export type TradeEventWhereInput = {
    AND?: TradeEventWhereInput | TradeEventWhereInput[]
    OR?: TradeEventWhereInput[]
    NOT?: TradeEventWhereInput | TradeEventWhereInput[]
    id?: IntFilter<"TradeEvent"> | number
    type?: StringFilter<"TradeEvent"> | string
    creationNumber?: StringFilter<"TradeEvent"> | string
    accountAddress?: StringFilter<"TradeEvent"> | string
    sequenceNumber?: StringFilter<"TradeEvent"> | string
    timestamp?: BigIntFilter<"TradeEvent"> | bigint | number
    isBuy?: BoolFilter<"TradeEvent"> | boolean
    supraAmount?: BigIntFilter<"TradeEvent"> | bigint | number
    tokenAddress?: StringFilter<"TradeEvent"> | string
    tokenAmount?: BigIntFilter<"TradeEvent"> | bigint | number
    user?: StringFilter<"TradeEvent"> | string
    virtualSupraReserves?: BigIntFilter<"TradeEvent"> | bigint | number
    virtualTokenReserves?: BigIntFilter<"TradeEvent"> | bigint | number
    createdAt?: DateTimeFilter<"TradeEvent"> | Date | string
    updatedAt?: DateTimeFilter<"TradeEvent"> | Date | string
    network?: StringFilter<"TradeEvent"> | string
    processedForOHLC?: BoolFilter<"TradeEvent"> | boolean
  }

  export type TradeEventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    creationNumber?: SortOrder
    accountAddress?: SortOrder
    sequenceNumber?: SortOrder
    timestamp?: SortOrder
    isBuy?: SortOrder
    supraAmount?: SortOrder
    tokenAddress?: SortOrder
    tokenAmount?: SortOrder
    user?: SortOrder
    virtualSupraReserves?: SortOrder
    virtualTokenReserves?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    processedForOHLC?: SortOrder
  }

  export type TradeEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_creationNumber_sequenceNumber_type?: TradeEventNetworkCreationNumberSequenceNumberTypeCompoundUniqueInput
    AND?: TradeEventWhereInput | TradeEventWhereInput[]
    OR?: TradeEventWhereInput[]
    NOT?: TradeEventWhereInput | TradeEventWhereInput[]
    type?: StringFilter<"TradeEvent"> | string
    creationNumber?: StringFilter<"TradeEvent"> | string
    accountAddress?: StringFilter<"TradeEvent"> | string
    sequenceNumber?: StringFilter<"TradeEvent"> | string
    timestamp?: BigIntFilter<"TradeEvent"> | bigint | number
    isBuy?: BoolFilter<"TradeEvent"> | boolean
    supraAmount?: BigIntFilter<"TradeEvent"> | bigint | number
    tokenAddress?: StringFilter<"TradeEvent"> | string
    tokenAmount?: BigIntFilter<"TradeEvent"> | bigint | number
    user?: StringFilter<"TradeEvent"> | string
    virtualSupraReserves?: BigIntFilter<"TradeEvent"> | bigint | number
    virtualTokenReserves?: BigIntFilter<"TradeEvent"> | bigint | number
    createdAt?: DateTimeFilter<"TradeEvent"> | Date | string
    updatedAt?: DateTimeFilter<"TradeEvent"> | Date | string
    network?: StringFilter<"TradeEvent"> | string
    processedForOHLC?: BoolFilter<"TradeEvent"> | boolean
  }, "id" | "network_creationNumber_sequenceNumber_type">

  export type TradeEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    creationNumber?: SortOrder
    accountAddress?: SortOrder
    sequenceNumber?: SortOrder
    timestamp?: SortOrder
    isBuy?: SortOrder
    supraAmount?: SortOrder
    tokenAddress?: SortOrder
    tokenAmount?: SortOrder
    user?: SortOrder
    virtualSupraReserves?: SortOrder
    virtualTokenReserves?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    processedForOHLC?: SortOrder
    _count?: TradeEventCountOrderByAggregateInput
    _avg?: TradeEventAvgOrderByAggregateInput
    _max?: TradeEventMaxOrderByAggregateInput
    _min?: TradeEventMinOrderByAggregateInput
    _sum?: TradeEventSumOrderByAggregateInput
  }

  export type TradeEventScalarWhereWithAggregatesInput = {
    AND?: TradeEventScalarWhereWithAggregatesInput | TradeEventScalarWhereWithAggregatesInput[]
    OR?: TradeEventScalarWhereWithAggregatesInput[]
    NOT?: TradeEventScalarWhereWithAggregatesInput | TradeEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TradeEvent"> | number
    type?: StringWithAggregatesFilter<"TradeEvent"> | string
    creationNumber?: StringWithAggregatesFilter<"TradeEvent"> | string
    accountAddress?: StringWithAggregatesFilter<"TradeEvent"> | string
    sequenceNumber?: StringWithAggregatesFilter<"TradeEvent"> | string
    timestamp?: BigIntWithAggregatesFilter<"TradeEvent"> | bigint | number
    isBuy?: BoolWithAggregatesFilter<"TradeEvent"> | boolean
    supraAmount?: BigIntWithAggregatesFilter<"TradeEvent"> | bigint | number
    tokenAddress?: StringWithAggregatesFilter<"TradeEvent"> | string
    tokenAmount?: BigIntWithAggregatesFilter<"TradeEvent"> | bigint | number
    user?: StringWithAggregatesFilter<"TradeEvent"> | string
    virtualSupraReserves?: BigIntWithAggregatesFilter<"TradeEvent"> | bigint | number
    virtualTokenReserves?: BigIntWithAggregatesFilter<"TradeEvent"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"TradeEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TradeEvent"> | Date | string
    network?: StringWithAggregatesFilter<"TradeEvent"> | string
    processedForOHLC?: BoolWithAggregatesFilter<"TradeEvent"> | boolean
  }

  export type VRFCallbackWhereInput = {
    AND?: VRFCallbackWhereInput | VRFCallbackWhereInput[]
    OR?: VRFCallbackWhereInput[]
    NOT?: VRFCallbackWhereInput | VRFCallbackWhereInput[]
    id?: IntFilter<"VRFCallback"> | number
    callerAddress?: StringFilter<"VRFCallback"> | string
    nonce?: StringFilter<"VRFCallback"> | string
    randomNumbers?: StringNullableListFilter<"VRFCallback">
    timestamp?: BigIntFilter<"VRFCallback"> | bigint | number
    createdAt?: DateTimeFilter<"VRFCallback"> | Date | string
    updatedAt?: DateTimeFilter<"VRFCallback"> | Date | string
    network?: StringFilter<"VRFCallback"> | string
  }

  export type VRFCallbackOrderByWithRelationInput = {
    id?: SortOrder
    callerAddress?: SortOrder
    nonce?: SortOrder
    randomNumbers?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
  }

  export type VRFCallbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_callerAddress_nonce?: VRFCallbackNetworkCallerAddressNonceCompoundUniqueInput
    AND?: VRFCallbackWhereInput | VRFCallbackWhereInput[]
    OR?: VRFCallbackWhereInput[]
    NOT?: VRFCallbackWhereInput | VRFCallbackWhereInput[]
    callerAddress?: StringFilter<"VRFCallback"> | string
    nonce?: StringFilter<"VRFCallback"> | string
    randomNumbers?: StringNullableListFilter<"VRFCallback">
    timestamp?: BigIntFilter<"VRFCallback"> | bigint | number
    createdAt?: DateTimeFilter<"VRFCallback"> | Date | string
    updatedAt?: DateTimeFilter<"VRFCallback"> | Date | string
    network?: StringFilter<"VRFCallback"> | string
  }, "id" | "network_callerAddress_nonce">

  export type VRFCallbackOrderByWithAggregationInput = {
    id?: SortOrder
    callerAddress?: SortOrder
    nonce?: SortOrder
    randomNumbers?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    _count?: VRFCallbackCountOrderByAggregateInput
    _avg?: VRFCallbackAvgOrderByAggregateInput
    _max?: VRFCallbackMaxOrderByAggregateInput
    _min?: VRFCallbackMinOrderByAggregateInput
    _sum?: VRFCallbackSumOrderByAggregateInput
  }

  export type VRFCallbackScalarWhereWithAggregatesInput = {
    AND?: VRFCallbackScalarWhereWithAggregatesInput | VRFCallbackScalarWhereWithAggregatesInput[]
    OR?: VRFCallbackScalarWhereWithAggregatesInput[]
    NOT?: VRFCallbackScalarWhereWithAggregatesInput | VRFCallbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VRFCallback"> | number
    callerAddress?: StringWithAggregatesFilter<"VRFCallback"> | string
    nonce?: StringWithAggregatesFilter<"VRFCallback"> | string
    randomNumbers?: StringNullableListFilter<"VRFCallback">
    timestamp?: BigIntWithAggregatesFilter<"VRFCallback"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"VRFCallback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VRFCallback"> | Date | string
    network?: StringWithAggregatesFilter<"VRFCallback"> | string
  }

  export type block_progressWhereInput = {
    AND?: block_progressWhereInput | block_progressWhereInput[]
    OR?: block_progressWhereInput[]
    NOT?: block_progressWhereInput | block_progressWhereInput[]
    network?: StringFilter<"block_progress"> | string
    lastBlockHeight?: BigIntFilter<"block_progress"> | bigint | number
    updatedAt?: DateTimeFilter<"block_progress"> | Date | string
  }

  export type block_progressOrderByWithRelationInput = {
    network?: SortOrder
    lastBlockHeight?: SortOrder
    updatedAt?: SortOrder
  }

  export type block_progressWhereUniqueInput = Prisma.AtLeast<{
    network?: string
    AND?: block_progressWhereInput | block_progressWhereInput[]
    OR?: block_progressWhereInput[]
    NOT?: block_progressWhereInput | block_progressWhereInput[]
    lastBlockHeight?: BigIntFilter<"block_progress"> | bigint | number
    updatedAt?: DateTimeFilter<"block_progress"> | Date | string
  }, "network">

  export type block_progressOrderByWithAggregationInput = {
    network?: SortOrder
    lastBlockHeight?: SortOrder
    updatedAt?: SortOrder
    _count?: block_progressCountOrderByAggregateInput
    _avg?: block_progressAvgOrderByAggregateInput
    _max?: block_progressMaxOrderByAggregateInput
    _min?: block_progressMinOrderByAggregateInput
    _sum?: block_progressSumOrderByAggregateInput
  }

  export type block_progressScalarWhereWithAggregatesInput = {
    AND?: block_progressScalarWhereWithAggregatesInput | block_progressScalarWhereWithAggregatesInput[]
    OR?: block_progressScalarWhereWithAggregatesInput[]
    NOT?: block_progressScalarWhereWithAggregatesInput | block_progressScalarWhereWithAggregatesInput[]
    network?: StringWithAggregatesFilter<"block_progress"> | string
    lastBlockHeight?: BigIntWithAggregatesFilter<"block_progress"> | bigint | number
    updatedAt?: DateTimeWithAggregatesFilter<"block_progress"> | Date | string
  }

  export type commentsWhereInput = {
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    id?: IntFilter<"comments"> | number
    text?: StringFilter<"comments"> | string
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
    poolId?: IntFilter<"comments"> | number
    network?: StringFilter<"comments"> | string
    userNetwork?: StringFilter<"comments"> | string
    userWalletAddress?: StringFilter<"comments"> | string
    displayOrder?: IntNullableFilter<"comments"> | number | null
    likeCount?: IntFilter<"comments"> | number
    poolNetwork?: StringFilter<"comments"> | string
    PoolsDB?: XOR<PoolsDBScalarRelationFilter, PoolsDBWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    images?: ImagesListRelationFilter
    likes?: LikesListRelationFilter
  }

  export type commentsOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    poolId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    likeCount?: SortOrder
    poolNetwork?: SortOrder
    PoolsDB?: PoolsDBOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    images?: imagesOrderByRelationAggregateInput
    likes?: likesOrderByRelationAggregateInput
  }

  export type commentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    text?: StringFilter<"comments"> | string
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
    poolId?: IntFilter<"comments"> | number
    network?: StringFilter<"comments"> | string
    userNetwork?: StringFilter<"comments"> | string
    userWalletAddress?: StringFilter<"comments"> | string
    displayOrder?: IntNullableFilter<"comments"> | number | null
    likeCount?: IntFilter<"comments"> | number
    poolNetwork?: StringFilter<"comments"> | string
    PoolsDB?: XOR<PoolsDBScalarRelationFilter, PoolsDBWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    images?: ImagesListRelationFilter
    likes?: LikesListRelationFilter
  }, "id">

  export type commentsOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    poolId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    likeCount?: SortOrder
    poolNetwork?: SortOrder
    _count?: commentsCountOrderByAggregateInput
    _avg?: commentsAvgOrderByAggregateInput
    _max?: commentsMaxOrderByAggregateInput
    _min?: commentsMinOrderByAggregateInput
    _sum?: commentsSumOrderByAggregateInput
  }

  export type commentsScalarWhereWithAggregatesInput = {
    AND?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    OR?: commentsScalarWhereWithAggregatesInput[]
    NOT?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"comments"> | number
    text?: StringWithAggregatesFilter<"comments"> | string
    createdAt?: DateTimeWithAggregatesFilter<"comments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"comments"> | Date | string
    poolId?: IntWithAggregatesFilter<"comments"> | number
    network?: StringWithAggregatesFilter<"comments"> | string
    userNetwork?: StringWithAggregatesFilter<"comments"> | string
    userWalletAddress?: StringWithAggregatesFilter<"comments"> | string
    displayOrder?: IntNullableWithAggregatesFilter<"comments"> | number | null
    likeCount?: IntWithAggregatesFilter<"comments"> | number
    poolNetwork?: StringWithAggregatesFilter<"comments"> | string
  }

  export type imagesWhereInput = {
    AND?: imagesWhereInput | imagesWhereInput[]
    OR?: imagesWhereInput[]
    NOT?: imagesWhereInput | imagesWhereInput[]
    id?: IntFilter<"images"> | number
    url?: StringFilter<"images"> | string
    altText?: StringNullableFilter<"images"> | string | null
    createdAt?: DateTimeFilter<"images"> | Date | string
    commentId?: IntFilter<"images"> | number
    comments?: XOR<CommentsScalarRelationFilter, commentsWhereInput>
  }

  export type imagesOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    comments?: commentsOrderByWithRelationInput
  }

  export type imagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: imagesWhereInput | imagesWhereInput[]
    OR?: imagesWhereInput[]
    NOT?: imagesWhereInput | imagesWhereInput[]
    url?: StringFilter<"images"> | string
    altText?: StringNullableFilter<"images"> | string | null
    createdAt?: DateTimeFilter<"images"> | Date | string
    commentId?: IntFilter<"images"> | number
    comments?: XOR<CommentsScalarRelationFilter, commentsWhereInput>
  }, "id">

  export type imagesOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    _count?: imagesCountOrderByAggregateInput
    _avg?: imagesAvgOrderByAggregateInput
    _max?: imagesMaxOrderByAggregateInput
    _min?: imagesMinOrderByAggregateInput
    _sum?: imagesSumOrderByAggregateInput
  }

  export type imagesScalarWhereWithAggregatesInput = {
    AND?: imagesScalarWhereWithAggregatesInput | imagesScalarWhereWithAggregatesInput[]
    OR?: imagesScalarWhereWithAggregatesInput[]
    NOT?: imagesScalarWhereWithAggregatesInput | imagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"images"> | number
    url?: StringWithAggregatesFilter<"images"> | string
    altText?: StringNullableWithAggregatesFilter<"images"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"images"> | Date | string
    commentId?: IntWithAggregatesFilter<"images"> | number
  }

  export type likesWhereInput = {
    AND?: likesWhereInput | likesWhereInput[]
    OR?: likesWhereInput[]
    NOT?: likesWhereInput | likesWhereInput[]
    id?: IntFilter<"likes"> | number
    createdAt?: DateTimeFilter<"likes"> | Date | string
    commentId?: IntFilter<"likes"> | number
    network?: StringFilter<"likes"> | string
    userNetwork?: StringFilter<"likes"> | string
    userWalletAddress?: StringFilter<"likes"> | string
    comments?: XOR<CommentsScalarRelationFilter, commentsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type likesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
    comments?: commentsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type likesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userNetwork_userWalletAddress_commentId?: likesUserNetworkUserWalletAddressCommentIdCompoundUniqueInput
    AND?: likesWhereInput | likesWhereInput[]
    OR?: likesWhereInput[]
    NOT?: likesWhereInput | likesWhereInput[]
    createdAt?: DateTimeFilter<"likes"> | Date | string
    commentId?: IntFilter<"likes"> | number
    network?: StringFilter<"likes"> | string
    userNetwork?: StringFilter<"likes"> | string
    userWalletAddress?: StringFilter<"likes"> | string
    comments?: XOR<CommentsScalarRelationFilter, commentsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "userNetwork_userWalletAddress_commentId">

  export type likesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
    _count?: likesCountOrderByAggregateInput
    _avg?: likesAvgOrderByAggregateInput
    _max?: likesMaxOrderByAggregateInput
    _min?: likesMinOrderByAggregateInput
    _sum?: likesSumOrderByAggregateInput
  }

  export type likesScalarWhereWithAggregatesInput = {
    AND?: likesScalarWhereWithAggregatesInput | likesScalarWhereWithAggregatesInput[]
    OR?: likesScalarWhereWithAggregatesInput[]
    NOT?: likesScalarWhereWithAggregatesInput | likesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"likes"> | number
    createdAt?: DateTimeWithAggregatesFilter<"likes"> | Date | string
    commentId?: IntWithAggregatesFilter<"likes"> | number
    network?: StringWithAggregatesFilter<"likes"> | string
    userNetwork?: StringWithAggregatesFilter<"likes"> | string
    userWalletAddress?: StringWithAggregatesFilter<"likes"> | string
  }

  export type migration_eventsWhereInput = {
    AND?: migration_eventsWhereInput | migration_eventsWhereInput[]
    OR?: migration_eventsWhereInput[]
    NOT?: migration_eventsWhereInput | migration_eventsWhereInput[]
    id?: IntFilter<"migration_events"> | number
    network?: StringFilter<"migration_events"> | string
    transactionHash?: StringFilter<"migration_events"> | string
    sequenceNumber?: StringFilter<"migration_events"> | string
    token_address?: StringFilter<"migration_events"> | string
    migrator?: StringFilter<"migration_events"> | string
    supra_sent_to_lp?: BigIntFilter<"migration_events"> | bigint | number
    tokens_sent_to_lp?: BigIntFilter<"migration_events"> | bigint | number
    dev_reward_staked?: BigIntFilter<"migration_events"> | bigint | number
    staking_pool_reward?: BigIntFilter<"migration_events"> | bigint | number
    migrator_reward?: BigIntFilter<"migration_events"> | bigint | number
    excess_supra_collected?: BigIntFilter<"migration_events"> | bigint | number
    createdAt?: DateTimeFilter<"migration_events"> | Date | string
  }

  export type migration_eventsOrderByWithRelationInput = {
    id?: SortOrder
    network?: SortOrder
    transactionHash?: SortOrder
    sequenceNumber?: SortOrder
    token_address?: SortOrder
    migrator?: SortOrder
    supra_sent_to_lp?: SortOrder
    tokens_sent_to_lp?: SortOrder
    dev_reward_staked?: SortOrder
    staking_pool_reward?: SortOrder
    migrator_reward?: SortOrder
    excess_supra_collected?: SortOrder
    createdAt?: SortOrder
  }

  export type migration_eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_transactionHash_sequenceNumber?: migration_eventsNetworkTransactionHashSequenceNumberCompoundUniqueInput
    AND?: migration_eventsWhereInput | migration_eventsWhereInput[]
    OR?: migration_eventsWhereInput[]
    NOT?: migration_eventsWhereInput | migration_eventsWhereInput[]
    network?: StringFilter<"migration_events"> | string
    transactionHash?: StringFilter<"migration_events"> | string
    sequenceNumber?: StringFilter<"migration_events"> | string
    token_address?: StringFilter<"migration_events"> | string
    migrator?: StringFilter<"migration_events"> | string
    supra_sent_to_lp?: BigIntFilter<"migration_events"> | bigint | number
    tokens_sent_to_lp?: BigIntFilter<"migration_events"> | bigint | number
    dev_reward_staked?: BigIntFilter<"migration_events"> | bigint | number
    staking_pool_reward?: BigIntFilter<"migration_events"> | bigint | number
    migrator_reward?: BigIntFilter<"migration_events"> | bigint | number
    excess_supra_collected?: BigIntFilter<"migration_events"> | bigint | number
    createdAt?: DateTimeFilter<"migration_events"> | Date | string
  }, "id" | "network_transactionHash_sequenceNumber">

  export type migration_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    network?: SortOrder
    transactionHash?: SortOrder
    sequenceNumber?: SortOrder
    token_address?: SortOrder
    migrator?: SortOrder
    supra_sent_to_lp?: SortOrder
    tokens_sent_to_lp?: SortOrder
    dev_reward_staked?: SortOrder
    staking_pool_reward?: SortOrder
    migrator_reward?: SortOrder
    excess_supra_collected?: SortOrder
    createdAt?: SortOrder
    _count?: migration_eventsCountOrderByAggregateInput
    _avg?: migration_eventsAvgOrderByAggregateInput
    _max?: migration_eventsMaxOrderByAggregateInput
    _min?: migration_eventsMinOrderByAggregateInput
    _sum?: migration_eventsSumOrderByAggregateInput
  }

  export type migration_eventsScalarWhereWithAggregatesInput = {
    AND?: migration_eventsScalarWhereWithAggregatesInput | migration_eventsScalarWhereWithAggregatesInput[]
    OR?: migration_eventsScalarWhereWithAggregatesInput[]
    NOT?: migration_eventsScalarWhereWithAggregatesInput | migration_eventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migration_events"> | number
    network?: StringWithAggregatesFilter<"migration_events"> | string
    transactionHash?: StringWithAggregatesFilter<"migration_events"> | string
    sequenceNumber?: StringWithAggregatesFilter<"migration_events"> | string
    token_address?: StringWithAggregatesFilter<"migration_events"> | string
    migrator?: StringWithAggregatesFilter<"migration_events"> | string
    supra_sent_to_lp?: BigIntWithAggregatesFilter<"migration_events"> | bigint | number
    tokens_sent_to_lp?: BigIntWithAggregatesFilter<"migration_events"> | bigint | number
    dev_reward_staked?: BigIntWithAggregatesFilter<"migration_events"> | bigint | number
    staking_pool_reward?: BigIntWithAggregatesFilter<"migration_events"> | bigint | number
    migrator_reward?: BigIntWithAggregatesFilter<"migration_events"> | bigint | number
    excess_supra_collected?: BigIntWithAggregatesFilter<"migration_events"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"migration_events"> | Date | string
  }

  export type protocol_statsWhereInput = {
    AND?: protocol_statsWhereInput | protocol_statsWhereInput[]
    OR?: protocol_statsWhereInput[]
    NOT?: protocol_statsWhereInput | protocol_statsWhereInput[]
    id?: IntFilter<"protocol_stats"> | number
    network?: StringFilter<"protocol_stats"> | string
    timestamp?: DateTimeFilter<"protocol_stats"> | Date | string
    totalTvlUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: IntNullableFilter<"protocol_stats"> | number | null
    totalFeesEarnedUsd24h?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
  }

  export type protocol_statsOrderByWithRelationInput = {
    id?: SortOrder
    network?: SortOrder
    timestamp?: SortOrder
    totalTvlUsd?: SortOrderInput | SortOrder
    ammTvlUsd?: SortOrderInput | SortOrder
    virtualPoolsTvlUsd?: SortOrderInput | SortOrder
    stakingTvlUsd?: SortOrderInput | SortOrder
    totalVolume24hUsd?: SortOrderInput | SortOrder
    ammVolume24hUsd?: SortOrderInput | SortOrder
    totalUniqueUsers?: SortOrderInput | SortOrder
    totalFeesEarnedUsd24h?: SortOrderInput | SortOrder
  }

  export type protocol_statsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_timestamp?: protocol_statsNetworkTimestampCompoundUniqueInput
    AND?: protocol_statsWhereInput | protocol_statsWhereInput[]
    OR?: protocol_statsWhereInput[]
    NOT?: protocol_statsWhereInput | protocol_statsWhereInput[]
    network?: StringFilter<"protocol_stats"> | string
    timestamp?: DateTimeFilter<"protocol_stats"> | Date | string
    totalTvlUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: IntNullableFilter<"protocol_stats"> | number | null
    totalFeesEarnedUsd24h?: DecimalNullableFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
  }, "id" | "network_timestamp">

  export type protocol_statsOrderByWithAggregationInput = {
    id?: SortOrder
    network?: SortOrder
    timestamp?: SortOrder
    totalTvlUsd?: SortOrderInput | SortOrder
    ammTvlUsd?: SortOrderInput | SortOrder
    virtualPoolsTvlUsd?: SortOrderInput | SortOrder
    stakingTvlUsd?: SortOrderInput | SortOrder
    totalVolume24hUsd?: SortOrderInput | SortOrder
    ammVolume24hUsd?: SortOrderInput | SortOrder
    totalUniqueUsers?: SortOrderInput | SortOrder
    totalFeesEarnedUsd24h?: SortOrderInput | SortOrder
    _count?: protocol_statsCountOrderByAggregateInput
    _avg?: protocol_statsAvgOrderByAggregateInput
    _max?: protocol_statsMaxOrderByAggregateInput
    _min?: protocol_statsMinOrderByAggregateInput
    _sum?: protocol_statsSumOrderByAggregateInput
  }

  export type protocol_statsScalarWhereWithAggregatesInput = {
    AND?: protocol_statsScalarWhereWithAggregatesInput | protocol_statsScalarWhereWithAggregatesInput[]
    OR?: protocol_statsScalarWhereWithAggregatesInput[]
    NOT?: protocol_statsScalarWhereWithAggregatesInput | protocol_statsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"protocol_stats"> | number
    network?: StringWithAggregatesFilter<"protocol_stats"> | string
    timestamp?: DateTimeWithAggregatesFilter<"protocol_stats"> | Date | string
    totalTvlUsd?: DecimalNullableWithAggregatesFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: DecimalNullableWithAggregatesFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: DecimalNullableWithAggregatesFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: DecimalNullableWithAggregatesFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: DecimalNullableWithAggregatesFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: DecimalNullableWithAggregatesFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: IntNullableWithAggregatesFilter<"protocol_stats"> | number | null
    totalFeesEarnedUsd24h?: DecimalNullableWithAggregatesFilter<"protocol_stats"> | Decimal | DecimalJsLike | number | string | null
  }

  export type staking_poolsWhereInput = {
    AND?: staking_poolsWhereInput | staking_poolsWhereInput[]
    OR?: staking_poolsWhereInput[]
    NOT?: staking_poolsWhereInput | staking_poolsWhereInput[]
    id?: IntFilter<"staking_pools"> | number
    creatorAddress?: StringFilter<"staking_pools"> | string
    stakeTokenAddress?: StringFilter<"staking_pools"> | string
    rewardTokenAddress?: StringFilter<"staking_pools"> | string
    isDynamicPool?: BoolFilter<"staking_pools"> | boolean
    rewardPerSec?: StringFilter<"staking_pools"> | string
    accumReward?: StringFilter<"staking_pools"> | string
    lastUpdatedTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    startTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    endTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    emergencyLocked?: BoolFilter<"staking_pools"> | boolean
    stakesClosed?: BoolFilter<"staking_pools"> | boolean
    createdAt?: DateTimeFilter<"staking_pools"> | Date | string
    updatedAt?: DateTimeFilter<"staking_pools"> | Date | string
    creatorNetwork?: StringFilter<"staking_pools"> | string
    network?: StringFilter<"staking_pools"> | string
    rewardTokenNetwork?: StringFilter<"staking_pools"> | string
    stakeTokenNetwork?: StringFilter<"staking_pools"> | string
    boostEnabled?: BoolFilter<"staking_pools"> | boolean
    initialEndTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    initialRewardPerSec?: StringFilter<"staking_pools"> | string
    verified?: BoolFilter<"staking_pools"> | boolean
    totalBoosted?: StringFilter<"staking_pools"> | string
    displayOrder?: IntNullableFilter<"staking_pools"> | number | null
    cachedApy?: StringNullableFilter<"staking_pools"> | string | null
    cachedStakerCount?: IntNullableFilter<"staking_pools"> | number | null
    cachedTvlUsd?: StringNullableFilter<"staking_pools"> | string | null
    poolType?: EnumPoolTypeFilter<"staking_pools"> | $Enums.PoolType
    totalStakedAmount?: StringFilter<"staking_pools"> | string
    boostConfigCollectionName?: StringNullableFilter<"staking_pools"> | string | null
    boostConfigCollectionOwner?: StringNullableFilter<"staking_pools"> | string | null
    boostConfigPercent?: StringNullableFilter<"staking_pools"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: XOR<TokensScalarRelationFilter, tokensWhereInput>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: XOR<TokensScalarRelationFilter, tokensWhereInput>
    user_stakes?: User_stakesListRelationFilter
  }

  export type staking_poolsOrderByWithRelationInput = {
    id?: SortOrder
    creatorAddress?: SortOrder
    stakeTokenAddress?: SortOrder
    rewardTokenAddress?: SortOrder
    isDynamicPool?: SortOrder
    rewardPerSec?: SortOrder
    accumReward?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    emergencyLocked?: SortOrder
    stakesClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorNetwork?: SortOrder
    network?: SortOrder
    rewardTokenNetwork?: SortOrder
    stakeTokenNetwork?: SortOrder
    boostEnabled?: SortOrder
    initialEndTimestamp?: SortOrder
    initialRewardPerSec?: SortOrder
    verified?: SortOrder
    totalBoosted?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    cachedApy?: SortOrderInput | SortOrder
    cachedStakerCount?: SortOrderInput | SortOrder
    cachedTvlUsd?: SortOrderInput | SortOrder
    poolType?: SortOrder
    totalStakedAmount?: SortOrder
    boostConfigCollectionName?: SortOrderInput | SortOrder
    boostConfigCollectionOwner?: SortOrderInput | SortOrder
    boostConfigPercent?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: tokensOrderByWithRelationInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: tokensOrderByWithRelationInput
    user_stakes?: user_stakesOrderByRelationAggregateInput
  }

  export type staking_poolsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_creatorAddress_stakeTokenAddress_rewardTokenAddress?: staking_poolsNetworkCreatorAddressStakeTokenAddressRewardTokenAddressCompoundUniqueInput
    AND?: staking_poolsWhereInput | staking_poolsWhereInput[]
    OR?: staking_poolsWhereInput[]
    NOT?: staking_poolsWhereInput | staking_poolsWhereInput[]
    creatorAddress?: StringFilter<"staking_pools"> | string
    stakeTokenAddress?: StringFilter<"staking_pools"> | string
    rewardTokenAddress?: StringFilter<"staking_pools"> | string
    isDynamicPool?: BoolFilter<"staking_pools"> | boolean
    rewardPerSec?: StringFilter<"staking_pools"> | string
    accumReward?: StringFilter<"staking_pools"> | string
    lastUpdatedTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    startTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    endTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    emergencyLocked?: BoolFilter<"staking_pools"> | boolean
    stakesClosed?: BoolFilter<"staking_pools"> | boolean
    createdAt?: DateTimeFilter<"staking_pools"> | Date | string
    updatedAt?: DateTimeFilter<"staking_pools"> | Date | string
    creatorNetwork?: StringFilter<"staking_pools"> | string
    network?: StringFilter<"staking_pools"> | string
    rewardTokenNetwork?: StringFilter<"staking_pools"> | string
    stakeTokenNetwork?: StringFilter<"staking_pools"> | string
    boostEnabled?: BoolFilter<"staking_pools"> | boolean
    initialEndTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    initialRewardPerSec?: StringFilter<"staking_pools"> | string
    verified?: BoolFilter<"staking_pools"> | boolean
    totalBoosted?: StringFilter<"staking_pools"> | string
    displayOrder?: IntNullableFilter<"staking_pools"> | number | null
    cachedApy?: StringNullableFilter<"staking_pools"> | string | null
    cachedStakerCount?: IntNullableFilter<"staking_pools"> | number | null
    cachedTvlUsd?: StringNullableFilter<"staking_pools"> | string | null
    poolType?: EnumPoolTypeFilter<"staking_pools"> | $Enums.PoolType
    totalStakedAmount?: StringFilter<"staking_pools"> | string
    boostConfigCollectionName?: StringNullableFilter<"staking_pools"> | string | null
    boostConfigCollectionOwner?: StringNullableFilter<"staking_pools"> | string | null
    boostConfigPercent?: StringNullableFilter<"staking_pools"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: XOR<TokensScalarRelationFilter, tokensWhereInput>
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: XOR<TokensScalarRelationFilter, tokensWhereInput>
    user_stakes?: User_stakesListRelationFilter
  }, "id" | "network_creatorAddress_stakeTokenAddress_rewardTokenAddress">

  export type staking_poolsOrderByWithAggregationInput = {
    id?: SortOrder
    creatorAddress?: SortOrder
    stakeTokenAddress?: SortOrder
    rewardTokenAddress?: SortOrder
    isDynamicPool?: SortOrder
    rewardPerSec?: SortOrder
    accumReward?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    emergencyLocked?: SortOrder
    stakesClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorNetwork?: SortOrder
    network?: SortOrder
    rewardTokenNetwork?: SortOrder
    stakeTokenNetwork?: SortOrder
    boostEnabled?: SortOrder
    initialEndTimestamp?: SortOrder
    initialRewardPerSec?: SortOrder
    verified?: SortOrder
    totalBoosted?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    cachedApy?: SortOrderInput | SortOrder
    cachedStakerCount?: SortOrderInput | SortOrder
    cachedTvlUsd?: SortOrderInput | SortOrder
    poolType?: SortOrder
    totalStakedAmount?: SortOrder
    boostConfigCollectionName?: SortOrderInput | SortOrder
    boostConfigCollectionOwner?: SortOrderInput | SortOrder
    boostConfigPercent?: SortOrderInput | SortOrder
    _count?: staking_poolsCountOrderByAggregateInput
    _avg?: staking_poolsAvgOrderByAggregateInput
    _max?: staking_poolsMaxOrderByAggregateInput
    _min?: staking_poolsMinOrderByAggregateInput
    _sum?: staking_poolsSumOrderByAggregateInput
  }

  export type staking_poolsScalarWhereWithAggregatesInput = {
    AND?: staking_poolsScalarWhereWithAggregatesInput | staking_poolsScalarWhereWithAggregatesInput[]
    OR?: staking_poolsScalarWhereWithAggregatesInput[]
    NOT?: staking_poolsScalarWhereWithAggregatesInput | staking_poolsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"staking_pools"> | number
    creatorAddress?: StringWithAggregatesFilter<"staking_pools"> | string
    stakeTokenAddress?: StringWithAggregatesFilter<"staking_pools"> | string
    rewardTokenAddress?: StringWithAggregatesFilter<"staking_pools"> | string
    isDynamicPool?: BoolWithAggregatesFilter<"staking_pools"> | boolean
    rewardPerSec?: StringWithAggregatesFilter<"staking_pools"> | string
    accumReward?: StringWithAggregatesFilter<"staking_pools"> | string
    lastUpdatedTimestamp?: BigIntWithAggregatesFilter<"staking_pools"> | bigint | number
    startTimestamp?: BigIntWithAggregatesFilter<"staking_pools"> | bigint | number
    endTimestamp?: BigIntWithAggregatesFilter<"staking_pools"> | bigint | number
    emergencyLocked?: BoolWithAggregatesFilter<"staking_pools"> | boolean
    stakesClosed?: BoolWithAggregatesFilter<"staking_pools"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"staking_pools"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"staking_pools"> | Date | string
    creatorNetwork?: StringWithAggregatesFilter<"staking_pools"> | string
    network?: StringWithAggregatesFilter<"staking_pools"> | string
    rewardTokenNetwork?: StringWithAggregatesFilter<"staking_pools"> | string
    stakeTokenNetwork?: StringWithAggregatesFilter<"staking_pools"> | string
    boostEnabled?: BoolWithAggregatesFilter<"staking_pools"> | boolean
    initialEndTimestamp?: BigIntWithAggregatesFilter<"staking_pools"> | bigint | number
    initialRewardPerSec?: StringWithAggregatesFilter<"staking_pools"> | string
    verified?: BoolWithAggregatesFilter<"staking_pools"> | boolean
    totalBoosted?: StringWithAggregatesFilter<"staking_pools"> | string
    displayOrder?: IntNullableWithAggregatesFilter<"staking_pools"> | number | null
    cachedApy?: StringNullableWithAggregatesFilter<"staking_pools"> | string | null
    cachedStakerCount?: IntNullableWithAggregatesFilter<"staking_pools"> | number | null
    cachedTvlUsd?: StringNullableWithAggregatesFilter<"staking_pools"> | string | null
    poolType?: EnumPoolTypeWithAggregatesFilter<"staking_pools"> | $Enums.PoolType
    totalStakedAmount?: StringWithAggregatesFilter<"staking_pools"> | string
    boostConfigCollectionName?: StringNullableWithAggregatesFilter<"staking_pools"> | string | null
    boostConfigCollectionOwner?: StringNullableWithAggregatesFilter<"staking_pools"> | string | null
    boostConfigPercent?: StringNullableWithAggregatesFilter<"staking_pools"> | string | null
  }

  export type token_price_historyWhereInput = {
    AND?: token_price_historyWhereInput | token_price_historyWhereInput[]
    OR?: token_price_historyWhereInput[]
    NOT?: token_price_historyWhereInput | token_price_historyWhereInput[]
    id?: IntFilter<"token_price_history"> | number
    network?: StringFilter<"token_price_history"> | string
    tokenAddress?: StringFilter<"token_price_history"> | string
    timestamp?: BigIntFilter<"token_price_history"> | bigint | number
    granularity?: StringFilter<"token_price_history"> | string
    open?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    volume?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
  }

  export type token_price_historyOrderByWithRelationInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    timestamp?: SortOrder
    granularity?: SortOrder
    open?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    close?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
  }

  export type token_price_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_tokenAddress_timestamp_granularity?: token_price_historyNetworkTokenAddressTimestampGranularityCompoundUniqueInput
    AND?: token_price_historyWhereInput | token_price_historyWhereInput[]
    OR?: token_price_historyWhereInput[]
    NOT?: token_price_historyWhereInput | token_price_historyWhereInput[]
    network?: StringFilter<"token_price_history"> | string
    tokenAddress?: StringFilter<"token_price_history"> | string
    timestamp?: BigIntFilter<"token_price_history"> | bigint | number
    granularity?: StringFilter<"token_price_history"> | string
    open?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    volume?: DecimalNullableFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
  }, "id" | "network_tokenAddress_timestamp_granularity">

  export type token_price_historyOrderByWithAggregationInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    timestamp?: SortOrder
    granularity?: SortOrder
    open?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    close?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    _count?: token_price_historyCountOrderByAggregateInput
    _avg?: token_price_historyAvgOrderByAggregateInput
    _max?: token_price_historyMaxOrderByAggregateInput
    _min?: token_price_historyMinOrderByAggregateInput
    _sum?: token_price_historySumOrderByAggregateInput
  }

  export type token_price_historyScalarWhereWithAggregatesInput = {
    AND?: token_price_historyScalarWhereWithAggregatesInput | token_price_historyScalarWhereWithAggregatesInput[]
    OR?: token_price_historyScalarWhereWithAggregatesInput[]
    NOT?: token_price_historyScalarWhereWithAggregatesInput | token_price_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"token_price_history"> | number
    network?: StringWithAggregatesFilter<"token_price_history"> | string
    tokenAddress?: StringWithAggregatesFilter<"token_price_history"> | string
    timestamp?: BigIntWithAggregatesFilter<"token_price_history"> | bigint | number
    granularity?: StringWithAggregatesFilter<"token_price_history"> | string
    open?: DecimalNullableWithAggregatesFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableWithAggregatesFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableWithAggregatesFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableWithAggregatesFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
    volume?: DecimalNullableWithAggregatesFilter<"token_price_history"> | Decimal | DecimalJsLike | number | string | null
  }

  export type token_pricesWhereInput = {
    AND?: token_pricesWhereInput | token_pricesWhereInput[]
    OR?: token_pricesWhereInput[]
    NOT?: token_pricesWhereInput | token_pricesWhereInput[]
    id?: IntFilter<"token_prices"> | number
    network?: StringFilter<"token_prices"> | string
    tokenAddress?: StringFilter<"token_prices"> | string
    priceUsd?: DecimalNullableFilter<"token_prices"> | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: DecimalNullableFilter<"token_prices"> | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableFilter<"token_prices"> | string | null
    lastUpdatedAt?: DateTimeFilter<"token_prices"> | Date | string
  }

  export type token_pricesOrderByWithRelationInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    priceUsd?: SortOrderInput | SortOrder
    priceAnchor?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    lastUpdatedAt?: SortOrder
  }

  export type token_pricesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    network_tokenAddress?: token_pricesNetworkTokenAddressCompoundUniqueInput
    AND?: token_pricesWhereInput | token_pricesWhereInput[]
    OR?: token_pricesWhereInput[]
    NOT?: token_pricesWhereInput | token_pricesWhereInput[]
    network?: StringFilter<"token_prices"> | string
    tokenAddress?: StringFilter<"token_prices"> | string
    priceUsd?: DecimalNullableFilter<"token_prices"> | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: DecimalNullableFilter<"token_prices"> | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableFilter<"token_prices"> | string | null
    lastUpdatedAt?: DateTimeFilter<"token_prices"> | Date | string
  }, "id" | "network_tokenAddress">

  export type token_pricesOrderByWithAggregationInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    priceUsd?: SortOrderInput | SortOrder
    priceAnchor?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    lastUpdatedAt?: SortOrder
    _count?: token_pricesCountOrderByAggregateInput
    _avg?: token_pricesAvgOrderByAggregateInput
    _max?: token_pricesMaxOrderByAggregateInput
    _min?: token_pricesMinOrderByAggregateInput
    _sum?: token_pricesSumOrderByAggregateInput
  }

  export type token_pricesScalarWhereWithAggregatesInput = {
    AND?: token_pricesScalarWhereWithAggregatesInput | token_pricesScalarWhereWithAggregatesInput[]
    OR?: token_pricesScalarWhereWithAggregatesInput[]
    NOT?: token_pricesScalarWhereWithAggregatesInput | token_pricesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"token_prices"> | number
    network?: StringWithAggregatesFilter<"token_prices"> | string
    tokenAddress?: StringWithAggregatesFilter<"token_prices"> | string
    priceUsd?: DecimalNullableWithAggregatesFilter<"token_prices"> | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: DecimalNullableWithAggregatesFilter<"token_prices"> | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableWithAggregatesFilter<"token_prices"> | string | null
    lastUpdatedAt?: DateTimeWithAggregatesFilter<"token_prices"> | Date | string
  }

  export type tokensWhereInput = {
    AND?: tokensWhereInput | tokensWhereInput[]
    OR?: tokensWhereInput[]
    NOT?: tokensWhereInput | tokensWhereInput[]
    id?: StringFilter<"tokens"> | string
    name?: StringNullableFilter<"tokens"> | string | null
    symbol?: StringNullableFilter<"tokens"> | string | null
    decimals?: IntNullableFilter<"tokens"> | number | null
    iconUri?: StringNullableFilter<"tokens"> | string | null
    projectUri?: StringNullableFilter<"tokens"> | string | null
    network?: StringFilter<"tokens"> | string
    lastMetadataAttempt?: DateTimeNullableFilter<"tokens"> | Date | string | null
    metadataFetched?: BoolFilter<"tokens"> | boolean
    metadataStandard?: StringNullableFilter<"tokens"> | string | null
    verified?: BoolFilter<"tokens"> | boolean
    displayOrder?: IntNullableFilter<"tokens"> | number | null
    originalCoinType?: StringNullableFilter<"tokens"> | string | null
    circulatingSupply?: StringNullableFilter<"tokens"> | string | null
    createdAt?: DateTimeFilter<"tokens"> | Date | string
    marketCapUsd?: StringNullableFilter<"tokens"> | string | null
    priceChange24hPercent?: DecimalNullableFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: DecimalNullableFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: DecimalNullableFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: DateTimeNullableFilter<"tokens"> | Date | string | null
    totalSupply?: StringNullableFilter<"tokens"> | string | null
    updatedAt?: DateTimeFilter<"tokens"> | Date | string
    volume24hUsd?: StringNullableFilter<"tokens"> | string | null
    ammpairsAsToken0?: AmmpairListRelationFilter
    ammpairsAsToken1?: AmmpairListRelationFilter
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: Staking_poolsListRelationFilter
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: Staking_poolsListRelationFilter
  }

  export type tokensOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    decimals?: SortOrderInput | SortOrder
    iconUri?: SortOrderInput | SortOrder
    projectUri?: SortOrderInput | SortOrder
    network?: SortOrder
    lastMetadataAttempt?: SortOrderInput | SortOrder
    metadataFetched?: SortOrder
    metadataStandard?: SortOrderInput | SortOrder
    verified?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    originalCoinType?: SortOrderInput | SortOrder
    circulatingSupply?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    marketCapUsd?: SortOrderInput | SortOrder
    priceChange24hPercent?: SortOrderInput | SortOrder
    priceUsdCurrent?: SortOrderInput | SortOrder
    priceAnchor?: SortOrderInput | SortOrder
    lastPriceUpdate?: SortOrderInput | SortOrder
    totalSupply?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    volume24hUsd?: SortOrderInput | SortOrder
    ammpairsAsToken0?: AmmpairOrderByRelationAggregateInput
    ammpairsAsToken1?: AmmpairOrderByRelationAggregateInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsOrderByRelationAggregateInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsOrderByRelationAggregateInput
  }

  export type tokensWhereUniqueInput = Prisma.AtLeast<{
    network_id?: tokensNetworkIdCompoundUniqueInput
    AND?: tokensWhereInput | tokensWhereInput[]
    OR?: tokensWhereInput[]
    NOT?: tokensWhereInput | tokensWhereInput[]
    id?: StringFilter<"tokens"> | string
    name?: StringNullableFilter<"tokens"> | string | null
    symbol?: StringNullableFilter<"tokens"> | string | null
    decimals?: IntNullableFilter<"tokens"> | number | null
    iconUri?: StringNullableFilter<"tokens"> | string | null
    projectUri?: StringNullableFilter<"tokens"> | string | null
    network?: StringFilter<"tokens"> | string
    lastMetadataAttempt?: DateTimeNullableFilter<"tokens"> | Date | string | null
    metadataFetched?: BoolFilter<"tokens"> | boolean
    metadataStandard?: StringNullableFilter<"tokens"> | string | null
    verified?: BoolFilter<"tokens"> | boolean
    displayOrder?: IntNullableFilter<"tokens"> | number | null
    originalCoinType?: StringNullableFilter<"tokens"> | string | null
    circulatingSupply?: StringNullableFilter<"tokens"> | string | null
    createdAt?: DateTimeFilter<"tokens"> | Date | string
    marketCapUsd?: StringNullableFilter<"tokens"> | string | null
    priceChange24hPercent?: DecimalNullableFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: DecimalNullableFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: DecimalNullableFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: DateTimeNullableFilter<"tokens"> | Date | string | null
    totalSupply?: StringNullableFilter<"tokens"> | string | null
    updatedAt?: DateTimeFilter<"tokens"> | Date | string
    volume24hUsd?: StringNullableFilter<"tokens"> | string | null
    ammpairsAsToken0?: AmmpairListRelationFilter
    ammpairsAsToken1?: AmmpairListRelationFilter
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: Staking_poolsListRelationFilter
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: Staking_poolsListRelationFilter
  }, "network_id">

  export type tokensOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    decimals?: SortOrderInput | SortOrder
    iconUri?: SortOrderInput | SortOrder
    projectUri?: SortOrderInput | SortOrder
    network?: SortOrder
    lastMetadataAttempt?: SortOrderInput | SortOrder
    metadataFetched?: SortOrder
    metadataStandard?: SortOrderInput | SortOrder
    verified?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    originalCoinType?: SortOrderInput | SortOrder
    circulatingSupply?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    marketCapUsd?: SortOrderInput | SortOrder
    priceChange24hPercent?: SortOrderInput | SortOrder
    priceUsdCurrent?: SortOrderInput | SortOrder
    priceAnchor?: SortOrderInput | SortOrder
    lastPriceUpdate?: SortOrderInput | SortOrder
    totalSupply?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    volume24hUsd?: SortOrderInput | SortOrder
    _count?: tokensCountOrderByAggregateInput
    _avg?: tokensAvgOrderByAggregateInput
    _max?: tokensMaxOrderByAggregateInput
    _min?: tokensMinOrderByAggregateInput
    _sum?: tokensSumOrderByAggregateInput
  }

  export type tokensScalarWhereWithAggregatesInput = {
    AND?: tokensScalarWhereWithAggregatesInput | tokensScalarWhereWithAggregatesInput[]
    OR?: tokensScalarWhereWithAggregatesInput[]
    NOT?: tokensScalarWhereWithAggregatesInput | tokensScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tokens"> | string
    name?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    decimals?: IntNullableWithAggregatesFilter<"tokens"> | number | null
    iconUri?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    projectUri?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    network?: StringWithAggregatesFilter<"tokens"> | string
    lastMetadataAttempt?: DateTimeNullableWithAggregatesFilter<"tokens"> | Date | string | null
    metadataFetched?: BoolWithAggregatesFilter<"tokens"> | boolean
    metadataStandard?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    verified?: BoolWithAggregatesFilter<"tokens"> | boolean
    displayOrder?: IntNullableWithAggregatesFilter<"tokens"> | number | null
    originalCoinType?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    circulatingSupply?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"tokens"> | Date | string
    marketCapUsd?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    priceChange24hPercent?: DecimalNullableWithAggregatesFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: DecimalNullableWithAggregatesFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: DecimalNullableWithAggregatesFilter<"tokens"> | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: DateTimeNullableWithAggregatesFilter<"tokens"> | Date | string | null
    totalSupply?: StringNullableWithAggregatesFilter<"tokens"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"tokens"> | Date | string
    volume24hUsd?: StringNullableWithAggregatesFilter<"tokens"> | string | null
  }

  export type trust_poolsWhereInput = {
    AND?: trust_poolsWhereInput | trust_poolsWhereInput[]
    OR?: trust_poolsWhereInput[]
    NOT?: trust_poolsWhereInput | trust_poolsWhereInput[]
    id?: IntFilter<"trust_pools"> | number
    network?: StringFilter<"trust_pools"> | string
    poolDbId?: IntFilter<"trust_pools"> | number
    tokenAddress?: StringFilter<"trust_pools"> | string
    isActive?: BoolFilter<"trust_pools"> | boolean
    totalStakedAmount?: StringFilter<"trust_pools"> | string
    stakerCount?: IntFilter<"trust_pools"> | number
    createdAt?: DateTimeFilter<"trust_pools"> | Date | string
    updatedAt?: DateTimeFilter<"trust_pools"> | Date | string
    PoolsDB?: XOR<PoolsDBScalarRelationFilter, PoolsDBWhereInput>
  }

  export type trust_poolsOrderByWithRelationInput = {
    id?: SortOrder
    network?: SortOrder
    poolDbId?: SortOrder
    tokenAddress?: SortOrder
    isActive?: SortOrder
    totalStakedAmount?: SortOrder
    stakerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    PoolsDB?: PoolsDBOrderByWithRelationInput
  }

  export type trust_poolsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    poolDbId?: number
    AND?: trust_poolsWhereInput | trust_poolsWhereInput[]
    OR?: trust_poolsWhereInput[]
    NOT?: trust_poolsWhereInput | trust_poolsWhereInput[]
    network?: StringFilter<"trust_pools"> | string
    tokenAddress?: StringFilter<"trust_pools"> | string
    isActive?: BoolFilter<"trust_pools"> | boolean
    totalStakedAmount?: StringFilter<"trust_pools"> | string
    stakerCount?: IntFilter<"trust_pools"> | number
    createdAt?: DateTimeFilter<"trust_pools"> | Date | string
    updatedAt?: DateTimeFilter<"trust_pools"> | Date | string
    PoolsDB?: XOR<PoolsDBScalarRelationFilter, PoolsDBWhereInput>
  }, "id" | "poolDbId">

  export type trust_poolsOrderByWithAggregationInput = {
    id?: SortOrder
    network?: SortOrder
    poolDbId?: SortOrder
    tokenAddress?: SortOrder
    isActive?: SortOrder
    totalStakedAmount?: SortOrder
    stakerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: trust_poolsCountOrderByAggregateInput
    _avg?: trust_poolsAvgOrderByAggregateInput
    _max?: trust_poolsMaxOrderByAggregateInput
    _min?: trust_poolsMinOrderByAggregateInput
    _sum?: trust_poolsSumOrderByAggregateInput
  }

  export type trust_poolsScalarWhereWithAggregatesInput = {
    AND?: trust_poolsScalarWhereWithAggregatesInput | trust_poolsScalarWhereWithAggregatesInput[]
    OR?: trust_poolsScalarWhereWithAggregatesInput[]
    NOT?: trust_poolsScalarWhereWithAggregatesInput | trust_poolsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"trust_pools"> | number
    network?: StringWithAggregatesFilter<"trust_pools"> | string
    poolDbId?: IntWithAggregatesFilter<"trust_pools"> | number
    tokenAddress?: StringWithAggregatesFilter<"trust_pools"> | string
    isActive?: BoolWithAggregatesFilter<"trust_pools"> | boolean
    totalStakedAmount?: StringWithAggregatesFilter<"trust_pools"> | string
    stakerCount?: IntWithAggregatesFilter<"trust_pools"> | number
    createdAt?: DateTimeWithAggregatesFilter<"trust_pools"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"trust_pools"> | Date | string
  }

  export type user_stakesWhereInput = {
    AND?: user_stakesWhereInput | user_stakesWhereInput[]
    OR?: user_stakesWhereInput[]
    NOT?: user_stakesWhereInput | user_stakesWhereInput[]
    id?: IntFilter<"user_stakes"> | number
    poolId?: IntFilter<"user_stakes"> | number
    userNetwork?: StringFilter<"user_stakes"> | string
    userAddress?: StringFilter<"user_stakes"> | string
    stakedAmount?: StringFilter<"user_stakes"> | string
    rewardDebt?: StringFilter<"user_stakes"> | string
    lastClaimTimestamp?: BigIntNullableFilter<"user_stakes"> | bigint | number | null
    createdAt?: DateTimeFilter<"user_stakes"> | Date | string
    updatedAt?: DateTimeFilter<"user_stakes"> | Date | string
    staking_pools?: XOR<Staking_poolsScalarRelationFilter, staking_poolsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_stakesOrderByWithRelationInput = {
    id?: SortOrder
    poolId?: SortOrder
    userNetwork?: SortOrder
    userAddress?: SortOrder
    stakedAmount?: SortOrder
    rewardDebt?: SortOrder
    lastClaimTimestamp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staking_pools?: staking_poolsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type user_stakesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    poolId_userNetwork_userAddress?: user_stakesPoolIdUserNetworkUserAddressCompoundUniqueInput
    AND?: user_stakesWhereInput | user_stakesWhereInput[]
    OR?: user_stakesWhereInput[]
    NOT?: user_stakesWhereInput | user_stakesWhereInput[]
    poolId?: IntFilter<"user_stakes"> | number
    userNetwork?: StringFilter<"user_stakes"> | string
    userAddress?: StringFilter<"user_stakes"> | string
    stakedAmount?: StringFilter<"user_stakes"> | string
    rewardDebt?: StringFilter<"user_stakes"> | string
    lastClaimTimestamp?: BigIntNullableFilter<"user_stakes"> | bigint | number | null
    createdAt?: DateTimeFilter<"user_stakes"> | Date | string
    updatedAt?: DateTimeFilter<"user_stakes"> | Date | string
    staking_pools?: XOR<Staking_poolsScalarRelationFilter, staking_poolsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "poolId_userNetwork_userAddress">

  export type user_stakesOrderByWithAggregationInput = {
    id?: SortOrder
    poolId?: SortOrder
    userNetwork?: SortOrder
    userAddress?: SortOrder
    stakedAmount?: SortOrder
    rewardDebt?: SortOrder
    lastClaimTimestamp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_stakesCountOrderByAggregateInput
    _avg?: user_stakesAvgOrderByAggregateInput
    _max?: user_stakesMaxOrderByAggregateInput
    _min?: user_stakesMinOrderByAggregateInput
    _sum?: user_stakesSumOrderByAggregateInput
  }

  export type user_stakesScalarWhereWithAggregatesInput = {
    AND?: user_stakesScalarWhereWithAggregatesInput | user_stakesScalarWhereWithAggregatesInput[]
    OR?: user_stakesScalarWhereWithAggregatesInput[]
    NOT?: user_stakesScalarWhereWithAggregatesInput | user_stakesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_stakes"> | number
    poolId?: IntWithAggregatesFilter<"user_stakes"> | number
    userNetwork?: StringWithAggregatesFilter<"user_stakes"> | string
    userAddress?: StringWithAggregatesFilter<"user_stakes"> | string
    stakedAmount?: StringWithAggregatesFilter<"user_stakes"> | string
    rewardDebt?: StringWithAggregatesFilter<"user_stakes"> | string
    lastClaimTimestamp?: BigIntNullableWithAggregatesFilter<"user_stakes"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"user_stakes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_stakes"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    walletAddress?: StringFilter<"users"> | string
    username?: StringNullableFilter<"users"> | string | null
    avatarUrl?: StringNullableFilter<"users"> | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    nonce?: IntNullableFilter<"users"> | number | null
    network?: StringFilter<"users"> | string
    comments?: CommentsListRelationFilter
    likes?: LikesListRelationFilter
    staking_pools?: Staking_poolsListRelationFilter
    user_stakes?: User_stakesListRelationFilter
    token_balances?: Token_holdersListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    walletAddress?: SortOrder
    username?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nonce?: SortOrderInput | SortOrder
    network?: SortOrder
    comments?: commentsOrderByRelationAggregateInput
    likes?: likesOrderByRelationAggregateInput
    staking_pools?: staking_poolsOrderByRelationAggregateInput
    user_stakes?: user_stakesOrderByRelationAggregateInput
    token_balances?: token_holdersOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    network_walletAddress?: usersNetworkWalletAddressCompoundUniqueInput
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    walletAddress?: StringFilter<"users"> | string
    username?: StringNullableFilter<"users"> | string | null
    avatarUrl?: StringNullableFilter<"users"> | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    nonce?: IntNullableFilter<"users"> | number | null
    network?: StringFilter<"users"> | string
    comments?: CommentsListRelationFilter
    likes?: LikesListRelationFilter
    staking_pools?: Staking_poolsListRelationFilter
    user_stakes?: User_stakesListRelationFilter
    token_balances?: Token_holdersListRelationFilter
  }, "network_walletAddress">

  export type usersOrderByWithAggregationInput = {
    walletAddress?: SortOrder
    username?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nonce?: SortOrderInput | SortOrder
    network?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    walletAddress?: StringWithAggregatesFilter<"users"> | string
    username?: StringNullableWithAggregatesFilter<"users"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"users"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    nonce?: IntNullableWithAggregatesFilter<"users"> | number | null
    network?: StringWithAggregatesFilter<"users"> | string
  }

  export type token_holdersWhereInput = {
    AND?: token_holdersWhereInput | token_holdersWhereInput[]
    OR?: token_holdersWhereInput[]
    NOT?: token_holdersWhereInput | token_holdersWhereInput[]
    network?: StringFilter<"token_holders"> | string
    userWalletAddress?: StringFilter<"token_holders"> | string
    tokenAddress?: StringFilter<"token_holders"> | string
    balance?: BigIntFilter<"token_holders"> | bigint | number
    createdAt?: DateTimeFilter<"token_holders"> | Date | string
    updatedAt?: DateTimeFilter<"token_holders"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    pool?: XOR<PoolsDBScalarRelationFilter, PoolsDBWhereInput>
  }

  export type token_holdersOrderByWithRelationInput = {
    network?: SortOrder
    userWalletAddress?: SortOrder
    tokenAddress?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    pool?: PoolsDBOrderByWithRelationInput
  }

  export type token_holdersWhereUniqueInput = Prisma.AtLeast<{
    network_userWalletAddress_tokenAddress?: token_holdersNetworkUserWalletAddressTokenAddressCompoundUniqueInput
    AND?: token_holdersWhereInput | token_holdersWhereInput[]
    OR?: token_holdersWhereInput[]
    NOT?: token_holdersWhereInput | token_holdersWhereInput[]
    network?: StringFilter<"token_holders"> | string
    userWalletAddress?: StringFilter<"token_holders"> | string
    tokenAddress?: StringFilter<"token_holders"> | string
    balance?: BigIntFilter<"token_holders"> | bigint | number
    createdAt?: DateTimeFilter<"token_holders"> | Date | string
    updatedAt?: DateTimeFilter<"token_holders"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    pool?: XOR<PoolsDBScalarRelationFilter, PoolsDBWhereInput>
  }, "network_userWalletAddress_tokenAddress">

  export type token_holdersOrderByWithAggregationInput = {
    network?: SortOrder
    userWalletAddress?: SortOrder
    tokenAddress?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: token_holdersCountOrderByAggregateInput
    _avg?: token_holdersAvgOrderByAggregateInput
    _max?: token_holdersMaxOrderByAggregateInput
    _min?: token_holdersMinOrderByAggregateInput
    _sum?: token_holdersSumOrderByAggregateInput
  }

  export type token_holdersScalarWhereWithAggregatesInput = {
    AND?: token_holdersScalarWhereWithAggregatesInput | token_holdersScalarWhereWithAggregatesInput[]
    OR?: token_holdersScalarWhereWithAggregatesInput[]
    NOT?: token_holdersScalarWhereWithAggregatesInput | token_holdersScalarWhereWithAggregatesInput[]
    network?: StringWithAggregatesFilter<"token_holders"> | string
    userWalletAddress?: StringWithAggregatesFilter<"token_holders"> | string
    tokenAddress?: StringWithAggregatesFilter<"token_holders"> | string
    balance?: BigIntWithAggregatesFilter<"token_holders"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"token_holders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"token_holders"> | Date | string
  }

  export type AmmpairCreateInput = {
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
    token0: tokensCreateNestedOneWithoutAmmpairsAsToken0Input
    token1: tokensCreateNestedOneWithoutAmmpairsAsToken1Input
  }

  export type AmmpairUncheckedCreateInput = {
    id?: number
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    token0Address: string
    token1Address: string
    network: string
    token0Network: string
    token1Network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
  }

  export type AmmpairUpdateInput = {
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    token0?: tokensUpdateOneRequiredWithoutAmmpairsAsToken0NestedInput
    token1?: tokensUpdateOneRequiredWithoutAmmpairsAsToken1NestedInput
  }

  export type AmmpairUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    token0Address?: StringFieldUpdateOperationsInput | string
    token1Address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    token0Network?: StringFieldUpdateOperationsInput | string
    token1Network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmmpairCreateManyInput = {
    id?: number
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    token0Address: string
    token1Address: string
    network: string
    token0Network: string
    token1Network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
  }

  export type AmmpairUpdateManyMutationInput = {
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmmpairUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    token0Address?: StringFieldUpdateOperationsInput | string
    token1Address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    token0Network?: StringFieldUpdateOperationsInput | string
    token1Network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventTrackingCreateInput = {
    eventType: string
    blockHeight: bigint | number
    transactionHash: string
    processed?: boolean
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    sequenceNumber?: string | null
  }

  export type EventTrackingUncheckedCreateInput = {
    id?: number
    eventType: string
    blockHeight: bigint | number
    transactionHash: string
    processed?: boolean
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    sequenceNumber?: string | null
  }

  export type EventTrackingUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    blockHeight?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventTrackingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    blockHeight?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventTrackingCreateManyInput = {
    id?: number
    eventType: string
    blockHeight: bigint | number
    transactionHash: string
    processed?: boolean
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    sequenceNumber?: string | null
  }

  export type EventTrackingUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    blockHeight?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventTrackingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    blockHeight?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameResultCreateInput = {
    nonce: bigint | number
    player: string
    playerMove: number
    houseMove: number
    betAmount: bigint | number
    outcome: number
    payoutAmount: bigint | number
    coinTypeName: string
    season: bigint | number
    timestamp: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
  }

  export type GameResultUncheckedCreateInput = {
    id?: number
    nonce: bigint | number
    player: string
    playerMove: number
    houseMove: number
    betAmount: bigint | number
    outcome: number
    payoutAmount: bigint | number
    coinTypeName: string
    season: bigint | number
    timestamp: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
  }

  export type GameResultUpdateInput = {
    nonce?: BigIntFieldUpdateOperationsInput | bigint | number
    player?: StringFieldUpdateOperationsInput | string
    playerMove?: IntFieldUpdateOperationsInput | number
    houseMove?: IntFieldUpdateOperationsInput | number
    betAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    outcome?: IntFieldUpdateOperationsInput | number
    payoutAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    coinTypeName?: StringFieldUpdateOperationsInput | string
    season?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type GameResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nonce?: BigIntFieldUpdateOperationsInput | bigint | number
    player?: StringFieldUpdateOperationsInput | string
    playerMove?: IntFieldUpdateOperationsInput | number
    houseMove?: IntFieldUpdateOperationsInput | number
    betAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    outcome?: IntFieldUpdateOperationsInput | number
    payoutAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    coinTypeName?: StringFieldUpdateOperationsInput | string
    season?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type GameResultCreateManyInput = {
    id?: number
    nonce: bigint | number
    player: string
    playerMove: number
    houseMove: number
    betAmount: bigint | number
    outcome: number
    payoutAmount: bigint | number
    coinTypeName: string
    season: bigint | number
    timestamp: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
  }

  export type GameResultUpdateManyMutationInput = {
    nonce?: BigIntFieldUpdateOperationsInput | bigint | number
    player?: StringFieldUpdateOperationsInput | string
    playerMove?: IntFieldUpdateOperationsInput | number
    houseMove?: IntFieldUpdateOperationsInput | number
    betAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    outcome?: IntFieldUpdateOperationsInput | number
    payoutAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    coinTypeName?: StringFieldUpdateOperationsInput | string
    season?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type GameResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nonce?: BigIntFieldUpdateOperationsInput | bigint | number
    player?: StringFieldUpdateOperationsInput | string
    playerMove?: IntFieldUpdateOperationsInput | number
    houseMove?: IntFieldUpdateOperationsInput | number
    betAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    outcome?: IntFieldUpdateOperationsInput | number
    payoutAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    coinTypeName?: StringFieldUpdateOperationsInput | string
    season?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type PoolsDBCreateInput = {
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
    comments?: commentsCreateNestedManyWithoutPoolsDBInput
    trust_pools?: trust_poolsCreateNestedOneWithoutPoolsDBInput
    holders?: token_holdersCreateNestedManyWithoutPoolInput
  }

  export type PoolsDBUncheckedCreateInput = {
    id?: number
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutPoolsDBInput
    trust_pools?: trust_poolsUncheckedCreateNestedOneWithoutPoolsDBInput
    holders?: token_holdersUncheckedCreateNestedManyWithoutPoolInput
  }

  export type PoolsDBUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutPoolsDBNestedInput
    trust_pools?: trust_poolsUpdateOneWithoutPoolsDBNestedInput
    holders?: token_holdersUpdateManyWithoutPoolNestedInput
  }

  export type PoolsDBUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutPoolsDBNestedInput
    trust_pools?: trust_poolsUncheckedUpdateOneWithoutPoolsDBNestedInput
    holders?: token_holdersUncheckedUpdateManyWithoutPoolNestedInput
  }

  export type PoolsDBCreateManyInput = {
    id?: number
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
  }

  export type PoolsDBUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PoolsDBUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TradeEventCreateInput = {
    type: string
    creationNumber: string
    accountAddress: string
    sequenceNumber: string
    timestamp: bigint | number
    isBuy: boolean
    supraAmount: bigint | number
    tokenAddress: string
    tokenAmount: bigint | number
    user: string
    virtualSupraReserves: bigint | number
    virtualTokenReserves: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    processedForOHLC?: boolean
  }

  export type TradeEventUncheckedCreateInput = {
    id?: number
    type: string
    creationNumber: string
    accountAddress: string
    sequenceNumber: string
    timestamp: bigint | number
    isBuy: boolean
    supraAmount: bigint | number
    tokenAddress: string
    tokenAmount: bigint | number
    user: string
    virtualSupraReserves: bigint | number
    virtualTokenReserves: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    processedForOHLC?: boolean
  }

  export type TradeEventUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    creationNumber?: StringFieldUpdateOperationsInput | string
    accountAddress?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    isBuy?: BoolFieldUpdateOperationsInput | boolean
    supraAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: StringFieldUpdateOperationsInput | string
    virtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    virtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    processedForOHLC?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TradeEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    creationNumber?: StringFieldUpdateOperationsInput | string
    accountAddress?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    isBuy?: BoolFieldUpdateOperationsInput | boolean
    supraAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: StringFieldUpdateOperationsInput | string
    virtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    virtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    processedForOHLC?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TradeEventCreateManyInput = {
    id?: number
    type: string
    creationNumber: string
    accountAddress: string
    sequenceNumber: string
    timestamp: bigint | number
    isBuy: boolean
    supraAmount: bigint | number
    tokenAddress: string
    tokenAmount: bigint | number
    user: string
    virtualSupraReserves: bigint | number
    virtualTokenReserves: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    processedForOHLC?: boolean
  }

  export type TradeEventUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    creationNumber?: StringFieldUpdateOperationsInput | string
    accountAddress?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    isBuy?: BoolFieldUpdateOperationsInput | boolean
    supraAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: StringFieldUpdateOperationsInput | string
    virtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    virtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    processedForOHLC?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TradeEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    creationNumber?: StringFieldUpdateOperationsInput | string
    accountAddress?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    isBuy?: BoolFieldUpdateOperationsInput | boolean
    supraAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: StringFieldUpdateOperationsInput | string
    virtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    virtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    processedForOHLC?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VRFCallbackCreateInput = {
    callerAddress: string
    nonce: string
    randomNumbers?: VRFCallbackCreaterandomNumbersInput | string[]
    timestamp: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
  }

  export type VRFCallbackUncheckedCreateInput = {
    id?: number
    callerAddress: string
    nonce: string
    randomNumbers?: VRFCallbackCreaterandomNumbersInput | string[]
    timestamp: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
  }

  export type VRFCallbackUpdateInput = {
    callerAddress?: StringFieldUpdateOperationsInput | string
    nonce?: StringFieldUpdateOperationsInput | string
    randomNumbers?: VRFCallbackUpdaterandomNumbersInput | string[]
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type VRFCallbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    callerAddress?: StringFieldUpdateOperationsInput | string
    nonce?: StringFieldUpdateOperationsInput | string
    randomNumbers?: VRFCallbackUpdaterandomNumbersInput | string[]
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type VRFCallbackCreateManyInput = {
    id?: number
    callerAddress: string
    nonce: string
    randomNumbers?: VRFCallbackCreaterandomNumbersInput | string[]
    timestamp: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
  }

  export type VRFCallbackUpdateManyMutationInput = {
    callerAddress?: StringFieldUpdateOperationsInput | string
    nonce?: StringFieldUpdateOperationsInput | string
    randomNumbers?: VRFCallbackUpdaterandomNumbersInput | string[]
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type VRFCallbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    callerAddress?: StringFieldUpdateOperationsInput | string
    nonce?: StringFieldUpdateOperationsInput | string
    randomNumbers?: VRFCallbackUpdaterandomNumbersInput | string[]
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type block_progressCreateInput = {
    network: string
    lastBlockHeight: bigint | number
    updatedAt?: Date | string
  }

  export type block_progressUncheckedCreateInput = {
    network: string
    lastBlockHeight: bigint | number
    updatedAt?: Date | string
  }

  export type block_progressUpdateInput = {
    network?: StringFieldUpdateOperationsInput | string
    lastBlockHeight?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type block_progressUncheckedUpdateInput = {
    network?: StringFieldUpdateOperationsInput | string
    lastBlockHeight?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type block_progressCreateManyInput = {
    network: string
    lastBlockHeight: bigint | number
    updatedAt?: Date | string
  }

  export type block_progressUpdateManyMutationInput = {
    network?: StringFieldUpdateOperationsInput | string
    lastBlockHeight?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type block_progressUncheckedUpdateManyInput = {
    network?: StringFieldUpdateOperationsInput | string
    lastBlockHeight?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsCreateInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    likeCount?: number
    PoolsDB: PoolsDBCreateNestedOneWithoutCommentsInput
    users: usersCreateNestedOneWithoutCommentsInput
    images?: imagesCreateNestedManyWithoutCommentsInput
    likes?: likesCreateNestedManyWithoutCommentsInput
  }

  export type commentsUncheckedCreateInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poolId: number
    network: string
    userNetwork: string
    userWalletAddress: string
    displayOrder?: number | null
    likeCount?: number
    poolNetwork: string
    images?: imagesUncheckedCreateNestedManyWithoutCommentsInput
    likes?: likesUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type commentsUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    PoolsDB?: PoolsDBUpdateOneRequiredWithoutCommentsNestedInput
    users?: usersUpdateOneRequiredWithoutCommentsNestedInput
    images?: imagesUpdateManyWithoutCommentsNestedInput
    likes?: likesUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poolId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    poolNetwork?: StringFieldUpdateOperationsInput | string
    images?: imagesUncheckedUpdateManyWithoutCommentsNestedInput
    likes?: likesUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type commentsCreateManyInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poolId: number
    network: string
    userNetwork: string
    userWalletAddress: string
    displayOrder?: number | null
    likeCount?: number
    poolNetwork: string
  }

  export type commentsUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
  }

  export type commentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poolId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    poolNetwork?: StringFieldUpdateOperationsInput | string
  }

  export type imagesCreateInput = {
    url: string
    altText?: string | null
    createdAt?: Date | string
    comments: commentsCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateInput = {
    id?: number
    url: string
    altText?: string | null
    createdAt?: Date | string
    commentId: number
  }

  export type imagesUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: commentsUpdateOneRequiredWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type imagesCreateManyInput = {
    id?: number
    url: string
    altText?: string | null
    createdAt?: Date | string
    commentId: number
  }

  export type imagesUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type likesCreateInput = {
    createdAt?: Date | string
    network: string
    comments: commentsCreateNestedOneWithoutLikesInput
    users: usersCreateNestedOneWithoutLikesInput
  }

  export type likesUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    commentId: number
    network: string
    userNetwork: string
    userWalletAddress: string
  }

  export type likesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUpdateOneRequiredWithoutLikesNestedInput
    users?: usersUpdateOneRequiredWithoutLikesNestedInput
  }

  export type likesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
  }

  export type likesCreateManyInput = {
    id?: number
    createdAt?: Date | string
    commentId: number
    network: string
    userNetwork: string
    userWalletAddress: string
  }

  export type likesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
  }

  export type likesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
  }

  export type migration_eventsCreateInput = {
    network: string
    transactionHash: string
    sequenceNumber: string
    token_address: string
    migrator: string
    supra_sent_to_lp: bigint | number
    tokens_sent_to_lp: bigint | number
    dev_reward_staked: bigint | number
    staking_pool_reward: bigint | number
    migrator_reward: bigint | number
    excess_supra_collected: bigint | number
    createdAt?: Date | string
  }

  export type migration_eventsUncheckedCreateInput = {
    id?: number
    network: string
    transactionHash: string
    sequenceNumber: string
    token_address: string
    migrator: string
    supra_sent_to_lp: bigint | number
    tokens_sent_to_lp: bigint | number
    dev_reward_staked: bigint | number
    staking_pool_reward: bigint | number
    migrator_reward: bigint | number
    excess_supra_collected: bigint | number
    createdAt?: Date | string
  }

  export type migration_eventsUpdateInput = {
    network?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: StringFieldUpdateOperationsInput | string
    token_address?: StringFieldUpdateOperationsInput | string
    migrator?: StringFieldUpdateOperationsInput | string
    supra_sent_to_lp?: BigIntFieldUpdateOperationsInput | bigint | number
    tokens_sent_to_lp?: BigIntFieldUpdateOperationsInput | bigint | number
    dev_reward_staked?: BigIntFieldUpdateOperationsInput | bigint | number
    staking_pool_reward?: BigIntFieldUpdateOperationsInput | bigint | number
    migrator_reward?: BigIntFieldUpdateOperationsInput | bigint | number
    excess_supra_collected?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type migration_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: StringFieldUpdateOperationsInput | string
    token_address?: StringFieldUpdateOperationsInput | string
    migrator?: StringFieldUpdateOperationsInput | string
    supra_sent_to_lp?: BigIntFieldUpdateOperationsInput | bigint | number
    tokens_sent_to_lp?: BigIntFieldUpdateOperationsInput | bigint | number
    dev_reward_staked?: BigIntFieldUpdateOperationsInput | bigint | number
    staking_pool_reward?: BigIntFieldUpdateOperationsInput | bigint | number
    migrator_reward?: BigIntFieldUpdateOperationsInput | bigint | number
    excess_supra_collected?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type migration_eventsCreateManyInput = {
    id?: number
    network: string
    transactionHash: string
    sequenceNumber: string
    token_address: string
    migrator: string
    supra_sent_to_lp: bigint | number
    tokens_sent_to_lp: bigint | number
    dev_reward_staked: bigint | number
    staking_pool_reward: bigint | number
    migrator_reward: bigint | number
    excess_supra_collected: bigint | number
    createdAt?: Date | string
  }

  export type migration_eventsUpdateManyMutationInput = {
    network?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: StringFieldUpdateOperationsInput | string
    token_address?: StringFieldUpdateOperationsInput | string
    migrator?: StringFieldUpdateOperationsInput | string
    supra_sent_to_lp?: BigIntFieldUpdateOperationsInput | bigint | number
    tokens_sent_to_lp?: BigIntFieldUpdateOperationsInput | bigint | number
    dev_reward_staked?: BigIntFieldUpdateOperationsInput | bigint | number
    staking_pool_reward?: BigIntFieldUpdateOperationsInput | bigint | number
    migrator_reward?: BigIntFieldUpdateOperationsInput | bigint | number
    excess_supra_collected?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type migration_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: StringFieldUpdateOperationsInput | string
    token_address?: StringFieldUpdateOperationsInput | string
    migrator?: StringFieldUpdateOperationsInput | string
    supra_sent_to_lp?: BigIntFieldUpdateOperationsInput | bigint | number
    tokens_sent_to_lp?: BigIntFieldUpdateOperationsInput | bigint | number
    dev_reward_staked?: BigIntFieldUpdateOperationsInput | bigint | number
    staking_pool_reward?: BigIntFieldUpdateOperationsInput | bigint | number
    migrator_reward?: BigIntFieldUpdateOperationsInput | bigint | number
    excess_supra_collected?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type protocol_statsCreateInput = {
    network: string
    timestamp: Date | string
    totalTvlUsd?: Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: number | null
    totalFeesEarnedUsd24h?: Decimal | DecimalJsLike | number | string | null
  }

  export type protocol_statsUncheckedCreateInput = {
    id?: number
    network: string
    timestamp: Date | string
    totalTvlUsd?: Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: number | null
    totalFeesEarnedUsd24h?: Decimal | DecimalJsLike | number | string | null
  }

  export type protocol_statsUpdateInput = {
    network?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: NullableIntFieldUpdateOperationsInput | number | null
    totalFeesEarnedUsd24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type protocol_statsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: NullableIntFieldUpdateOperationsInput | number | null
    totalFeesEarnedUsd24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type protocol_statsCreateManyInput = {
    id?: number
    network: string
    timestamp: Date | string
    totalTvlUsd?: Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: number | null
    totalFeesEarnedUsd24h?: Decimal | DecimalJsLike | number | string | null
  }

  export type protocol_statsUpdateManyMutationInput = {
    network?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: NullableIntFieldUpdateOperationsInput | number | null
    totalFeesEarnedUsd24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type protocol_statsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ammTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    virtualPoolsTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stakingTvlUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalVolume24hUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ammVolume24hUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalUniqueUsers?: NullableIntFieldUpdateOperationsInput | number | null
    totalFeesEarnedUsd24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type staking_poolsCreateInput = {
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    users: usersCreateNestedOneWithoutStaking_poolsInput
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens: tokensCreateNestedOneWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens: tokensCreateNestedOneWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
    user_stakes?: user_stakesCreateNestedManyWithoutStaking_poolsInput
  }

  export type staking_poolsUncheckedCreateInput = {
    id?: number
    creatorAddress: string
    stakeTokenAddress: string
    rewardTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorNetwork: string
    network: string
    rewardTokenNetwork: string
    stakeTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutStaking_poolsInput
  }

  export type staking_poolsUpdateInput = {
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutStaking_poolsNestedInput
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
    user_stakes?: user_stakesUpdateManyWithoutStaking_poolsNestedInput
  }

  export type staking_poolsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorAddress?: StringFieldUpdateOperationsInput | string
    stakeTokenAddress?: StringFieldUpdateOperationsInput | string
    rewardTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorNetwork?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    rewardTokenNetwork?: StringFieldUpdateOperationsInput | string
    stakeTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    user_stakes?: user_stakesUncheckedUpdateManyWithoutStaking_poolsNestedInput
  }

  export type staking_poolsCreateManyInput = {
    id?: number
    creatorAddress: string
    stakeTokenAddress: string
    rewardTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorNetwork: string
    network: string
    rewardTokenNetwork: string
    stakeTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
  }

  export type staking_poolsUpdateManyMutationInput = {
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staking_poolsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorAddress?: StringFieldUpdateOperationsInput | string
    stakeTokenAddress?: StringFieldUpdateOperationsInput | string
    rewardTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorNetwork?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    rewardTokenNetwork?: StringFieldUpdateOperationsInput | string
    stakeTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type token_price_historyCreateInput = {
    network: string
    tokenAddress: string
    timestamp: bigint | number
    granularity: string
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    volume?: Decimal | DecimalJsLike | number | string | null
  }

  export type token_price_historyUncheckedCreateInput = {
    id?: number
    network: string
    tokenAddress: string
    timestamp: bigint | number
    granularity: string
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    volume?: Decimal | DecimalJsLike | number | string | null
  }

  export type token_price_historyUpdateInput = {
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    granularity?: StringFieldUpdateOperationsInput | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type token_price_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    granularity?: StringFieldUpdateOperationsInput | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type token_price_historyCreateManyInput = {
    id?: number
    network: string
    tokenAddress: string
    timestamp: bigint | number
    granularity: string
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    volume?: Decimal | DecimalJsLike | number | string | null
  }

  export type token_price_historyUpdateManyMutationInput = {
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    granularity?: StringFieldUpdateOperationsInput | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type token_price_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    granularity?: StringFieldUpdateOperationsInput | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type token_pricesCreateInput = {
    network: string
    tokenAddress: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    lastUpdatedAt: Date | string
  }

  export type token_pricesUncheckedCreateInput = {
    id?: number
    network: string
    tokenAddress: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    lastUpdatedAt: Date | string
  }

  export type token_pricesUpdateInput = {
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_pricesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_pricesCreateManyInput = {
    id?: number
    network: string
    tokenAddress: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    lastUpdatedAt: Date | string
  }

  export type token_pricesUpdateManyMutationInput = {
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_pricesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokensCreateInput = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken0?: AmmpairCreateNestedManyWithoutToken0Input
    ammpairsAsToken1?: AmmpairCreateNestedManyWithoutToken1Input
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type tokensUncheckedCreateInput = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken0?: AmmpairUncheckedCreateNestedManyWithoutToken0Input
    ammpairsAsToken1?: AmmpairUncheckedCreateNestedManyWithoutToken1Input
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type tokensUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken0?: AmmpairUpdateManyWithoutToken0NestedInput
    ammpairsAsToken1?: AmmpairUpdateManyWithoutToken1NestedInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type tokensUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken0?: AmmpairUncheckedUpdateManyWithoutToken0NestedInput
    ammpairsAsToken1?: AmmpairUncheckedUpdateManyWithoutToken1NestedInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type tokensCreateManyInput = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
  }

  export type tokensUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tokensUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trust_poolsCreateInput = {
    network: string
    tokenAddress: string
    isActive?: boolean
    totalStakedAmount?: string
    stakerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PoolsDB: PoolsDBCreateNestedOneWithoutTrust_poolsInput
  }

  export type trust_poolsUncheckedCreateInput = {
    id?: number
    network: string
    poolDbId: number
    tokenAddress: string
    isActive?: boolean
    totalStakedAmount?: string
    stakerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type trust_poolsUpdateInput = {
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    stakerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PoolsDB?: PoolsDBUpdateOneRequiredWithoutTrust_poolsNestedInput
  }

  export type trust_poolsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    poolDbId?: IntFieldUpdateOperationsInput | number
    tokenAddress?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    stakerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trust_poolsCreateManyInput = {
    id?: number
    network: string
    poolDbId: number
    tokenAddress: string
    isActive?: boolean
    totalStakedAmount?: string
    stakerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type trust_poolsUpdateManyMutationInput = {
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    stakerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trust_poolsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    poolDbId?: IntFieldUpdateOperationsInput | number
    tokenAddress?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    stakerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_stakesCreateInput = {
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staking_pools: staking_poolsCreateNestedOneWithoutUser_stakesInput
    users: usersCreateNestedOneWithoutUser_stakesInput
  }

  export type user_stakesUncheckedCreateInput = {
    id?: number
    poolId: number
    userNetwork: string
    userAddress: string
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_stakesUpdateInput = {
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staking_pools?: staking_poolsUpdateOneRequiredWithoutUser_stakesNestedInput
    users?: usersUpdateOneRequiredWithoutUser_stakesNestedInput
  }

  export type user_stakesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    poolId?: IntFieldUpdateOperationsInput | number
    userNetwork?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_stakesCreateManyInput = {
    id?: number
    poolId: number
    userNetwork: string
    userAddress: string
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_stakesUpdateManyMutationInput = {
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_stakesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    poolId?: IntFieldUpdateOperationsInput | number
    userNetwork?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsUncheckedCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUncheckedUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUncheckedUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
  }

  export type usersUpdateManyMutationInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
  }

  export type token_holdersCreateInput = {
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutToken_balancesInput
    pool: PoolsDBCreateNestedOneWithoutHoldersInput
  }

  export type token_holdersUncheckedCreateInput = {
    network: string
    userWalletAddress: string
    tokenAddress: string
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type token_holdersUpdateInput = {
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutToken_balancesNestedInput
    pool?: PoolsDBUpdateOneRequiredWithoutHoldersNestedInput
  }

  export type token_holdersUncheckedUpdateInput = {
    network?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_holdersCreateManyInput = {
    network: string
    userWalletAddress: string
    tokenAddress: string
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type token_holdersUpdateManyMutationInput = {
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_holdersUncheckedUpdateManyInput = {
    network?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumAmmVersionFilter<$PrismaModel = never> = {
    equals?: $Enums.AmmVersion | EnumAmmVersionFieldRefInput<$PrismaModel>
    in?: $Enums.AmmVersion[] | ListEnumAmmVersionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AmmVersion[] | ListEnumAmmVersionFieldRefInput<$PrismaModel>
    not?: NestedEnumAmmVersionFilter<$PrismaModel> | $Enums.AmmVersion
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TokensScalarRelationFilter = {
    is?: tokensWhereInput
    isNot?: tokensWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AmmpairNetworkPairCompoundUniqueInput = {
    network: string
    pair: string
  }

  export type AmmpairCountOrderByAggregateInput = {
    id?: SortOrder
    pair?: SortOrder
    creator?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    token0Address?: SortOrder
    token1Address?: SortOrder
    network?: SortOrder
    token0Network?: SortOrder
    token1Network?: SortOrder
    verified?: SortOrder
    displayOrder?: SortOrder
    apr24h?: SortOrder
    apr7d?: SortOrder
    apyCalculated?: SortOrder
    lastStatsUpdate?: SortOrder
    lpFeePercent?: SortOrder
    reserve0?: SortOrder
    reserve1?: SortOrder
    tvlUsd?: SortOrder
    volumeToken0_24h?: SortOrder
    volumeToken1_24h?: SortOrder
    volumeUsd24h?: SortOrder
    volumeUsd7d?: SortOrder
    volumeUsd30d?: SortOrder
    feesUsd24h?: SortOrder
    feesUsd7d?: SortOrder
    feesUsd30d?: SortOrder
  }

  export type AmmpairAvgOrderByAggregateInput = {
    id?: SortOrder
    displayOrder?: SortOrder
  }

  export type AmmpairMaxOrderByAggregateInput = {
    id?: SortOrder
    pair?: SortOrder
    creator?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    token0Address?: SortOrder
    token1Address?: SortOrder
    network?: SortOrder
    token0Network?: SortOrder
    token1Network?: SortOrder
    verified?: SortOrder
    displayOrder?: SortOrder
    apr24h?: SortOrder
    apr7d?: SortOrder
    apyCalculated?: SortOrder
    lastStatsUpdate?: SortOrder
    lpFeePercent?: SortOrder
    reserve0?: SortOrder
    reserve1?: SortOrder
    tvlUsd?: SortOrder
    volumeToken0_24h?: SortOrder
    volumeToken1_24h?: SortOrder
    volumeUsd24h?: SortOrder
    volumeUsd7d?: SortOrder
    volumeUsd30d?: SortOrder
    feesUsd24h?: SortOrder
    feesUsd7d?: SortOrder
    feesUsd30d?: SortOrder
  }

  export type AmmpairMinOrderByAggregateInput = {
    id?: SortOrder
    pair?: SortOrder
    creator?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    token0Address?: SortOrder
    token1Address?: SortOrder
    network?: SortOrder
    token0Network?: SortOrder
    token1Network?: SortOrder
    verified?: SortOrder
    displayOrder?: SortOrder
    apr24h?: SortOrder
    apr7d?: SortOrder
    apyCalculated?: SortOrder
    lastStatsUpdate?: SortOrder
    lpFeePercent?: SortOrder
    reserve0?: SortOrder
    reserve1?: SortOrder
    tvlUsd?: SortOrder
    volumeToken0_24h?: SortOrder
    volumeToken1_24h?: SortOrder
    volumeUsd24h?: SortOrder
    volumeUsd7d?: SortOrder
    volumeUsd30d?: SortOrder
    feesUsd24h?: SortOrder
    feesUsd7d?: SortOrder
    feesUsd30d?: SortOrder
  }

  export type AmmpairSumOrderByAggregateInput = {
    id?: SortOrder
    displayOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAmmVersionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AmmVersion | EnumAmmVersionFieldRefInput<$PrismaModel>
    in?: $Enums.AmmVersion[] | ListEnumAmmVersionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AmmVersion[] | ListEnumAmmVersionFieldRefInput<$PrismaModel>
    not?: NestedEnumAmmVersionWithAggregatesFilter<$PrismaModel> | $Enums.AmmVersion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAmmVersionFilter<$PrismaModel>
    _max?: NestedEnumAmmVersionFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EventTrackingNetworkTransactionHashSequenceNumberEventTypeCompoundUniqueInput = {
    network: string
    transactionHash: string
    sequenceNumber: string
    eventType: string
  }

  export type EventTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    blockHeight?: SortOrder
    transactionHash?: SortOrder
    processed?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    sequenceNumber?: SortOrder
  }

  export type EventTrackingAvgOrderByAggregateInput = {
    id?: SortOrder
    blockHeight?: SortOrder
  }

  export type EventTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    blockHeight?: SortOrder
    transactionHash?: SortOrder
    processed?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    sequenceNumber?: SortOrder
  }

  export type EventTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    blockHeight?: SortOrder
    transactionHash?: SortOrder
    processed?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    sequenceNumber?: SortOrder
  }

  export type EventTrackingSumOrderByAggregateInput = {
    id?: SortOrder
    blockHeight?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type GameResultNetworkNonceCompoundUniqueInput = {
    network: string
    nonce: bigint | number
  }

  export type GameResultCountOrderByAggregateInput = {
    id?: SortOrder
    nonce?: SortOrder
    player?: SortOrder
    playerMove?: SortOrder
    houseMove?: SortOrder
    betAmount?: SortOrder
    outcome?: SortOrder
    payoutAmount?: SortOrder
    coinTypeName?: SortOrder
    season?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
  }

  export type GameResultAvgOrderByAggregateInput = {
    id?: SortOrder
    nonce?: SortOrder
    playerMove?: SortOrder
    houseMove?: SortOrder
    betAmount?: SortOrder
    outcome?: SortOrder
    payoutAmount?: SortOrder
    season?: SortOrder
    timestamp?: SortOrder
  }

  export type GameResultMaxOrderByAggregateInput = {
    id?: SortOrder
    nonce?: SortOrder
    player?: SortOrder
    playerMove?: SortOrder
    houseMove?: SortOrder
    betAmount?: SortOrder
    outcome?: SortOrder
    payoutAmount?: SortOrder
    coinTypeName?: SortOrder
    season?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
  }

  export type GameResultMinOrderByAggregateInput = {
    id?: SortOrder
    nonce?: SortOrder
    player?: SortOrder
    playerMove?: SortOrder
    houseMove?: SortOrder
    betAmount?: SortOrder
    outcome?: SortOrder
    payoutAmount?: SortOrder
    coinTypeName?: SortOrder
    season?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
  }

  export type GameResultSumOrderByAggregateInput = {
    id?: SortOrder
    nonce?: SortOrder
    playerMove?: SortOrder
    houseMove?: SortOrder
    betAmount?: SortOrder
    outcome?: SortOrder
    payoutAmount?: SortOrder
    season?: SortOrder
    timestamp?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type CommentsListRelationFilter = {
    every?: commentsWhereInput
    some?: commentsWhereInput
    none?: commentsWhereInput
  }

  export type Trust_poolsNullableScalarRelationFilter = {
    is?: trust_poolsWhereInput | null
    isNot?: trust_poolsWhereInput | null
  }

  export type Token_holdersListRelationFilter = {
    every?: token_holdersWhereInput
    some?: token_holdersWhereInput
    none?: token_holdersWhereInput
  }

  export type commentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type token_holdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PoolsDBNetworkIdCompoundUniqueInput = {
    network: string
    id: number
  }

  export type PoolsDBNetworkTokenAddressCompoundUniqueInput = {
    network: string
    tokenAddress: string
  }

  export type PoolsDBCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    dev?: SortOrder
    initialVirtualSupraReserves?: SortOrder
    initialVirtualTokenReserves?: SortOrder
    name?: SortOrder
    platformFee?: SortOrder
    pool?: SortOrder
    symbol?: SortOrder
    telegram?: SortOrder
    tokenAddress?: SortOrder
    tokenDecimals?: SortOrder
    twitter?: SortOrder
    uri?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    displayOrder?: SortOrder
    github?: SortOrder
    stream?: SortOrder
    unstakePeriodSeconds?: SortOrder
    project_type?: SortOrder
  }

  export type PoolsDBAvgOrderByAggregateInput = {
    id?: SortOrder
    initialVirtualSupraReserves?: SortOrder
    initialVirtualTokenReserves?: SortOrder
    platformFee?: SortOrder
    tokenDecimals?: SortOrder
    displayOrder?: SortOrder
    unstakePeriodSeconds?: SortOrder
  }

  export type PoolsDBMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    dev?: SortOrder
    initialVirtualSupraReserves?: SortOrder
    initialVirtualTokenReserves?: SortOrder
    name?: SortOrder
    platformFee?: SortOrder
    pool?: SortOrder
    symbol?: SortOrder
    telegram?: SortOrder
    tokenAddress?: SortOrder
    tokenDecimals?: SortOrder
    twitter?: SortOrder
    uri?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    displayOrder?: SortOrder
    github?: SortOrder
    stream?: SortOrder
    unstakePeriodSeconds?: SortOrder
    project_type?: SortOrder
  }

  export type PoolsDBMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    dev?: SortOrder
    initialVirtualSupraReserves?: SortOrder
    initialVirtualTokenReserves?: SortOrder
    name?: SortOrder
    platformFee?: SortOrder
    pool?: SortOrder
    symbol?: SortOrder
    telegram?: SortOrder
    tokenAddress?: SortOrder
    tokenDecimals?: SortOrder
    twitter?: SortOrder
    uri?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    displayOrder?: SortOrder
    github?: SortOrder
    stream?: SortOrder
    unstakePeriodSeconds?: SortOrder
    project_type?: SortOrder
  }

  export type PoolsDBSumOrderByAggregateInput = {
    id?: SortOrder
    initialVirtualSupraReserves?: SortOrder
    initialVirtualTokenReserves?: SortOrder
    platformFee?: SortOrder
    tokenDecimals?: SortOrder
    displayOrder?: SortOrder
    unstakePeriodSeconds?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type TradeEventNetworkCreationNumberSequenceNumberTypeCompoundUniqueInput = {
    network: string
    creationNumber: string
    sequenceNumber: string
    type: string
  }

  export type TradeEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    creationNumber?: SortOrder
    accountAddress?: SortOrder
    sequenceNumber?: SortOrder
    timestamp?: SortOrder
    isBuy?: SortOrder
    supraAmount?: SortOrder
    tokenAddress?: SortOrder
    tokenAmount?: SortOrder
    user?: SortOrder
    virtualSupraReserves?: SortOrder
    virtualTokenReserves?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    processedForOHLC?: SortOrder
  }

  export type TradeEventAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    supraAmount?: SortOrder
    tokenAmount?: SortOrder
    virtualSupraReserves?: SortOrder
    virtualTokenReserves?: SortOrder
  }

  export type TradeEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    creationNumber?: SortOrder
    accountAddress?: SortOrder
    sequenceNumber?: SortOrder
    timestamp?: SortOrder
    isBuy?: SortOrder
    supraAmount?: SortOrder
    tokenAddress?: SortOrder
    tokenAmount?: SortOrder
    user?: SortOrder
    virtualSupraReserves?: SortOrder
    virtualTokenReserves?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    processedForOHLC?: SortOrder
  }

  export type TradeEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    creationNumber?: SortOrder
    accountAddress?: SortOrder
    sequenceNumber?: SortOrder
    timestamp?: SortOrder
    isBuy?: SortOrder
    supraAmount?: SortOrder
    tokenAddress?: SortOrder
    tokenAmount?: SortOrder
    user?: SortOrder
    virtualSupraReserves?: SortOrder
    virtualTokenReserves?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
    processedForOHLC?: SortOrder
  }

  export type TradeEventSumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    supraAmount?: SortOrder
    tokenAmount?: SortOrder
    virtualSupraReserves?: SortOrder
    virtualTokenReserves?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type VRFCallbackNetworkCallerAddressNonceCompoundUniqueInput = {
    network: string
    callerAddress: string
    nonce: string
  }

  export type VRFCallbackCountOrderByAggregateInput = {
    id?: SortOrder
    callerAddress?: SortOrder
    nonce?: SortOrder
    randomNumbers?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
  }

  export type VRFCallbackAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type VRFCallbackMaxOrderByAggregateInput = {
    id?: SortOrder
    callerAddress?: SortOrder
    nonce?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
  }

  export type VRFCallbackMinOrderByAggregateInput = {
    id?: SortOrder
    callerAddress?: SortOrder
    nonce?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    network?: SortOrder
  }

  export type VRFCallbackSumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type block_progressCountOrderByAggregateInput = {
    network?: SortOrder
    lastBlockHeight?: SortOrder
    updatedAt?: SortOrder
  }

  export type block_progressAvgOrderByAggregateInput = {
    lastBlockHeight?: SortOrder
  }

  export type block_progressMaxOrderByAggregateInput = {
    network?: SortOrder
    lastBlockHeight?: SortOrder
    updatedAt?: SortOrder
  }

  export type block_progressMinOrderByAggregateInput = {
    network?: SortOrder
    lastBlockHeight?: SortOrder
    updatedAt?: SortOrder
  }

  export type block_progressSumOrderByAggregateInput = {
    lastBlockHeight?: SortOrder
  }

  export type PoolsDBScalarRelationFilter = {
    is?: PoolsDBWhereInput
    isNot?: PoolsDBWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type ImagesListRelationFilter = {
    every?: imagesWhereInput
    some?: imagesWhereInput
    none?: imagesWhereInput
  }

  export type LikesListRelationFilter = {
    every?: likesWhereInput
    some?: likesWhereInput
    none?: likesWhereInput
  }

  export type imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type likesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type commentsCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    poolId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
    displayOrder?: SortOrder
    likeCount?: SortOrder
    poolNetwork?: SortOrder
  }

  export type commentsAvgOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    displayOrder?: SortOrder
    likeCount?: SortOrder
  }

  export type commentsMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    poolId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
    displayOrder?: SortOrder
    likeCount?: SortOrder
    poolNetwork?: SortOrder
  }

  export type commentsMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    poolId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
    displayOrder?: SortOrder
    likeCount?: SortOrder
    poolNetwork?: SortOrder
  }

  export type commentsSumOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    displayOrder?: SortOrder
    likeCount?: SortOrder
  }

  export type CommentsScalarRelationFilter = {
    is?: commentsWhereInput
    isNot?: commentsWhereInput
  }

  export type imagesCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
  }

  export type imagesAvgOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
  }

  export type imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
  }

  export type imagesMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
  }

  export type imagesSumOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
  }

  export type likesUserNetworkUserWalletAddressCommentIdCompoundUniqueInput = {
    userNetwork: string
    userWalletAddress: string
    commentId: number
  }

  export type likesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
  }

  export type likesAvgOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
  }

  export type likesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
  }

  export type likesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    network?: SortOrder
    userNetwork?: SortOrder
    userWalletAddress?: SortOrder
  }

  export type likesSumOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
  }

  export type migration_eventsNetworkTransactionHashSequenceNumberCompoundUniqueInput = {
    network: string
    transactionHash: string
    sequenceNumber: string
  }

  export type migration_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    transactionHash?: SortOrder
    sequenceNumber?: SortOrder
    token_address?: SortOrder
    migrator?: SortOrder
    supra_sent_to_lp?: SortOrder
    tokens_sent_to_lp?: SortOrder
    dev_reward_staked?: SortOrder
    staking_pool_reward?: SortOrder
    migrator_reward?: SortOrder
    excess_supra_collected?: SortOrder
    createdAt?: SortOrder
  }

  export type migration_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    supra_sent_to_lp?: SortOrder
    tokens_sent_to_lp?: SortOrder
    dev_reward_staked?: SortOrder
    staking_pool_reward?: SortOrder
    migrator_reward?: SortOrder
    excess_supra_collected?: SortOrder
  }

  export type migration_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    transactionHash?: SortOrder
    sequenceNumber?: SortOrder
    token_address?: SortOrder
    migrator?: SortOrder
    supra_sent_to_lp?: SortOrder
    tokens_sent_to_lp?: SortOrder
    dev_reward_staked?: SortOrder
    staking_pool_reward?: SortOrder
    migrator_reward?: SortOrder
    excess_supra_collected?: SortOrder
    createdAt?: SortOrder
  }

  export type migration_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    transactionHash?: SortOrder
    sequenceNumber?: SortOrder
    token_address?: SortOrder
    migrator?: SortOrder
    supra_sent_to_lp?: SortOrder
    tokens_sent_to_lp?: SortOrder
    dev_reward_staked?: SortOrder
    staking_pool_reward?: SortOrder
    migrator_reward?: SortOrder
    excess_supra_collected?: SortOrder
    createdAt?: SortOrder
  }

  export type migration_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    supra_sent_to_lp?: SortOrder
    tokens_sent_to_lp?: SortOrder
    dev_reward_staked?: SortOrder
    staking_pool_reward?: SortOrder
    migrator_reward?: SortOrder
    excess_supra_collected?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type protocol_statsNetworkTimestampCompoundUniqueInput = {
    network: string
    timestamp: Date | string
  }

  export type protocol_statsCountOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    timestamp?: SortOrder
    totalTvlUsd?: SortOrder
    ammTvlUsd?: SortOrder
    virtualPoolsTvlUsd?: SortOrder
    stakingTvlUsd?: SortOrder
    totalVolume24hUsd?: SortOrder
    ammVolume24hUsd?: SortOrder
    totalUniqueUsers?: SortOrder
    totalFeesEarnedUsd24h?: SortOrder
  }

  export type protocol_statsAvgOrderByAggregateInput = {
    id?: SortOrder
    totalTvlUsd?: SortOrder
    ammTvlUsd?: SortOrder
    virtualPoolsTvlUsd?: SortOrder
    stakingTvlUsd?: SortOrder
    totalVolume24hUsd?: SortOrder
    ammVolume24hUsd?: SortOrder
    totalUniqueUsers?: SortOrder
    totalFeesEarnedUsd24h?: SortOrder
  }

  export type protocol_statsMaxOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    timestamp?: SortOrder
    totalTvlUsd?: SortOrder
    ammTvlUsd?: SortOrder
    virtualPoolsTvlUsd?: SortOrder
    stakingTvlUsd?: SortOrder
    totalVolume24hUsd?: SortOrder
    ammVolume24hUsd?: SortOrder
    totalUniqueUsers?: SortOrder
    totalFeesEarnedUsd24h?: SortOrder
  }

  export type protocol_statsMinOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    timestamp?: SortOrder
    totalTvlUsd?: SortOrder
    ammTvlUsd?: SortOrder
    virtualPoolsTvlUsd?: SortOrder
    stakingTvlUsd?: SortOrder
    totalVolume24hUsd?: SortOrder
    ammVolume24hUsd?: SortOrder
    totalUniqueUsers?: SortOrder
    totalFeesEarnedUsd24h?: SortOrder
  }

  export type protocol_statsSumOrderByAggregateInput = {
    id?: SortOrder
    totalTvlUsd?: SortOrder
    ammTvlUsd?: SortOrder
    virtualPoolsTvlUsd?: SortOrder
    stakingTvlUsd?: SortOrder
    totalVolume24hUsd?: SortOrder
    ammVolume24hUsd?: SortOrder
    totalUniqueUsers?: SortOrder
    totalFeesEarnedUsd24h?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumPoolTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolType | EnumPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoolType[] | ListEnumPoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoolType[] | ListEnumPoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoolTypeFilter<$PrismaModel> | $Enums.PoolType
  }

  export type User_stakesListRelationFilter = {
    every?: user_stakesWhereInput
    some?: user_stakesWhereInput
    none?: user_stakesWhereInput
  }

  export type user_stakesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type staking_poolsNetworkCreatorAddressStakeTokenAddressRewardTokenAddressCompoundUniqueInput = {
    network: string
    creatorAddress: string
    stakeTokenAddress: string
    rewardTokenAddress: string
  }

  export type staking_poolsCountOrderByAggregateInput = {
    id?: SortOrder
    creatorAddress?: SortOrder
    stakeTokenAddress?: SortOrder
    rewardTokenAddress?: SortOrder
    isDynamicPool?: SortOrder
    rewardPerSec?: SortOrder
    accumReward?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    emergencyLocked?: SortOrder
    stakesClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorNetwork?: SortOrder
    network?: SortOrder
    rewardTokenNetwork?: SortOrder
    stakeTokenNetwork?: SortOrder
    boostEnabled?: SortOrder
    initialEndTimestamp?: SortOrder
    initialRewardPerSec?: SortOrder
    verified?: SortOrder
    totalBoosted?: SortOrder
    displayOrder?: SortOrder
    cachedApy?: SortOrder
    cachedStakerCount?: SortOrder
    cachedTvlUsd?: SortOrder
    poolType?: SortOrder
    totalStakedAmount?: SortOrder
    boostConfigCollectionName?: SortOrder
    boostConfigCollectionOwner?: SortOrder
    boostConfigPercent?: SortOrder
  }

  export type staking_poolsAvgOrderByAggregateInput = {
    id?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    initialEndTimestamp?: SortOrder
    displayOrder?: SortOrder
    cachedStakerCount?: SortOrder
  }

  export type staking_poolsMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorAddress?: SortOrder
    stakeTokenAddress?: SortOrder
    rewardTokenAddress?: SortOrder
    isDynamicPool?: SortOrder
    rewardPerSec?: SortOrder
    accumReward?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    emergencyLocked?: SortOrder
    stakesClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorNetwork?: SortOrder
    network?: SortOrder
    rewardTokenNetwork?: SortOrder
    stakeTokenNetwork?: SortOrder
    boostEnabled?: SortOrder
    initialEndTimestamp?: SortOrder
    initialRewardPerSec?: SortOrder
    verified?: SortOrder
    totalBoosted?: SortOrder
    displayOrder?: SortOrder
    cachedApy?: SortOrder
    cachedStakerCount?: SortOrder
    cachedTvlUsd?: SortOrder
    poolType?: SortOrder
    totalStakedAmount?: SortOrder
    boostConfigCollectionName?: SortOrder
    boostConfigCollectionOwner?: SortOrder
    boostConfigPercent?: SortOrder
  }

  export type staking_poolsMinOrderByAggregateInput = {
    id?: SortOrder
    creatorAddress?: SortOrder
    stakeTokenAddress?: SortOrder
    rewardTokenAddress?: SortOrder
    isDynamicPool?: SortOrder
    rewardPerSec?: SortOrder
    accumReward?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    emergencyLocked?: SortOrder
    stakesClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorNetwork?: SortOrder
    network?: SortOrder
    rewardTokenNetwork?: SortOrder
    stakeTokenNetwork?: SortOrder
    boostEnabled?: SortOrder
    initialEndTimestamp?: SortOrder
    initialRewardPerSec?: SortOrder
    verified?: SortOrder
    totalBoosted?: SortOrder
    displayOrder?: SortOrder
    cachedApy?: SortOrder
    cachedStakerCount?: SortOrder
    cachedTvlUsd?: SortOrder
    poolType?: SortOrder
    totalStakedAmount?: SortOrder
    boostConfigCollectionName?: SortOrder
    boostConfigCollectionOwner?: SortOrder
    boostConfigPercent?: SortOrder
  }

  export type staking_poolsSumOrderByAggregateInput = {
    id?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    initialEndTimestamp?: SortOrder
    displayOrder?: SortOrder
    cachedStakerCount?: SortOrder
  }

  export type EnumPoolTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolType | EnumPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoolType[] | ListEnumPoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoolType[] | ListEnumPoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoolTypeWithAggregatesFilter<$PrismaModel> | $Enums.PoolType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoolTypeFilter<$PrismaModel>
    _max?: NestedEnumPoolTypeFilter<$PrismaModel>
  }

  export type token_price_historyNetworkTokenAddressTimestampGranularityCompoundUniqueInput = {
    network: string
    tokenAddress: string
    timestamp: bigint | number
    granularity: string
  }

  export type token_price_historyCountOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    timestamp?: SortOrder
    granularity?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
  }

  export type token_price_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
  }

  export type token_price_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    timestamp?: SortOrder
    granularity?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
  }

  export type token_price_historyMinOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    timestamp?: SortOrder
    granularity?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
  }

  export type token_price_historySumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
  }

  export type token_pricesNetworkTokenAddressCompoundUniqueInput = {
    network: string
    tokenAddress: string
  }

  export type token_pricesCountOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    priceUsd?: SortOrder
    priceAnchor?: SortOrder
    source?: SortOrder
    lastUpdatedAt?: SortOrder
  }

  export type token_pricesAvgOrderByAggregateInput = {
    id?: SortOrder
    priceUsd?: SortOrder
    priceAnchor?: SortOrder
  }

  export type token_pricesMaxOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    priceUsd?: SortOrder
    priceAnchor?: SortOrder
    source?: SortOrder
    lastUpdatedAt?: SortOrder
  }

  export type token_pricesMinOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    tokenAddress?: SortOrder
    priceUsd?: SortOrder
    priceAnchor?: SortOrder
    source?: SortOrder
    lastUpdatedAt?: SortOrder
  }

  export type token_pricesSumOrderByAggregateInput = {
    id?: SortOrder
    priceUsd?: SortOrder
    priceAnchor?: SortOrder
  }

  export type AmmpairListRelationFilter = {
    every?: AmmpairWhereInput
    some?: AmmpairWhereInput
    none?: AmmpairWhereInput
  }

  export type Staking_poolsListRelationFilter = {
    every?: staking_poolsWhereInput
    some?: staking_poolsWhereInput
    none?: staking_poolsWhereInput
  }

  export type AmmpairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type staking_poolsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tokensNetworkIdCompoundUniqueInput = {
    network: string
    id: string
  }

  export type tokensCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    iconUri?: SortOrder
    projectUri?: SortOrder
    network?: SortOrder
    lastMetadataAttempt?: SortOrder
    metadataFetched?: SortOrder
    metadataStandard?: SortOrder
    verified?: SortOrder
    displayOrder?: SortOrder
    originalCoinType?: SortOrder
    circulatingSupply?: SortOrder
    createdAt?: SortOrder
    marketCapUsd?: SortOrder
    priceChange24hPercent?: SortOrder
    priceUsdCurrent?: SortOrder
    priceAnchor?: SortOrder
    lastPriceUpdate?: SortOrder
    totalSupply?: SortOrder
    updatedAt?: SortOrder
    volume24hUsd?: SortOrder
  }

  export type tokensAvgOrderByAggregateInput = {
    decimals?: SortOrder
    displayOrder?: SortOrder
    priceChange24hPercent?: SortOrder
    priceUsdCurrent?: SortOrder
    priceAnchor?: SortOrder
  }

  export type tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    iconUri?: SortOrder
    projectUri?: SortOrder
    network?: SortOrder
    lastMetadataAttempt?: SortOrder
    metadataFetched?: SortOrder
    metadataStandard?: SortOrder
    verified?: SortOrder
    displayOrder?: SortOrder
    originalCoinType?: SortOrder
    circulatingSupply?: SortOrder
    createdAt?: SortOrder
    marketCapUsd?: SortOrder
    priceChange24hPercent?: SortOrder
    priceUsdCurrent?: SortOrder
    priceAnchor?: SortOrder
    lastPriceUpdate?: SortOrder
    totalSupply?: SortOrder
    updatedAt?: SortOrder
    volume24hUsd?: SortOrder
  }

  export type tokensMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    iconUri?: SortOrder
    projectUri?: SortOrder
    network?: SortOrder
    lastMetadataAttempt?: SortOrder
    metadataFetched?: SortOrder
    metadataStandard?: SortOrder
    verified?: SortOrder
    displayOrder?: SortOrder
    originalCoinType?: SortOrder
    circulatingSupply?: SortOrder
    createdAt?: SortOrder
    marketCapUsd?: SortOrder
    priceChange24hPercent?: SortOrder
    priceUsdCurrent?: SortOrder
    priceAnchor?: SortOrder
    lastPriceUpdate?: SortOrder
    totalSupply?: SortOrder
    updatedAt?: SortOrder
    volume24hUsd?: SortOrder
  }

  export type tokensSumOrderByAggregateInput = {
    decimals?: SortOrder
    displayOrder?: SortOrder
    priceChange24hPercent?: SortOrder
    priceUsdCurrent?: SortOrder
    priceAnchor?: SortOrder
  }

  export type trust_poolsCountOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    poolDbId?: SortOrder
    tokenAddress?: SortOrder
    isActive?: SortOrder
    totalStakedAmount?: SortOrder
    stakerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trust_poolsAvgOrderByAggregateInput = {
    id?: SortOrder
    poolDbId?: SortOrder
    stakerCount?: SortOrder
  }

  export type trust_poolsMaxOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    poolDbId?: SortOrder
    tokenAddress?: SortOrder
    isActive?: SortOrder
    totalStakedAmount?: SortOrder
    stakerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trust_poolsMinOrderByAggregateInput = {
    id?: SortOrder
    network?: SortOrder
    poolDbId?: SortOrder
    tokenAddress?: SortOrder
    isActive?: SortOrder
    totalStakedAmount?: SortOrder
    stakerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trust_poolsSumOrderByAggregateInput = {
    id?: SortOrder
    poolDbId?: SortOrder
    stakerCount?: SortOrder
  }

  export type Staking_poolsScalarRelationFilter = {
    is?: staking_poolsWhereInput
    isNot?: staking_poolsWhereInput
  }

  export type user_stakesPoolIdUserNetworkUserAddressCompoundUniqueInput = {
    poolId: number
    userNetwork: string
    userAddress: string
  }

  export type user_stakesCountOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    userNetwork?: SortOrder
    userAddress?: SortOrder
    stakedAmount?: SortOrder
    rewardDebt?: SortOrder
    lastClaimTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_stakesAvgOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    lastClaimTimestamp?: SortOrder
  }

  export type user_stakesMaxOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    userNetwork?: SortOrder
    userAddress?: SortOrder
    stakedAmount?: SortOrder
    rewardDebt?: SortOrder
    lastClaimTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_stakesMinOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    userNetwork?: SortOrder
    userAddress?: SortOrder
    stakedAmount?: SortOrder
    rewardDebt?: SortOrder
    lastClaimTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_stakesSumOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    lastClaimTimestamp?: SortOrder
  }

  export type usersNetworkWalletAddressCompoundUniqueInput = {
    network: string
    walletAddress: string
  }

  export type usersCountOrderByAggregateInput = {
    walletAddress?: SortOrder
    username?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nonce?: SortOrder
    network?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    nonce?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    walletAddress?: SortOrder
    username?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nonce?: SortOrder
    network?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    walletAddress?: SortOrder
    username?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nonce?: SortOrder
    network?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    nonce?: SortOrder
  }

  export type token_holdersNetworkUserWalletAddressTokenAddressCompoundUniqueInput = {
    network: string
    userWalletAddress: string
    tokenAddress: string
  }

  export type token_holdersCountOrderByAggregateInput = {
    network?: SortOrder
    userWalletAddress?: SortOrder
    tokenAddress?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type token_holdersAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type token_holdersMaxOrderByAggregateInput = {
    network?: SortOrder
    userWalletAddress?: SortOrder
    tokenAddress?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type token_holdersMinOrderByAggregateInput = {
    network?: SortOrder
    userWalletAddress?: SortOrder
    tokenAddress?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type token_holdersSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type tokensCreateNestedOneWithoutAmmpairsAsToken0Input = {
    create?: XOR<tokensCreateWithoutAmmpairsAsToken0Input, tokensUncheckedCreateWithoutAmmpairsAsToken0Input>
    connectOrCreate?: tokensCreateOrConnectWithoutAmmpairsAsToken0Input
    connect?: tokensWhereUniqueInput
  }

  export type tokensCreateNestedOneWithoutAmmpairsAsToken1Input = {
    create?: XOR<tokensCreateWithoutAmmpairsAsToken1Input, tokensUncheckedCreateWithoutAmmpairsAsToken1Input>
    connectOrCreate?: tokensCreateOrConnectWithoutAmmpairsAsToken1Input
    connect?: tokensWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumAmmVersionFieldUpdateOperationsInput = {
    set?: $Enums.AmmVersion
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type tokensUpdateOneRequiredWithoutAmmpairsAsToken0NestedInput = {
    create?: XOR<tokensCreateWithoutAmmpairsAsToken0Input, tokensUncheckedCreateWithoutAmmpairsAsToken0Input>
    connectOrCreate?: tokensCreateOrConnectWithoutAmmpairsAsToken0Input
    upsert?: tokensUpsertWithoutAmmpairsAsToken0Input
    connect?: tokensWhereUniqueInput
    update?: XOR<XOR<tokensUpdateToOneWithWhereWithoutAmmpairsAsToken0Input, tokensUpdateWithoutAmmpairsAsToken0Input>, tokensUncheckedUpdateWithoutAmmpairsAsToken0Input>
  }

  export type tokensUpdateOneRequiredWithoutAmmpairsAsToken1NestedInput = {
    create?: XOR<tokensCreateWithoutAmmpairsAsToken1Input, tokensUncheckedCreateWithoutAmmpairsAsToken1Input>
    connectOrCreate?: tokensCreateOrConnectWithoutAmmpairsAsToken1Input
    upsert?: tokensUpsertWithoutAmmpairsAsToken1Input
    connect?: tokensWhereUniqueInput
    update?: XOR<XOR<tokensUpdateToOneWithWhereWithoutAmmpairsAsToken1Input, tokensUpdateWithoutAmmpairsAsToken1Input>, tokensUncheckedUpdateWithoutAmmpairsAsToken1Input>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type commentsCreateNestedManyWithoutPoolsDBInput = {
    create?: XOR<commentsCreateWithoutPoolsDBInput, commentsUncheckedCreateWithoutPoolsDBInput> | commentsCreateWithoutPoolsDBInput[] | commentsUncheckedCreateWithoutPoolsDBInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPoolsDBInput | commentsCreateOrConnectWithoutPoolsDBInput[]
    createMany?: commentsCreateManyPoolsDBInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type trust_poolsCreateNestedOneWithoutPoolsDBInput = {
    create?: XOR<trust_poolsCreateWithoutPoolsDBInput, trust_poolsUncheckedCreateWithoutPoolsDBInput>
    connectOrCreate?: trust_poolsCreateOrConnectWithoutPoolsDBInput
    connect?: trust_poolsWhereUniqueInput
  }

  export type token_holdersCreateNestedManyWithoutPoolInput = {
    create?: XOR<token_holdersCreateWithoutPoolInput, token_holdersUncheckedCreateWithoutPoolInput> | token_holdersCreateWithoutPoolInput[] | token_holdersUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: token_holdersCreateOrConnectWithoutPoolInput | token_holdersCreateOrConnectWithoutPoolInput[]
    createMany?: token_holdersCreateManyPoolInputEnvelope
    connect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutPoolsDBInput = {
    create?: XOR<commentsCreateWithoutPoolsDBInput, commentsUncheckedCreateWithoutPoolsDBInput> | commentsCreateWithoutPoolsDBInput[] | commentsUncheckedCreateWithoutPoolsDBInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPoolsDBInput | commentsCreateOrConnectWithoutPoolsDBInput[]
    createMany?: commentsCreateManyPoolsDBInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type trust_poolsUncheckedCreateNestedOneWithoutPoolsDBInput = {
    create?: XOR<trust_poolsCreateWithoutPoolsDBInput, trust_poolsUncheckedCreateWithoutPoolsDBInput>
    connectOrCreate?: trust_poolsCreateOrConnectWithoutPoolsDBInput
    connect?: trust_poolsWhereUniqueInput
  }

  export type token_holdersUncheckedCreateNestedManyWithoutPoolInput = {
    create?: XOR<token_holdersCreateWithoutPoolInput, token_holdersUncheckedCreateWithoutPoolInput> | token_holdersCreateWithoutPoolInput[] | token_holdersUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: token_holdersCreateOrConnectWithoutPoolInput | token_holdersCreateOrConnectWithoutPoolInput[]
    createMany?: token_holdersCreateManyPoolInputEnvelope
    connect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type commentsUpdateManyWithoutPoolsDBNestedInput = {
    create?: XOR<commentsCreateWithoutPoolsDBInput, commentsUncheckedCreateWithoutPoolsDBInput> | commentsCreateWithoutPoolsDBInput[] | commentsUncheckedCreateWithoutPoolsDBInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPoolsDBInput | commentsCreateOrConnectWithoutPoolsDBInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutPoolsDBInput | commentsUpsertWithWhereUniqueWithoutPoolsDBInput[]
    createMany?: commentsCreateManyPoolsDBInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutPoolsDBInput | commentsUpdateWithWhereUniqueWithoutPoolsDBInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutPoolsDBInput | commentsUpdateManyWithWhereWithoutPoolsDBInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type trust_poolsUpdateOneWithoutPoolsDBNestedInput = {
    create?: XOR<trust_poolsCreateWithoutPoolsDBInput, trust_poolsUncheckedCreateWithoutPoolsDBInput>
    connectOrCreate?: trust_poolsCreateOrConnectWithoutPoolsDBInput
    upsert?: trust_poolsUpsertWithoutPoolsDBInput
    disconnect?: trust_poolsWhereInput | boolean
    delete?: trust_poolsWhereInput | boolean
    connect?: trust_poolsWhereUniqueInput
    update?: XOR<XOR<trust_poolsUpdateToOneWithWhereWithoutPoolsDBInput, trust_poolsUpdateWithoutPoolsDBInput>, trust_poolsUncheckedUpdateWithoutPoolsDBInput>
  }

  export type token_holdersUpdateManyWithoutPoolNestedInput = {
    create?: XOR<token_holdersCreateWithoutPoolInput, token_holdersUncheckedCreateWithoutPoolInput> | token_holdersCreateWithoutPoolInput[] | token_holdersUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: token_holdersCreateOrConnectWithoutPoolInput | token_holdersCreateOrConnectWithoutPoolInput[]
    upsert?: token_holdersUpsertWithWhereUniqueWithoutPoolInput | token_holdersUpsertWithWhereUniqueWithoutPoolInput[]
    createMany?: token_holdersCreateManyPoolInputEnvelope
    set?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    disconnect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    delete?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    connect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    update?: token_holdersUpdateWithWhereUniqueWithoutPoolInput | token_holdersUpdateWithWhereUniqueWithoutPoolInput[]
    updateMany?: token_holdersUpdateManyWithWhereWithoutPoolInput | token_holdersUpdateManyWithWhereWithoutPoolInput[]
    deleteMany?: token_holdersScalarWhereInput | token_holdersScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutPoolsDBNestedInput = {
    create?: XOR<commentsCreateWithoutPoolsDBInput, commentsUncheckedCreateWithoutPoolsDBInput> | commentsCreateWithoutPoolsDBInput[] | commentsUncheckedCreateWithoutPoolsDBInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPoolsDBInput | commentsCreateOrConnectWithoutPoolsDBInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutPoolsDBInput | commentsUpsertWithWhereUniqueWithoutPoolsDBInput[]
    createMany?: commentsCreateManyPoolsDBInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutPoolsDBInput | commentsUpdateWithWhereUniqueWithoutPoolsDBInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutPoolsDBInput | commentsUpdateManyWithWhereWithoutPoolsDBInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type trust_poolsUncheckedUpdateOneWithoutPoolsDBNestedInput = {
    create?: XOR<trust_poolsCreateWithoutPoolsDBInput, trust_poolsUncheckedCreateWithoutPoolsDBInput>
    connectOrCreate?: trust_poolsCreateOrConnectWithoutPoolsDBInput
    upsert?: trust_poolsUpsertWithoutPoolsDBInput
    disconnect?: trust_poolsWhereInput | boolean
    delete?: trust_poolsWhereInput | boolean
    connect?: trust_poolsWhereUniqueInput
    update?: XOR<XOR<trust_poolsUpdateToOneWithWhereWithoutPoolsDBInput, trust_poolsUpdateWithoutPoolsDBInput>, trust_poolsUncheckedUpdateWithoutPoolsDBInput>
  }

  export type token_holdersUncheckedUpdateManyWithoutPoolNestedInput = {
    create?: XOR<token_holdersCreateWithoutPoolInput, token_holdersUncheckedCreateWithoutPoolInput> | token_holdersCreateWithoutPoolInput[] | token_holdersUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: token_holdersCreateOrConnectWithoutPoolInput | token_holdersCreateOrConnectWithoutPoolInput[]
    upsert?: token_holdersUpsertWithWhereUniqueWithoutPoolInput | token_holdersUpsertWithWhereUniqueWithoutPoolInput[]
    createMany?: token_holdersCreateManyPoolInputEnvelope
    set?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    disconnect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    delete?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    connect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    update?: token_holdersUpdateWithWhereUniqueWithoutPoolInput | token_holdersUpdateWithWhereUniqueWithoutPoolInput[]
    updateMany?: token_holdersUpdateManyWithWhereWithoutPoolInput | token_holdersUpdateManyWithWhereWithoutPoolInput[]
    deleteMany?: token_holdersScalarWhereInput | token_holdersScalarWhereInput[]
  }

  export type VRFCallbackCreaterandomNumbersInput = {
    set: string[]
  }

  export type VRFCallbackUpdaterandomNumbersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PoolsDBCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PoolsDBCreateWithoutCommentsInput, PoolsDBUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PoolsDBCreateOrConnectWithoutCommentsInput
    connect?: PoolsDBWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCommentsInput = {
    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput
    connect?: usersWhereUniqueInput
  }

  export type imagesCreateNestedManyWithoutCommentsInput = {
    create?: XOR<imagesCreateWithoutCommentsInput, imagesUncheckedCreateWithoutCommentsInput> | imagesCreateWithoutCommentsInput[] | imagesUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutCommentsInput | imagesCreateOrConnectWithoutCommentsInput[]
    createMany?: imagesCreateManyCommentsInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type likesCreateNestedManyWithoutCommentsInput = {
    create?: XOR<likesCreateWithoutCommentsInput, likesUncheckedCreateWithoutCommentsInput> | likesCreateWithoutCommentsInput[] | likesUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: likesCreateOrConnectWithoutCommentsInput | likesCreateOrConnectWithoutCommentsInput[]
    createMany?: likesCreateManyCommentsInputEnvelope
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
  }

  export type imagesUncheckedCreateNestedManyWithoutCommentsInput = {
    create?: XOR<imagesCreateWithoutCommentsInput, imagesUncheckedCreateWithoutCommentsInput> | imagesCreateWithoutCommentsInput[] | imagesUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutCommentsInput | imagesCreateOrConnectWithoutCommentsInput[]
    createMany?: imagesCreateManyCommentsInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type likesUncheckedCreateNestedManyWithoutCommentsInput = {
    create?: XOR<likesCreateWithoutCommentsInput, likesUncheckedCreateWithoutCommentsInput> | likesCreateWithoutCommentsInput[] | likesUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: likesCreateOrConnectWithoutCommentsInput | likesCreateOrConnectWithoutCommentsInput[]
    createMany?: likesCreateManyCommentsInputEnvelope
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
  }

  export type PoolsDBUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PoolsDBCreateWithoutCommentsInput, PoolsDBUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PoolsDBCreateOrConnectWithoutCommentsInput
    upsert?: PoolsDBUpsertWithoutCommentsInput
    connect?: PoolsDBWhereUniqueInput
    update?: XOR<XOR<PoolsDBUpdateToOneWithWhereWithoutCommentsInput, PoolsDBUpdateWithoutCommentsInput>, PoolsDBUncheckedUpdateWithoutCommentsInput>
  }

  export type usersUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput
    upsert?: usersUpsertWithoutCommentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCommentsInput, usersUpdateWithoutCommentsInput>, usersUncheckedUpdateWithoutCommentsInput>
  }

  export type imagesUpdateManyWithoutCommentsNestedInput = {
    create?: XOR<imagesCreateWithoutCommentsInput, imagesUncheckedCreateWithoutCommentsInput> | imagesCreateWithoutCommentsInput[] | imagesUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutCommentsInput | imagesCreateOrConnectWithoutCommentsInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutCommentsInput | imagesUpsertWithWhereUniqueWithoutCommentsInput[]
    createMany?: imagesCreateManyCommentsInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutCommentsInput | imagesUpdateWithWhereUniqueWithoutCommentsInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutCommentsInput | imagesUpdateManyWithWhereWithoutCommentsInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type likesUpdateManyWithoutCommentsNestedInput = {
    create?: XOR<likesCreateWithoutCommentsInput, likesUncheckedCreateWithoutCommentsInput> | likesCreateWithoutCommentsInput[] | likesUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: likesCreateOrConnectWithoutCommentsInput | likesCreateOrConnectWithoutCommentsInput[]
    upsert?: likesUpsertWithWhereUniqueWithoutCommentsInput | likesUpsertWithWhereUniqueWithoutCommentsInput[]
    createMany?: likesCreateManyCommentsInputEnvelope
    set?: likesWhereUniqueInput | likesWhereUniqueInput[]
    disconnect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    delete?: likesWhereUniqueInput | likesWhereUniqueInput[]
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    update?: likesUpdateWithWhereUniqueWithoutCommentsInput | likesUpdateWithWhereUniqueWithoutCommentsInput[]
    updateMany?: likesUpdateManyWithWhereWithoutCommentsInput | likesUpdateManyWithWhereWithoutCommentsInput[]
    deleteMany?: likesScalarWhereInput | likesScalarWhereInput[]
  }

  export type imagesUncheckedUpdateManyWithoutCommentsNestedInput = {
    create?: XOR<imagesCreateWithoutCommentsInput, imagesUncheckedCreateWithoutCommentsInput> | imagesCreateWithoutCommentsInput[] | imagesUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutCommentsInput | imagesCreateOrConnectWithoutCommentsInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutCommentsInput | imagesUpsertWithWhereUniqueWithoutCommentsInput[]
    createMany?: imagesCreateManyCommentsInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutCommentsInput | imagesUpdateWithWhereUniqueWithoutCommentsInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutCommentsInput | imagesUpdateManyWithWhereWithoutCommentsInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type likesUncheckedUpdateManyWithoutCommentsNestedInput = {
    create?: XOR<likesCreateWithoutCommentsInput, likesUncheckedCreateWithoutCommentsInput> | likesCreateWithoutCommentsInput[] | likesUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: likesCreateOrConnectWithoutCommentsInput | likesCreateOrConnectWithoutCommentsInput[]
    upsert?: likesUpsertWithWhereUniqueWithoutCommentsInput | likesUpsertWithWhereUniqueWithoutCommentsInput[]
    createMany?: likesCreateManyCommentsInputEnvelope
    set?: likesWhereUniqueInput | likesWhereUniqueInput[]
    disconnect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    delete?: likesWhereUniqueInput | likesWhereUniqueInput[]
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    update?: likesUpdateWithWhereUniqueWithoutCommentsInput | likesUpdateWithWhereUniqueWithoutCommentsInput[]
    updateMany?: likesUpdateManyWithWhereWithoutCommentsInput | likesUpdateManyWithWhereWithoutCommentsInput[]
    deleteMany?: likesScalarWhereInput | likesScalarWhereInput[]
  }

  export type commentsCreateNestedOneWithoutImagesInput = {
    create?: XOR<commentsCreateWithoutImagesInput, commentsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: commentsCreateOrConnectWithoutImagesInput
    connect?: commentsWhereUniqueInput
  }

  export type commentsUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<commentsCreateWithoutImagesInput, commentsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: commentsCreateOrConnectWithoutImagesInput
    upsert?: commentsUpsertWithoutImagesInput
    connect?: commentsWhereUniqueInput
    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutImagesInput, commentsUpdateWithoutImagesInput>, commentsUncheckedUpdateWithoutImagesInput>
  }

  export type commentsCreateNestedOneWithoutLikesInput = {
    create?: XOR<commentsCreateWithoutLikesInput, commentsUncheckedCreateWithoutLikesInput>
    connectOrCreate?: commentsCreateOrConnectWithoutLikesInput
    connect?: commentsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutLikesInput = {
    create?: XOR<usersCreateWithoutLikesInput, usersUncheckedCreateWithoutLikesInput>
    connectOrCreate?: usersCreateOrConnectWithoutLikesInput
    connect?: usersWhereUniqueInput
  }

  export type commentsUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<commentsCreateWithoutLikesInput, commentsUncheckedCreateWithoutLikesInput>
    connectOrCreate?: commentsCreateOrConnectWithoutLikesInput
    upsert?: commentsUpsertWithoutLikesInput
    connect?: commentsWhereUniqueInput
    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutLikesInput, commentsUpdateWithoutLikesInput>, commentsUncheckedUpdateWithoutLikesInput>
  }

  export type usersUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<usersCreateWithoutLikesInput, usersUncheckedCreateWithoutLikesInput>
    connectOrCreate?: usersCreateOrConnectWithoutLikesInput
    upsert?: usersUpsertWithoutLikesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLikesInput, usersUpdateWithoutLikesInput>, usersUncheckedUpdateWithoutLikesInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type usersCreateNestedOneWithoutStaking_poolsInput = {
    create?: XOR<usersCreateWithoutStaking_poolsInput, usersUncheckedCreateWithoutStaking_poolsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStaking_poolsInput
    connect?: usersWhereUniqueInput
  }

  export type tokensCreateNestedOneWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    create?: XOR<tokensCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, tokensUncheckedCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
    connectOrCreate?: tokensCreateOrConnectWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    connect?: tokensWhereUniqueInput
  }

  export type tokensCreateNestedOneWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    create?: XOR<tokensCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, tokensUncheckedCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
    connectOrCreate?: tokensCreateOrConnectWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
    connect?: tokensWhereUniqueInput
  }

  export type user_stakesCreateNestedManyWithoutStaking_poolsInput = {
    create?: XOR<user_stakesCreateWithoutStaking_poolsInput, user_stakesUncheckedCreateWithoutStaking_poolsInput> | user_stakesCreateWithoutStaking_poolsInput[] | user_stakesUncheckedCreateWithoutStaking_poolsInput[]
    connectOrCreate?: user_stakesCreateOrConnectWithoutStaking_poolsInput | user_stakesCreateOrConnectWithoutStaking_poolsInput[]
    createMany?: user_stakesCreateManyStaking_poolsInputEnvelope
    connect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
  }

  export type user_stakesUncheckedCreateNestedManyWithoutStaking_poolsInput = {
    create?: XOR<user_stakesCreateWithoutStaking_poolsInput, user_stakesUncheckedCreateWithoutStaking_poolsInput> | user_stakesCreateWithoutStaking_poolsInput[] | user_stakesUncheckedCreateWithoutStaking_poolsInput[]
    connectOrCreate?: user_stakesCreateOrConnectWithoutStaking_poolsInput | user_stakesCreateOrConnectWithoutStaking_poolsInput[]
    createMany?: user_stakesCreateManyStaking_poolsInputEnvelope
    connect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
  }

  export type EnumPoolTypeFieldUpdateOperationsInput = {
    set?: $Enums.PoolType
  }

  export type usersUpdateOneRequiredWithoutStaking_poolsNestedInput = {
    create?: XOR<usersCreateWithoutStaking_poolsInput, usersUncheckedCreateWithoutStaking_poolsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStaking_poolsInput
    upsert?: usersUpsertWithoutStaking_poolsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStaking_poolsInput, usersUpdateWithoutStaking_poolsInput>, usersUncheckedUpdateWithoutStaking_poolsInput>
  }

  export type tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput = {
    create?: XOR<tokensCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, tokensUncheckedCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
    connectOrCreate?: tokensCreateOrConnectWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    upsert?: tokensUpsertWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    connect?: tokensWhereUniqueInput
    update?: XOR<XOR<tokensUpdateToOneWithWhereWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, tokensUpdateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>, tokensUncheckedUpdateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
  }

  export type tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput = {
    create?: XOR<tokensCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, tokensUncheckedCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
    connectOrCreate?: tokensCreateOrConnectWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
    upsert?: tokensUpsertWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
    connect?: tokensWhereUniqueInput
    update?: XOR<XOR<tokensUpdateToOneWithWhereWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, tokensUpdateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>, tokensUncheckedUpdateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
  }

  export type user_stakesUpdateManyWithoutStaking_poolsNestedInput = {
    create?: XOR<user_stakesCreateWithoutStaking_poolsInput, user_stakesUncheckedCreateWithoutStaking_poolsInput> | user_stakesCreateWithoutStaking_poolsInput[] | user_stakesUncheckedCreateWithoutStaking_poolsInput[]
    connectOrCreate?: user_stakesCreateOrConnectWithoutStaking_poolsInput | user_stakesCreateOrConnectWithoutStaking_poolsInput[]
    upsert?: user_stakesUpsertWithWhereUniqueWithoutStaking_poolsInput | user_stakesUpsertWithWhereUniqueWithoutStaking_poolsInput[]
    createMany?: user_stakesCreateManyStaking_poolsInputEnvelope
    set?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    disconnect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    delete?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    connect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    update?: user_stakesUpdateWithWhereUniqueWithoutStaking_poolsInput | user_stakesUpdateWithWhereUniqueWithoutStaking_poolsInput[]
    updateMany?: user_stakesUpdateManyWithWhereWithoutStaking_poolsInput | user_stakesUpdateManyWithWhereWithoutStaking_poolsInput[]
    deleteMany?: user_stakesScalarWhereInput | user_stakesScalarWhereInput[]
  }

  export type user_stakesUncheckedUpdateManyWithoutStaking_poolsNestedInput = {
    create?: XOR<user_stakesCreateWithoutStaking_poolsInput, user_stakesUncheckedCreateWithoutStaking_poolsInput> | user_stakesCreateWithoutStaking_poolsInput[] | user_stakesUncheckedCreateWithoutStaking_poolsInput[]
    connectOrCreate?: user_stakesCreateOrConnectWithoutStaking_poolsInput | user_stakesCreateOrConnectWithoutStaking_poolsInput[]
    upsert?: user_stakesUpsertWithWhereUniqueWithoutStaking_poolsInput | user_stakesUpsertWithWhereUniqueWithoutStaking_poolsInput[]
    createMany?: user_stakesCreateManyStaking_poolsInputEnvelope
    set?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    disconnect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    delete?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    connect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    update?: user_stakesUpdateWithWhereUniqueWithoutStaking_poolsInput | user_stakesUpdateWithWhereUniqueWithoutStaking_poolsInput[]
    updateMany?: user_stakesUpdateManyWithWhereWithoutStaking_poolsInput | user_stakesUpdateManyWithWhereWithoutStaking_poolsInput[]
    deleteMany?: user_stakesScalarWhereInput | user_stakesScalarWhereInput[]
  }

  export type AmmpairCreateNestedManyWithoutToken0Input = {
    create?: XOR<AmmpairCreateWithoutToken0Input, AmmpairUncheckedCreateWithoutToken0Input> | AmmpairCreateWithoutToken0Input[] | AmmpairUncheckedCreateWithoutToken0Input[]
    connectOrCreate?: AmmpairCreateOrConnectWithoutToken0Input | AmmpairCreateOrConnectWithoutToken0Input[]
    createMany?: AmmpairCreateManyToken0InputEnvelope
    connect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
  }

  export type AmmpairCreateNestedManyWithoutToken1Input = {
    create?: XOR<AmmpairCreateWithoutToken1Input, AmmpairUncheckedCreateWithoutToken1Input> | AmmpairCreateWithoutToken1Input[] | AmmpairUncheckedCreateWithoutToken1Input[]
    connectOrCreate?: AmmpairCreateOrConnectWithoutToken1Input | AmmpairCreateOrConnectWithoutToken1Input[]
    createMany?: AmmpairCreateManyToken1InputEnvelope
    connect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
  }

  export type staking_poolsCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    create?: XOR<staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput> | staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[] | staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    createMany?: staking_poolsCreateManyTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInputEnvelope
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
  }

  export type staking_poolsCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    create?: XOR<staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput> | staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[] | staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    createMany?: staking_poolsCreateManyTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInputEnvelope
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
  }

  export type AmmpairUncheckedCreateNestedManyWithoutToken0Input = {
    create?: XOR<AmmpairCreateWithoutToken0Input, AmmpairUncheckedCreateWithoutToken0Input> | AmmpairCreateWithoutToken0Input[] | AmmpairUncheckedCreateWithoutToken0Input[]
    connectOrCreate?: AmmpairCreateOrConnectWithoutToken0Input | AmmpairCreateOrConnectWithoutToken0Input[]
    createMany?: AmmpairCreateManyToken0InputEnvelope
    connect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
  }

  export type AmmpairUncheckedCreateNestedManyWithoutToken1Input = {
    create?: XOR<AmmpairCreateWithoutToken1Input, AmmpairUncheckedCreateWithoutToken1Input> | AmmpairCreateWithoutToken1Input[] | AmmpairUncheckedCreateWithoutToken1Input[]
    connectOrCreate?: AmmpairCreateOrConnectWithoutToken1Input | AmmpairCreateOrConnectWithoutToken1Input[]
    createMany?: AmmpairCreateManyToken1InputEnvelope
    connect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
  }

  export type staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    create?: XOR<staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput> | staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[] | staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    createMany?: staking_poolsCreateManyTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInputEnvelope
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
  }

  export type staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    create?: XOR<staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput> | staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[] | staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    createMany?: staking_poolsCreateManyTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInputEnvelope
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
  }

  export type AmmpairUpdateManyWithoutToken0NestedInput = {
    create?: XOR<AmmpairCreateWithoutToken0Input, AmmpairUncheckedCreateWithoutToken0Input> | AmmpairCreateWithoutToken0Input[] | AmmpairUncheckedCreateWithoutToken0Input[]
    connectOrCreate?: AmmpairCreateOrConnectWithoutToken0Input | AmmpairCreateOrConnectWithoutToken0Input[]
    upsert?: AmmpairUpsertWithWhereUniqueWithoutToken0Input | AmmpairUpsertWithWhereUniqueWithoutToken0Input[]
    createMany?: AmmpairCreateManyToken0InputEnvelope
    set?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    disconnect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    delete?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    connect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    update?: AmmpairUpdateWithWhereUniqueWithoutToken0Input | AmmpairUpdateWithWhereUniqueWithoutToken0Input[]
    updateMany?: AmmpairUpdateManyWithWhereWithoutToken0Input | AmmpairUpdateManyWithWhereWithoutToken0Input[]
    deleteMany?: AmmpairScalarWhereInput | AmmpairScalarWhereInput[]
  }

  export type AmmpairUpdateManyWithoutToken1NestedInput = {
    create?: XOR<AmmpairCreateWithoutToken1Input, AmmpairUncheckedCreateWithoutToken1Input> | AmmpairCreateWithoutToken1Input[] | AmmpairUncheckedCreateWithoutToken1Input[]
    connectOrCreate?: AmmpairCreateOrConnectWithoutToken1Input | AmmpairCreateOrConnectWithoutToken1Input[]
    upsert?: AmmpairUpsertWithWhereUniqueWithoutToken1Input | AmmpairUpsertWithWhereUniqueWithoutToken1Input[]
    createMany?: AmmpairCreateManyToken1InputEnvelope
    set?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    disconnect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    delete?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    connect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    update?: AmmpairUpdateWithWhereUniqueWithoutToken1Input | AmmpairUpdateWithWhereUniqueWithoutToken1Input[]
    updateMany?: AmmpairUpdateManyWithWhereWithoutToken1Input | AmmpairUpdateManyWithWhereWithoutToken1Input[]
    deleteMany?: AmmpairScalarWhereInput | AmmpairScalarWhereInput[]
  }

  export type staking_poolsUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput = {
    create?: XOR<staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput> | staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[] | staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    upsert?: staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    createMany?: staking_poolsCreateManyTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInputEnvelope
    set?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    disconnect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    delete?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    update?: staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    updateMany?: staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    deleteMany?: staking_poolsScalarWhereInput | staking_poolsScalarWhereInput[]
  }

  export type staking_poolsUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput = {
    create?: XOR<staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput> | staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[] | staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    upsert?: staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    createMany?: staking_poolsCreateManyTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInputEnvelope
    set?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    disconnect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    delete?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    update?: staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    updateMany?: staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    deleteMany?: staking_poolsScalarWhereInput | staking_poolsScalarWhereInput[]
  }

  export type AmmpairUncheckedUpdateManyWithoutToken0NestedInput = {
    create?: XOR<AmmpairCreateWithoutToken0Input, AmmpairUncheckedCreateWithoutToken0Input> | AmmpairCreateWithoutToken0Input[] | AmmpairUncheckedCreateWithoutToken0Input[]
    connectOrCreate?: AmmpairCreateOrConnectWithoutToken0Input | AmmpairCreateOrConnectWithoutToken0Input[]
    upsert?: AmmpairUpsertWithWhereUniqueWithoutToken0Input | AmmpairUpsertWithWhereUniqueWithoutToken0Input[]
    createMany?: AmmpairCreateManyToken0InputEnvelope
    set?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    disconnect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    delete?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    connect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    update?: AmmpairUpdateWithWhereUniqueWithoutToken0Input | AmmpairUpdateWithWhereUniqueWithoutToken0Input[]
    updateMany?: AmmpairUpdateManyWithWhereWithoutToken0Input | AmmpairUpdateManyWithWhereWithoutToken0Input[]
    deleteMany?: AmmpairScalarWhereInput | AmmpairScalarWhereInput[]
  }

  export type AmmpairUncheckedUpdateManyWithoutToken1NestedInput = {
    create?: XOR<AmmpairCreateWithoutToken1Input, AmmpairUncheckedCreateWithoutToken1Input> | AmmpairCreateWithoutToken1Input[] | AmmpairUncheckedCreateWithoutToken1Input[]
    connectOrCreate?: AmmpairCreateOrConnectWithoutToken1Input | AmmpairCreateOrConnectWithoutToken1Input[]
    upsert?: AmmpairUpsertWithWhereUniqueWithoutToken1Input | AmmpairUpsertWithWhereUniqueWithoutToken1Input[]
    createMany?: AmmpairCreateManyToken1InputEnvelope
    set?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    disconnect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    delete?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    connect?: AmmpairWhereUniqueInput | AmmpairWhereUniqueInput[]
    update?: AmmpairUpdateWithWhereUniqueWithoutToken1Input | AmmpairUpdateWithWhereUniqueWithoutToken1Input[]
    updateMany?: AmmpairUpdateManyWithWhereWithoutToken1Input | AmmpairUpdateManyWithWhereWithoutToken1Input[]
    deleteMany?: AmmpairScalarWhereInput | AmmpairScalarWhereInput[]
  }

  export type staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput = {
    create?: XOR<staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput> | staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[] | staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    upsert?: staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    createMany?: staking_poolsCreateManyTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInputEnvelope
    set?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    disconnect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    delete?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    update?: staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    updateMany?: staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    deleteMany?: staking_poolsScalarWhereInput | staking_poolsScalarWhereInput[]
  }

  export type staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput = {
    create?: XOR<staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput> | staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[] | staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    upsert?: staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    createMany?: staking_poolsCreateManyTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInputEnvelope
    set?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    disconnect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    delete?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    update?: staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    updateMany?: staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    deleteMany?: staking_poolsScalarWhereInput | staking_poolsScalarWhereInput[]
  }

  export type PoolsDBCreateNestedOneWithoutTrust_poolsInput = {
    create?: XOR<PoolsDBCreateWithoutTrust_poolsInput, PoolsDBUncheckedCreateWithoutTrust_poolsInput>
    connectOrCreate?: PoolsDBCreateOrConnectWithoutTrust_poolsInput
    connect?: PoolsDBWhereUniqueInput
  }

  export type PoolsDBUpdateOneRequiredWithoutTrust_poolsNestedInput = {
    create?: XOR<PoolsDBCreateWithoutTrust_poolsInput, PoolsDBUncheckedCreateWithoutTrust_poolsInput>
    connectOrCreate?: PoolsDBCreateOrConnectWithoutTrust_poolsInput
    upsert?: PoolsDBUpsertWithoutTrust_poolsInput
    connect?: PoolsDBWhereUniqueInput
    update?: XOR<XOR<PoolsDBUpdateToOneWithWhereWithoutTrust_poolsInput, PoolsDBUpdateWithoutTrust_poolsInput>, PoolsDBUncheckedUpdateWithoutTrust_poolsInput>
  }

  export type staking_poolsCreateNestedOneWithoutUser_stakesInput = {
    create?: XOR<staking_poolsCreateWithoutUser_stakesInput, staking_poolsUncheckedCreateWithoutUser_stakesInput>
    connectOrCreate?: staking_poolsCreateOrConnectWithoutUser_stakesInput
    connect?: staking_poolsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUser_stakesInput = {
    create?: XOR<usersCreateWithoutUser_stakesInput, usersUncheckedCreateWithoutUser_stakesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_stakesInput
    connect?: usersWhereUniqueInput
  }

  export type staking_poolsUpdateOneRequiredWithoutUser_stakesNestedInput = {
    create?: XOR<staking_poolsCreateWithoutUser_stakesInput, staking_poolsUncheckedCreateWithoutUser_stakesInput>
    connectOrCreate?: staking_poolsCreateOrConnectWithoutUser_stakesInput
    upsert?: staking_poolsUpsertWithoutUser_stakesInput
    connect?: staking_poolsWhereUniqueInput
    update?: XOR<XOR<staking_poolsUpdateToOneWithWhereWithoutUser_stakesInput, staking_poolsUpdateWithoutUser_stakesInput>, staking_poolsUncheckedUpdateWithoutUser_stakesInput>
  }

  export type usersUpdateOneRequiredWithoutUser_stakesNestedInput = {
    create?: XOR<usersCreateWithoutUser_stakesInput, usersUncheckedCreateWithoutUser_stakesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_stakesInput
    upsert?: usersUpsertWithoutUser_stakesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_stakesInput, usersUpdateWithoutUser_stakesInput>, usersUncheckedUpdateWithoutUser_stakesInput>
  }

  export type commentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type likesCreateNestedManyWithoutUsersInput = {
    create?: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput> | likesCreateWithoutUsersInput[] | likesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: likesCreateOrConnectWithoutUsersInput | likesCreateOrConnectWithoutUsersInput[]
    createMany?: likesCreateManyUsersInputEnvelope
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
  }

  export type staking_poolsCreateNestedManyWithoutUsersInput = {
    create?: XOR<staking_poolsCreateWithoutUsersInput, staking_poolsUncheckedCreateWithoutUsersInput> | staking_poolsCreateWithoutUsersInput[] | staking_poolsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutUsersInput | staking_poolsCreateOrConnectWithoutUsersInput[]
    createMany?: staking_poolsCreateManyUsersInputEnvelope
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
  }

  export type user_stakesCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_stakesCreateWithoutUsersInput, user_stakesUncheckedCreateWithoutUsersInput> | user_stakesCreateWithoutUsersInput[] | user_stakesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_stakesCreateOrConnectWithoutUsersInput | user_stakesCreateOrConnectWithoutUsersInput[]
    createMany?: user_stakesCreateManyUsersInputEnvelope
    connect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
  }

  export type token_holdersCreateNestedManyWithoutUserInput = {
    create?: XOR<token_holdersCreateWithoutUserInput, token_holdersUncheckedCreateWithoutUserInput> | token_holdersCreateWithoutUserInput[] | token_holdersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: token_holdersCreateOrConnectWithoutUserInput | token_holdersCreateOrConnectWithoutUserInput[]
    createMany?: token_holdersCreateManyUserInputEnvelope
    connect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type likesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput> | likesCreateWithoutUsersInput[] | likesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: likesCreateOrConnectWithoutUsersInput | likesCreateOrConnectWithoutUsersInput[]
    createMany?: likesCreateManyUsersInputEnvelope
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
  }

  export type staking_poolsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<staking_poolsCreateWithoutUsersInput, staking_poolsUncheckedCreateWithoutUsersInput> | staking_poolsCreateWithoutUsersInput[] | staking_poolsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutUsersInput | staking_poolsCreateOrConnectWithoutUsersInput[]
    createMany?: staking_poolsCreateManyUsersInputEnvelope
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
  }

  export type user_stakesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_stakesCreateWithoutUsersInput, user_stakesUncheckedCreateWithoutUsersInput> | user_stakesCreateWithoutUsersInput[] | user_stakesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_stakesCreateOrConnectWithoutUsersInput | user_stakesCreateOrConnectWithoutUsersInput[]
    createMany?: user_stakesCreateManyUsersInputEnvelope
    connect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
  }

  export type token_holdersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<token_holdersCreateWithoutUserInput, token_holdersUncheckedCreateWithoutUserInput> | token_holdersCreateWithoutUserInput[] | token_holdersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: token_holdersCreateOrConnectWithoutUserInput | token_holdersCreateOrConnectWithoutUserInput[]
    createMany?: token_holdersCreateManyUserInputEnvelope
    connect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
  }

  export type commentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUsersInput | commentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUsersInput | commentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUsersInput | commentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type likesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput> | likesCreateWithoutUsersInput[] | likesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: likesCreateOrConnectWithoutUsersInput | likesCreateOrConnectWithoutUsersInput[]
    upsert?: likesUpsertWithWhereUniqueWithoutUsersInput | likesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: likesCreateManyUsersInputEnvelope
    set?: likesWhereUniqueInput | likesWhereUniqueInput[]
    disconnect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    delete?: likesWhereUniqueInput | likesWhereUniqueInput[]
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    update?: likesUpdateWithWhereUniqueWithoutUsersInput | likesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: likesUpdateManyWithWhereWithoutUsersInput | likesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: likesScalarWhereInput | likesScalarWhereInput[]
  }

  export type staking_poolsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<staking_poolsCreateWithoutUsersInput, staking_poolsUncheckedCreateWithoutUsersInput> | staking_poolsCreateWithoutUsersInput[] | staking_poolsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutUsersInput | staking_poolsCreateOrConnectWithoutUsersInput[]
    upsert?: staking_poolsUpsertWithWhereUniqueWithoutUsersInput | staking_poolsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: staking_poolsCreateManyUsersInputEnvelope
    set?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    disconnect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    delete?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    update?: staking_poolsUpdateWithWhereUniqueWithoutUsersInput | staking_poolsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: staking_poolsUpdateManyWithWhereWithoutUsersInput | staking_poolsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: staking_poolsScalarWhereInput | staking_poolsScalarWhereInput[]
  }

  export type user_stakesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_stakesCreateWithoutUsersInput, user_stakesUncheckedCreateWithoutUsersInput> | user_stakesCreateWithoutUsersInput[] | user_stakesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_stakesCreateOrConnectWithoutUsersInput | user_stakesCreateOrConnectWithoutUsersInput[]
    upsert?: user_stakesUpsertWithWhereUniqueWithoutUsersInput | user_stakesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_stakesCreateManyUsersInputEnvelope
    set?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    disconnect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    delete?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    connect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    update?: user_stakesUpdateWithWhereUniqueWithoutUsersInput | user_stakesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_stakesUpdateManyWithWhereWithoutUsersInput | user_stakesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_stakesScalarWhereInput | user_stakesScalarWhereInput[]
  }

  export type token_holdersUpdateManyWithoutUserNestedInput = {
    create?: XOR<token_holdersCreateWithoutUserInput, token_holdersUncheckedCreateWithoutUserInput> | token_holdersCreateWithoutUserInput[] | token_holdersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: token_holdersCreateOrConnectWithoutUserInput | token_holdersCreateOrConnectWithoutUserInput[]
    upsert?: token_holdersUpsertWithWhereUniqueWithoutUserInput | token_holdersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: token_holdersCreateManyUserInputEnvelope
    set?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    disconnect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    delete?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    connect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    update?: token_holdersUpdateWithWhereUniqueWithoutUserInput | token_holdersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: token_holdersUpdateManyWithWhereWithoutUserInput | token_holdersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: token_holdersScalarWhereInput | token_holdersScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUsersInput | commentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUsersInput | commentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUsersInput | commentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type likesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput> | likesCreateWithoutUsersInput[] | likesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: likesCreateOrConnectWithoutUsersInput | likesCreateOrConnectWithoutUsersInput[]
    upsert?: likesUpsertWithWhereUniqueWithoutUsersInput | likesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: likesCreateManyUsersInputEnvelope
    set?: likesWhereUniqueInput | likesWhereUniqueInput[]
    disconnect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    delete?: likesWhereUniqueInput | likesWhereUniqueInput[]
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    update?: likesUpdateWithWhereUniqueWithoutUsersInput | likesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: likesUpdateManyWithWhereWithoutUsersInput | likesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: likesScalarWhereInput | likesScalarWhereInput[]
  }

  export type staking_poolsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<staking_poolsCreateWithoutUsersInput, staking_poolsUncheckedCreateWithoutUsersInput> | staking_poolsCreateWithoutUsersInput[] | staking_poolsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: staking_poolsCreateOrConnectWithoutUsersInput | staking_poolsCreateOrConnectWithoutUsersInput[]
    upsert?: staking_poolsUpsertWithWhereUniqueWithoutUsersInput | staking_poolsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: staking_poolsCreateManyUsersInputEnvelope
    set?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    disconnect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    delete?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    connect?: staking_poolsWhereUniqueInput | staking_poolsWhereUniqueInput[]
    update?: staking_poolsUpdateWithWhereUniqueWithoutUsersInput | staking_poolsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: staking_poolsUpdateManyWithWhereWithoutUsersInput | staking_poolsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: staking_poolsScalarWhereInput | staking_poolsScalarWhereInput[]
  }

  export type user_stakesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_stakesCreateWithoutUsersInput, user_stakesUncheckedCreateWithoutUsersInput> | user_stakesCreateWithoutUsersInput[] | user_stakesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_stakesCreateOrConnectWithoutUsersInput | user_stakesCreateOrConnectWithoutUsersInput[]
    upsert?: user_stakesUpsertWithWhereUniqueWithoutUsersInput | user_stakesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_stakesCreateManyUsersInputEnvelope
    set?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    disconnect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    delete?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    connect?: user_stakesWhereUniqueInput | user_stakesWhereUniqueInput[]
    update?: user_stakesUpdateWithWhereUniqueWithoutUsersInput | user_stakesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_stakesUpdateManyWithWhereWithoutUsersInput | user_stakesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_stakesScalarWhereInput | user_stakesScalarWhereInput[]
  }

  export type token_holdersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<token_holdersCreateWithoutUserInput, token_holdersUncheckedCreateWithoutUserInput> | token_holdersCreateWithoutUserInput[] | token_holdersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: token_holdersCreateOrConnectWithoutUserInput | token_holdersCreateOrConnectWithoutUserInput[]
    upsert?: token_holdersUpsertWithWhereUniqueWithoutUserInput | token_holdersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: token_holdersCreateManyUserInputEnvelope
    set?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    disconnect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    delete?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    connect?: token_holdersWhereUniqueInput | token_holdersWhereUniqueInput[]
    update?: token_holdersUpdateWithWhereUniqueWithoutUserInput | token_holdersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: token_holdersUpdateManyWithWhereWithoutUserInput | token_holdersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: token_holdersScalarWhereInput | token_holdersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutToken_balancesInput = {
    create?: XOR<usersCreateWithoutToken_balancesInput, usersUncheckedCreateWithoutToken_balancesInput>
    connectOrCreate?: usersCreateOrConnectWithoutToken_balancesInput
    connect?: usersWhereUniqueInput
  }

  export type PoolsDBCreateNestedOneWithoutHoldersInput = {
    create?: XOR<PoolsDBCreateWithoutHoldersInput, PoolsDBUncheckedCreateWithoutHoldersInput>
    connectOrCreate?: PoolsDBCreateOrConnectWithoutHoldersInput
    connect?: PoolsDBWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutToken_balancesNestedInput = {
    create?: XOR<usersCreateWithoutToken_balancesInput, usersUncheckedCreateWithoutToken_balancesInput>
    connectOrCreate?: usersCreateOrConnectWithoutToken_balancesInput
    upsert?: usersUpsertWithoutToken_balancesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutToken_balancesInput, usersUpdateWithoutToken_balancesInput>, usersUncheckedUpdateWithoutToken_balancesInput>
  }

  export type PoolsDBUpdateOneRequiredWithoutHoldersNestedInput = {
    create?: XOR<PoolsDBCreateWithoutHoldersInput, PoolsDBUncheckedCreateWithoutHoldersInput>
    connectOrCreate?: PoolsDBCreateOrConnectWithoutHoldersInput
    upsert?: PoolsDBUpsertWithoutHoldersInput
    connect?: PoolsDBWhereUniqueInput
    update?: XOR<XOR<PoolsDBUpdateToOneWithWhereWithoutHoldersInput, PoolsDBUpdateWithoutHoldersInput>, PoolsDBUncheckedUpdateWithoutHoldersInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumAmmVersionFilter<$PrismaModel = never> = {
    equals?: $Enums.AmmVersion | EnumAmmVersionFieldRefInput<$PrismaModel>
    in?: $Enums.AmmVersion[] | ListEnumAmmVersionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AmmVersion[] | ListEnumAmmVersionFieldRefInput<$PrismaModel>
    not?: NestedEnumAmmVersionFilter<$PrismaModel> | $Enums.AmmVersion
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAmmVersionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AmmVersion | EnumAmmVersionFieldRefInput<$PrismaModel>
    in?: $Enums.AmmVersion[] | ListEnumAmmVersionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AmmVersion[] | ListEnumAmmVersionFieldRefInput<$PrismaModel>
    not?: NestedEnumAmmVersionWithAggregatesFilter<$PrismaModel> | $Enums.AmmVersion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAmmVersionFilter<$PrismaModel>
    _max?: NestedEnumAmmVersionFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumPoolTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolType | EnumPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoolType[] | ListEnumPoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoolType[] | ListEnumPoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoolTypeFilter<$PrismaModel> | $Enums.PoolType
  }

  export type NestedEnumPoolTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolType | EnumPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoolType[] | ListEnumPoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoolType[] | ListEnumPoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoolTypeWithAggregatesFilter<$PrismaModel> | $Enums.PoolType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoolTypeFilter<$PrismaModel>
    _max?: NestedEnumPoolTypeFilter<$PrismaModel>
  }

  export type tokensCreateWithoutAmmpairsAsToken0Input = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken1?: AmmpairCreateNestedManyWithoutToken1Input
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type tokensUncheckedCreateWithoutAmmpairsAsToken0Input = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken1?: AmmpairUncheckedCreateNestedManyWithoutToken1Input
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type tokensCreateOrConnectWithoutAmmpairsAsToken0Input = {
    where: tokensWhereUniqueInput
    create: XOR<tokensCreateWithoutAmmpairsAsToken0Input, tokensUncheckedCreateWithoutAmmpairsAsToken0Input>
  }

  export type tokensCreateWithoutAmmpairsAsToken1Input = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken0?: AmmpairCreateNestedManyWithoutToken0Input
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type tokensUncheckedCreateWithoutAmmpairsAsToken1Input = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken0?: AmmpairUncheckedCreateNestedManyWithoutToken0Input
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type tokensCreateOrConnectWithoutAmmpairsAsToken1Input = {
    where: tokensWhereUniqueInput
    create: XOR<tokensCreateWithoutAmmpairsAsToken1Input, tokensUncheckedCreateWithoutAmmpairsAsToken1Input>
  }

  export type tokensUpsertWithoutAmmpairsAsToken0Input = {
    update: XOR<tokensUpdateWithoutAmmpairsAsToken0Input, tokensUncheckedUpdateWithoutAmmpairsAsToken0Input>
    create: XOR<tokensCreateWithoutAmmpairsAsToken0Input, tokensUncheckedCreateWithoutAmmpairsAsToken0Input>
    where?: tokensWhereInput
  }

  export type tokensUpdateToOneWithWhereWithoutAmmpairsAsToken0Input = {
    where?: tokensWhereInput
    data: XOR<tokensUpdateWithoutAmmpairsAsToken0Input, tokensUncheckedUpdateWithoutAmmpairsAsToken0Input>
  }

  export type tokensUpdateWithoutAmmpairsAsToken0Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken1?: AmmpairUpdateManyWithoutToken1NestedInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type tokensUncheckedUpdateWithoutAmmpairsAsToken0Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken1?: AmmpairUncheckedUpdateManyWithoutToken1NestedInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type tokensUpsertWithoutAmmpairsAsToken1Input = {
    update: XOR<tokensUpdateWithoutAmmpairsAsToken1Input, tokensUncheckedUpdateWithoutAmmpairsAsToken1Input>
    create: XOR<tokensCreateWithoutAmmpairsAsToken1Input, tokensUncheckedCreateWithoutAmmpairsAsToken1Input>
    where?: tokensWhereInput
  }

  export type tokensUpdateToOneWithWhereWithoutAmmpairsAsToken1Input = {
    where?: tokensWhereInput
    data: XOR<tokensUpdateWithoutAmmpairsAsToken1Input, tokensUncheckedUpdateWithoutAmmpairsAsToken1Input>
  }

  export type tokensUpdateWithoutAmmpairsAsToken1Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken0?: AmmpairUpdateManyWithoutToken0NestedInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type tokensUncheckedUpdateWithoutAmmpairsAsToken1Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken0?: AmmpairUncheckedUpdateManyWithoutToken0NestedInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type commentsCreateWithoutPoolsDBInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    likeCount?: number
    users: usersCreateNestedOneWithoutCommentsInput
    images?: imagesCreateNestedManyWithoutCommentsInput
    likes?: likesCreateNestedManyWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutPoolsDBInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    userNetwork: string
    userWalletAddress: string
    displayOrder?: number | null
    likeCount?: number
    images?: imagesUncheckedCreateNestedManyWithoutCommentsInput
    likes?: likesUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type commentsCreateOrConnectWithoutPoolsDBInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutPoolsDBInput, commentsUncheckedCreateWithoutPoolsDBInput>
  }

  export type commentsCreateManyPoolsDBInputEnvelope = {
    data: commentsCreateManyPoolsDBInput | commentsCreateManyPoolsDBInput[]
    skipDuplicates?: boolean
  }

  export type trust_poolsCreateWithoutPoolsDBInput = {
    network: string
    tokenAddress: string
    isActive?: boolean
    totalStakedAmount?: string
    stakerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type trust_poolsUncheckedCreateWithoutPoolsDBInput = {
    id?: number
    network: string
    tokenAddress: string
    isActive?: boolean
    totalStakedAmount?: string
    stakerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type trust_poolsCreateOrConnectWithoutPoolsDBInput = {
    where: trust_poolsWhereUniqueInput
    create: XOR<trust_poolsCreateWithoutPoolsDBInput, trust_poolsUncheckedCreateWithoutPoolsDBInput>
  }

  export type token_holdersCreateWithoutPoolInput = {
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutToken_balancesInput
  }

  export type token_holdersUncheckedCreateWithoutPoolInput = {
    userWalletAddress: string
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type token_holdersCreateOrConnectWithoutPoolInput = {
    where: token_holdersWhereUniqueInput
    create: XOR<token_holdersCreateWithoutPoolInput, token_holdersUncheckedCreateWithoutPoolInput>
  }

  export type token_holdersCreateManyPoolInputEnvelope = {
    data: token_holdersCreateManyPoolInput | token_holdersCreateManyPoolInput[]
    skipDuplicates?: boolean
  }

  export type commentsUpsertWithWhereUniqueWithoutPoolsDBInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutPoolsDBInput, commentsUncheckedUpdateWithoutPoolsDBInput>
    create: XOR<commentsCreateWithoutPoolsDBInput, commentsUncheckedCreateWithoutPoolsDBInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutPoolsDBInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutPoolsDBInput, commentsUncheckedUpdateWithoutPoolsDBInput>
  }

  export type commentsUpdateManyWithWhereWithoutPoolsDBInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutPoolsDBInput>
  }

  export type commentsScalarWhereInput = {
    AND?: commentsScalarWhereInput | commentsScalarWhereInput[]
    OR?: commentsScalarWhereInput[]
    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[]
    id?: IntFilter<"comments"> | number
    text?: StringFilter<"comments"> | string
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
    poolId?: IntFilter<"comments"> | number
    network?: StringFilter<"comments"> | string
    userNetwork?: StringFilter<"comments"> | string
    userWalletAddress?: StringFilter<"comments"> | string
    displayOrder?: IntNullableFilter<"comments"> | number | null
    likeCount?: IntFilter<"comments"> | number
    poolNetwork?: StringFilter<"comments"> | string
  }

  export type trust_poolsUpsertWithoutPoolsDBInput = {
    update: XOR<trust_poolsUpdateWithoutPoolsDBInput, trust_poolsUncheckedUpdateWithoutPoolsDBInput>
    create: XOR<trust_poolsCreateWithoutPoolsDBInput, trust_poolsUncheckedCreateWithoutPoolsDBInput>
    where?: trust_poolsWhereInput
  }

  export type trust_poolsUpdateToOneWithWhereWithoutPoolsDBInput = {
    where?: trust_poolsWhereInput
    data: XOR<trust_poolsUpdateWithoutPoolsDBInput, trust_poolsUncheckedUpdateWithoutPoolsDBInput>
  }

  export type trust_poolsUpdateWithoutPoolsDBInput = {
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    stakerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trust_poolsUncheckedUpdateWithoutPoolsDBInput = {
    id?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    stakerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_holdersUpsertWithWhereUniqueWithoutPoolInput = {
    where: token_holdersWhereUniqueInput
    update: XOR<token_holdersUpdateWithoutPoolInput, token_holdersUncheckedUpdateWithoutPoolInput>
    create: XOR<token_holdersCreateWithoutPoolInput, token_holdersUncheckedCreateWithoutPoolInput>
  }

  export type token_holdersUpdateWithWhereUniqueWithoutPoolInput = {
    where: token_holdersWhereUniqueInput
    data: XOR<token_holdersUpdateWithoutPoolInput, token_holdersUncheckedUpdateWithoutPoolInput>
  }

  export type token_holdersUpdateManyWithWhereWithoutPoolInput = {
    where: token_holdersScalarWhereInput
    data: XOR<token_holdersUpdateManyMutationInput, token_holdersUncheckedUpdateManyWithoutPoolInput>
  }

  export type token_holdersScalarWhereInput = {
    AND?: token_holdersScalarWhereInput | token_holdersScalarWhereInput[]
    OR?: token_holdersScalarWhereInput[]
    NOT?: token_holdersScalarWhereInput | token_holdersScalarWhereInput[]
    network?: StringFilter<"token_holders"> | string
    userWalletAddress?: StringFilter<"token_holders"> | string
    tokenAddress?: StringFilter<"token_holders"> | string
    balance?: BigIntFilter<"token_holders"> | bigint | number
    createdAt?: DateTimeFilter<"token_holders"> | Date | string
    updatedAt?: DateTimeFilter<"token_holders"> | Date | string
  }

  export type PoolsDBCreateWithoutCommentsInput = {
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
    trust_pools?: trust_poolsCreateNestedOneWithoutPoolsDBInput
    holders?: token_holdersCreateNestedManyWithoutPoolInput
  }

  export type PoolsDBUncheckedCreateWithoutCommentsInput = {
    id?: number
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
    trust_pools?: trust_poolsUncheckedCreateNestedOneWithoutPoolsDBInput
    holders?: token_holdersUncheckedCreateNestedManyWithoutPoolInput
  }

  export type PoolsDBCreateOrConnectWithoutCommentsInput = {
    where: PoolsDBWhereUniqueInput
    create: XOR<PoolsDBCreateWithoutCommentsInput, PoolsDBUncheckedCreateWithoutCommentsInput>
  }

  export type usersCreateWithoutCommentsInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    likes?: likesCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutCommentsInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsUncheckedCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutCommentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
  }

  export type imagesCreateWithoutCommentsInput = {
    url: string
    altText?: string | null
    createdAt?: Date | string
  }

  export type imagesUncheckedCreateWithoutCommentsInput = {
    id?: number
    url: string
    altText?: string | null
    createdAt?: Date | string
  }

  export type imagesCreateOrConnectWithoutCommentsInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutCommentsInput, imagesUncheckedCreateWithoutCommentsInput>
  }

  export type imagesCreateManyCommentsInputEnvelope = {
    data: imagesCreateManyCommentsInput | imagesCreateManyCommentsInput[]
    skipDuplicates?: boolean
  }

  export type likesCreateWithoutCommentsInput = {
    createdAt?: Date | string
    network: string
    users: usersCreateNestedOneWithoutLikesInput
  }

  export type likesUncheckedCreateWithoutCommentsInput = {
    id?: number
    createdAt?: Date | string
    network: string
    userNetwork: string
    userWalletAddress: string
  }

  export type likesCreateOrConnectWithoutCommentsInput = {
    where: likesWhereUniqueInput
    create: XOR<likesCreateWithoutCommentsInput, likesUncheckedCreateWithoutCommentsInput>
  }

  export type likesCreateManyCommentsInputEnvelope = {
    data: likesCreateManyCommentsInput | likesCreateManyCommentsInput[]
    skipDuplicates?: boolean
  }

  export type PoolsDBUpsertWithoutCommentsInput = {
    update: XOR<PoolsDBUpdateWithoutCommentsInput, PoolsDBUncheckedUpdateWithoutCommentsInput>
    create: XOR<PoolsDBCreateWithoutCommentsInput, PoolsDBUncheckedCreateWithoutCommentsInput>
    where?: PoolsDBWhereInput
  }

  export type PoolsDBUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PoolsDBWhereInput
    data: XOR<PoolsDBUpdateWithoutCommentsInput, PoolsDBUncheckedUpdateWithoutCommentsInput>
  }

  export type PoolsDBUpdateWithoutCommentsInput = {
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
    trust_pools?: trust_poolsUpdateOneWithoutPoolsDBNestedInput
    holders?: token_holdersUpdateManyWithoutPoolNestedInput
  }

  export type PoolsDBUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
    trust_pools?: trust_poolsUncheckedUpdateOneWithoutPoolsDBNestedInput
    holders?: token_holdersUncheckedUpdateManyWithoutPoolNestedInput
  }

  export type usersUpsertWithoutCommentsInput = {
    update: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>
    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCommentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>
  }

  export type usersUpdateWithoutCommentsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    likes?: likesUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutCommentsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUncheckedUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUncheckedUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type imagesUpsertWithWhereUniqueWithoutCommentsInput = {
    where: imagesWhereUniqueInput
    update: XOR<imagesUpdateWithoutCommentsInput, imagesUncheckedUpdateWithoutCommentsInput>
    create: XOR<imagesCreateWithoutCommentsInput, imagesUncheckedCreateWithoutCommentsInput>
  }

  export type imagesUpdateWithWhereUniqueWithoutCommentsInput = {
    where: imagesWhereUniqueInput
    data: XOR<imagesUpdateWithoutCommentsInput, imagesUncheckedUpdateWithoutCommentsInput>
  }

  export type imagesUpdateManyWithWhereWithoutCommentsInput = {
    where: imagesScalarWhereInput
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyWithoutCommentsInput>
  }

  export type imagesScalarWhereInput = {
    AND?: imagesScalarWhereInput | imagesScalarWhereInput[]
    OR?: imagesScalarWhereInput[]
    NOT?: imagesScalarWhereInput | imagesScalarWhereInput[]
    id?: IntFilter<"images"> | number
    url?: StringFilter<"images"> | string
    altText?: StringNullableFilter<"images"> | string | null
    createdAt?: DateTimeFilter<"images"> | Date | string
    commentId?: IntFilter<"images"> | number
  }

  export type likesUpsertWithWhereUniqueWithoutCommentsInput = {
    where: likesWhereUniqueInput
    update: XOR<likesUpdateWithoutCommentsInput, likesUncheckedUpdateWithoutCommentsInput>
    create: XOR<likesCreateWithoutCommentsInput, likesUncheckedCreateWithoutCommentsInput>
  }

  export type likesUpdateWithWhereUniqueWithoutCommentsInput = {
    where: likesWhereUniqueInput
    data: XOR<likesUpdateWithoutCommentsInput, likesUncheckedUpdateWithoutCommentsInput>
  }

  export type likesUpdateManyWithWhereWithoutCommentsInput = {
    where: likesScalarWhereInput
    data: XOR<likesUpdateManyMutationInput, likesUncheckedUpdateManyWithoutCommentsInput>
  }

  export type likesScalarWhereInput = {
    AND?: likesScalarWhereInput | likesScalarWhereInput[]
    OR?: likesScalarWhereInput[]
    NOT?: likesScalarWhereInput | likesScalarWhereInput[]
    id?: IntFilter<"likes"> | number
    createdAt?: DateTimeFilter<"likes"> | Date | string
    commentId?: IntFilter<"likes"> | number
    network?: StringFilter<"likes"> | string
    userNetwork?: StringFilter<"likes"> | string
    userWalletAddress?: StringFilter<"likes"> | string
  }

  export type commentsCreateWithoutImagesInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    likeCount?: number
    PoolsDB: PoolsDBCreateNestedOneWithoutCommentsInput
    users: usersCreateNestedOneWithoutCommentsInput
    likes?: likesCreateNestedManyWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutImagesInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poolId: number
    network: string
    userNetwork: string
    userWalletAddress: string
    displayOrder?: number | null
    likeCount?: number
    poolNetwork: string
    likes?: likesUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type commentsCreateOrConnectWithoutImagesInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutImagesInput, commentsUncheckedCreateWithoutImagesInput>
  }

  export type commentsUpsertWithoutImagesInput = {
    update: XOR<commentsUpdateWithoutImagesInput, commentsUncheckedUpdateWithoutImagesInput>
    create: XOR<commentsCreateWithoutImagesInput, commentsUncheckedCreateWithoutImagesInput>
    where?: commentsWhereInput
  }

  export type commentsUpdateToOneWithWhereWithoutImagesInput = {
    where?: commentsWhereInput
    data: XOR<commentsUpdateWithoutImagesInput, commentsUncheckedUpdateWithoutImagesInput>
  }

  export type commentsUpdateWithoutImagesInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    PoolsDB?: PoolsDBUpdateOneRequiredWithoutCommentsNestedInput
    users?: usersUpdateOneRequiredWithoutCommentsNestedInput
    likes?: likesUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poolId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    poolNetwork?: StringFieldUpdateOperationsInput | string
    likes?: likesUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type commentsCreateWithoutLikesInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    likeCount?: number
    PoolsDB: PoolsDBCreateNestedOneWithoutCommentsInput
    users: usersCreateNestedOneWithoutCommentsInput
    images?: imagesCreateNestedManyWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutLikesInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poolId: number
    network: string
    userNetwork: string
    userWalletAddress: string
    displayOrder?: number | null
    likeCount?: number
    poolNetwork: string
    images?: imagesUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type commentsCreateOrConnectWithoutLikesInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutLikesInput, commentsUncheckedCreateWithoutLikesInput>
  }

  export type usersCreateWithoutLikesInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutLikesInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsUncheckedCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutLikesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLikesInput, usersUncheckedCreateWithoutLikesInput>
  }

  export type commentsUpsertWithoutLikesInput = {
    update: XOR<commentsUpdateWithoutLikesInput, commentsUncheckedUpdateWithoutLikesInput>
    create: XOR<commentsCreateWithoutLikesInput, commentsUncheckedCreateWithoutLikesInput>
    where?: commentsWhereInput
  }

  export type commentsUpdateToOneWithWhereWithoutLikesInput = {
    where?: commentsWhereInput
    data: XOR<commentsUpdateWithoutLikesInput, commentsUncheckedUpdateWithoutLikesInput>
  }

  export type commentsUpdateWithoutLikesInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    PoolsDB?: PoolsDBUpdateOneRequiredWithoutCommentsNestedInput
    users?: usersUpdateOneRequiredWithoutCommentsNestedInput
    images?: imagesUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poolId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    poolNetwork?: StringFieldUpdateOperationsInput | string
    images?: imagesUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type usersUpsertWithoutLikesInput = {
    update: XOR<usersUpdateWithoutLikesInput, usersUncheckedUpdateWithoutLikesInput>
    create: XOR<usersCreateWithoutLikesInput, usersUncheckedCreateWithoutLikesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLikesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLikesInput, usersUncheckedUpdateWithoutLikesInput>
  }

  export type usersUpdateWithoutLikesInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutLikesInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUncheckedUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUncheckedUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutStaking_poolsInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutStaking_poolsInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutStaking_poolsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStaking_poolsInput, usersUncheckedCreateWithoutStaking_poolsInput>
  }

  export type tokensCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken0?: AmmpairCreateNestedManyWithoutToken0Input
    ammpairsAsToken1?: AmmpairCreateNestedManyWithoutToken1Input
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type tokensUncheckedCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken0?: AmmpairUncheckedCreateNestedManyWithoutToken0Input
    ammpairsAsToken1?: AmmpairUncheckedCreateNestedManyWithoutToken1Input
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type tokensCreateOrConnectWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    where: tokensWhereUniqueInput
    create: XOR<tokensCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, tokensUncheckedCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
  }

  export type tokensCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken0?: AmmpairCreateNestedManyWithoutToken0Input
    ammpairsAsToken1?: AmmpairCreateNestedManyWithoutToken1Input
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
  }

  export type tokensUncheckedCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    id: string
    name?: string | null
    symbol?: string | null
    decimals?: number | null
    iconUri?: string | null
    projectUri?: string | null
    network: string
    lastMetadataAttempt?: Date | string | null
    metadataFetched?: boolean
    metadataStandard?: string | null
    verified?: boolean
    displayOrder?: number | null
    originalCoinType?: string | null
    circulatingSupply?: string | null
    createdAt?: Date | string
    marketCapUsd?: string | null
    priceChange24hPercent?: Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: Decimal | DecimalJsLike | number | string | null
    priceAnchor?: Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: Date | string | null
    totalSupply?: string | null
    updatedAt?: Date | string
    volume24hUsd?: string | null
    ammpairsAsToken0?: AmmpairUncheckedCreateNestedManyWithoutToken0Input
    ammpairsAsToken1?: AmmpairUncheckedCreateNestedManyWithoutToken1Input
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUncheckedCreateNestedManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
  }

  export type tokensCreateOrConnectWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    where: tokensWhereUniqueInput
    create: XOR<tokensCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, tokensUncheckedCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
  }

  export type user_stakesCreateWithoutStaking_poolsInput = {
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutUser_stakesInput
  }

  export type user_stakesUncheckedCreateWithoutStaking_poolsInput = {
    id?: number
    userNetwork: string
    userAddress: string
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_stakesCreateOrConnectWithoutStaking_poolsInput = {
    where: user_stakesWhereUniqueInput
    create: XOR<user_stakesCreateWithoutStaking_poolsInput, user_stakesUncheckedCreateWithoutStaking_poolsInput>
  }

  export type user_stakesCreateManyStaking_poolsInputEnvelope = {
    data: user_stakesCreateManyStaking_poolsInput | user_stakesCreateManyStaking_poolsInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutStaking_poolsInput = {
    update: XOR<usersUpdateWithoutStaking_poolsInput, usersUncheckedUpdateWithoutStaking_poolsInput>
    create: XOR<usersCreateWithoutStaking_poolsInput, usersUncheckedCreateWithoutStaking_poolsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStaking_poolsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStaking_poolsInput, usersUncheckedUpdateWithoutStaking_poolsInput>
  }

  export type usersUpdateWithoutStaking_poolsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutStaking_poolsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUncheckedUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tokensUpsertWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    update: XOR<tokensUpdateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, tokensUncheckedUpdateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
    create: XOR<tokensCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, tokensUncheckedCreateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
    where?: tokensWhereInput
  }

  export type tokensUpdateToOneWithWhereWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    where?: tokensWhereInput
    data: XOR<tokensUpdateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, tokensUncheckedUpdateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
  }

  export type tokensUpdateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken0?: AmmpairUpdateManyWithoutToken0NestedInput
    ammpairsAsToken1?: AmmpairUpdateManyWithoutToken1NestedInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type tokensUncheckedUpdateWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken0?: AmmpairUncheckedUpdateManyWithoutToken0NestedInput
    ammpairsAsToken1?: AmmpairUncheckedUpdateManyWithoutToken1NestedInput
    staking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type tokensUpsertWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    update: XOR<tokensUpdateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, tokensUncheckedUpdateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
    create: XOR<tokensCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, tokensUncheckedCreateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
    where?: tokensWhereInput
  }

  export type tokensUpdateToOneWithWhereWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    where?: tokensWhereInput
    data: XOR<tokensUpdateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, tokensUncheckedUpdateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
  }

  export type tokensUpdateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken0?: AmmpairUpdateManyWithoutToken0NestedInput
    ammpairsAsToken1?: AmmpairUpdateManyWithoutToken1NestedInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
  }

  export type tokensUncheckedUpdateWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: NullableIntFieldUpdateOperationsInput | number | null
    iconUri?: NullableStringFieldUpdateOperationsInput | string | null
    projectUri?: NullableStringFieldUpdateOperationsInput | string | null
    network?: StringFieldUpdateOperationsInput | string
    lastMetadataAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadataFetched?: BoolFieldUpdateOperationsInput | boolean
    metadataStandard?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    originalCoinType?: NullableStringFieldUpdateOperationsInput | string | null
    circulatingSupply?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketCapUsd?: NullableStringFieldUpdateOperationsInput | string | null
    priceChange24hPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceUsdCurrent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnchor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    volume24hUsd?: NullableStringFieldUpdateOperationsInput | string | null
    ammpairsAsToken0?: AmmpairUncheckedUpdateManyWithoutToken0NestedInput
    ammpairsAsToken1?: AmmpairUncheckedUpdateManyWithoutToken1NestedInput
    staking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
  }

  export type user_stakesUpsertWithWhereUniqueWithoutStaking_poolsInput = {
    where: user_stakesWhereUniqueInput
    update: XOR<user_stakesUpdateWithoutStaking_poolsInput, user_stakesUncheckedUpdateWithoutStaking_poolsInput>
    create: XOR<user_stakesCreateWithoutStaking_poolsInput, user_stakesUncheckedCreateWithoutStaking_poolsInput>
  }

  export type user_stakesUpdateWithWhereUniqueWithoutStaking_poolsInput = {
    where: user_stakesWhereUniqueInput
    data: XOR<user_stakesUpdateWithoutStaking_poolsInput, user_stakesUncheckedUpdateWithoutStaking_poolsInput>
  }

  export type user_stakesUpdateManyWithWhereWithoutStaking_poolsInput = {
    where: user_stakesScalarWhereInput
    data: XOR<user_stakesUpdateManyMutationInput, user_stakesUncheckedUpdateManyWithoutStaking_poolsInput>
  }

  export type user_stakesScalarWhereInput = {
    AND?: user_stakesScalarWhereInput | user_stakesScalarWhereInput[]
    OR?: user_stakesScalarWhereInput[]
    NOT?: user_stakesScalarWhereInput | user_stakesScalarWhereInput[]
    id?: IntFilter<"user_stakes"> | number
    poolId?: IntFilter<"user_stakes"> | number
    userNetwork?: StringFilter<"user_stakes"> | string
    userAddress?: StringFilter<"user_stakes"> | string
    stakedAmount?: StringFilter<"user_stakes"> | string
    rewardDebt?: StringFilter<"user_stakes"> | string
    lastClaimTimestamp?: BigIntNullableFilter<"user_stakes"> | bigint | number | null
    createdAt?: DateTimeFilter<"user_stakes"> | Date | string
    updatedAt?: DateTimeFilter<"user_stakes"> | Date | string
  }

  export type AmmpairCreateWithoutToken0Input = {
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
    token1: tokensCreateNestedOneWithoutAmmpairsAsToken1Input
  }

  export type AmmpairUncheckedCreateWithoutToken0Input = {
    id?: number
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    token1Address: string
    network: string
    token1Network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
  }

  export type AmmpairCreateOrConnectWithoutToken0Input = {
    where: AmmpairWhereUniqueInput
    create: XOR<AmmpairCreateWithoutToken0Input, AmmpairUncheckedCreateWithoutToken0Input>
  }

  export type AmmpairCreateManyToken0InputEnvelope = {
    data: AmmpairCreateManyToken0Input | AmmpairCreateManyToken0Input[]
    skipDuplicates?: boolean
  }

  export type AmmpairCreateWithoutToken1Input = {
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
    token0: tokensCreateNestedOneWithoutAmmpairsAsToken0Input
  }

  export type AmmpairUncheckedCreateWithoutToken1Input = {
    id?: number
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    token0Address: string
    network: string
    token0Network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
  }

  export type AmmpairCreateOrConnectWithoutToken1Input = {
    where: AmmpairWhereUniqueInput
    create: XOR<AmmpairCreateWithoutToken1Input, AmmpairUncheckedCreateWithoutToken1Input>
  }

  export type AmmpairCreateManyToken1InputEnvelope = {
    data: AmmpairCreateManyToken1Input | AmmpairCreateManyToken1Input[]
    skipDuplicates?: boolean
  }

  export type staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    users: usersCreateNestedOneWithoutStaking_poolsInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens: tokensCreateNestedOneWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
    user_stakes?: user_stakesCreateNestedManyWithoutStaking_poolsInput
  }

  export type staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    id?: number
    creatorAddress: string
    stakeTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorNetwork: string
    network: string
    stakeTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutStaking_poolsInput
  }

  export type staking_poolsCreateOrConnectWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    where: staking_poolsWhereUniqueInput
    create: XOR<staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
  }

  export type staking_poolsCreateManyTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInputEnvelope = {
    data: staking_poolsCreateManyTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput | staking_poolsCreateManyTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput[]
    skipDuplicates?: boolean
  }

  export type staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    users: usersCreateNestedOneWithoutStaking_poolsInput
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens: tokensCreateNestedOneWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    user_stakes?: user_stakesCreateNestedManyWithoutStaking_poolsInput
  }

  export type staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    id?: number
    creatorAddress: string
    rewardTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorNetwork: string
    network: string
    rewardTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutStaking_poolsInput
  }

  export type staking_poolsCreateOrConnectWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    where: staking_poolsWhereUniqueInput
    create: XOR<staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
  }

  export type staking_poolsCreateManyTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInputEnvelope = {
    data: staking_poolsCreateManyTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput | staking_poolsCreateManyTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput[]
    skipDuplicates?: boolean
  }

  export type AmmpairUpsertWithWhereUniqueWithoutToken0Input = {
    where: AmmpairWhereUniqueInput
    update: XOR<AmmpairUpdateWithoutToken0Input, AmmpairUncheckedUpdateWithoutToken0Input>
    create: XOR<AmmpairCreateWithoutToken0Input, AmmpairUncheckedCreateWithoutToken0Input>
  }

  export type AmmpairUpdateWithWhereUniqueWithoutToken0Input = {
    where: AmmpairWhereUniqueInput
    data: XOR<AmmpairUpdateWithoutToken0Input, AmmpairUncheckedUpdateWithoutToken0Input>
  }

  export type AmmpairUpdateManyWithWhereWithoutToken0Input = {
    where: AmmpairScalarWhereInput
    data: XOR<AmmpairUpdateManyMutationInput, AmmpairUncheckedUpdateManyWithoutToken0Input>
  }

  export type AmmpairScalarWhereInput = {
    AND?: AmmpairScalarWhereInput | AmmpairScalarWhereInput[]
    OR?: AmmpairScalarWhereInput[]
    NOT?: AmmpairScalarWhereInput | AmmpairScalarWhereInput[]
    id?: IntFilter<"Ammpair"> | number
    pair?: StringFilter<"Ammpair"> | string
    creator?: StringFilter<"Ammpair"> | string
    createdAt?: DateTimeFilter<"Ammpair"> | Date | string
    updatedAt?: DateTimeFilter<"Ammpair"> | Date | string
    version?: EnumAmmVersionFilter<"Ammpair"> | $Enums.AmmVersion
    token0Address?: StringFilter<"Ammpair"> | string
    token1Address?: StringFilter<"Ammpair"> | string
    network?: StringFilter<"Ammpair"> | string
    token0Network?: StringFilter<"Ammpair"> | string
    token1Network?: StringFilter<"Ammpair"> | string
    verified?: BoolFilter<"Ammpair"> | boolean
    displayOrder?: IntNullableFilter<"Ammpair"> | number | null
    apr24h?: StringNullableFilter<"Ammpair"> | string | null
    apr7d?: StringNullableFilter<"Ammpair"> | string | null
    apyCalculated?: StringNullableFilter<"Ammpair"> | string | null
    lastStatsUpdate?: DateTimeNullableFilter<"Ammpair"> | Date | string | null
    lpFeePercent?: StringNullableFilter<"Ammpair"> | string | null
    reserve0?: StringNullableFilter<"Ammpair"> | string | null
    reserve1?: StringNullableFilter<"Ammpair"> | string | null
    tvlUsd?: StringNullableFilter<"Ammpair"> | string | null
    volumeToken0_24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeToken1_24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd24h?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd7d?: StringNullableFilter<"Ammpair"> | string | null
    volumeUsd30d?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd24h?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd7d?: StringNullableFilter<"Ammpair"> | string | null
    feesUsd30d?: StringNullableFilter<"Ammpair"> | string | null
  }

  export type AmmpairUpsertWithWhereUniqueWithoutToken1Input = {
    where: AmmpairWhereUniqueInput
    update: XOR<AmmpairUpdateWithoutToken1Input, AmmpairUncheckedUpdateWithoutToken1Input>
    create: XOR<AmmpairCreateWithoutToken1Input, AmmpairUncheckedCreateWithoutToken1Input>
  }

  export type AmmpairUpdateWithWhereUniqueWithoutToken1Input = {
    where: AmmpairWhereUniqueInput
    data: XOR<AmmpairUpdateWithoutToken1Input, AmmpairUncheckedUpdateWithoutToken1Input>
  }

  export type AmmpairUpdateManyWithWhereWithoutToken1Input = {
    where: AmmpairScalarWhereInput
    data: XOR<AmmpairUpdateManyMutationInput, AmmpairUncheckedUpdateManyWithoutToken1Input>
  }

  export type staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    where: staking_poolsWhereUniqueInput
    update: XOR<staking_poolsUpdateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, staking_poolsUncheckedUpdateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
    create: XOR<staking_poolsCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
  }

  export type staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    where: staking_poolsWhereUniqueInput
    data: XOR<staking_poolsUpdateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput, staking_poolsUncheckedUpdateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
  }

  export type staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    where: staking_poolsScalarWhereInput
    data: XOR<staking_poolsUpdateManyMutationInput, staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput>
  }

  export type staking_poolsScalarWhereInput = {
    AND?: staking_poolsScalarWhereInput | staking_poolsScalarWhereInput[]
    OR?: staking_poolsScalarWhereInput[]
    NOT?: staking_poolsScalarWhereInput | staking_poolsScalarWhereInput[]
    id?: IntFilter<"staking_pools"> | number
    creatorAddress?: StringFilter<"staking_pools"> | string
    stakeTokenAddress?: StringFilter<"staking_pools"> | string
    rewardTokenAddress?: StringFilter<"staking_pools"> | string
    isDynamicPool?: BoolFilter<"staking_pools"> | boolean
    rewardPerSec?: StringFilter<"staking_pools"> | string
    accumReward?: StringFilter<"staking_pools"> | string
    lastUpdatedTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    startTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    endTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    emergencyLocked?: BoolFilter<"staking_pools"> | boolean
    stakesClosed?: BoolFilter<"staking_pools"> | boolean
    createdAt?: DateTimeFilter<"staking_pools"> | Date | string
    updatedAt?: DateTimeFilter<"staking_pools"> | Date | string
    creatorNetwork?: StringFilter<"staking_pools"> | string
    network?: StringFilter<"staking_pools"> | string
    rewardTokenNetwork?: StringFilter<"staking_pools"> | string
    stakeTokenNetwork?: StringFilter<"staking_pools"> | string
    boostEnabled?: BoolFilter<"staking_pools"> | boolean
    initialEndTimestamp?: BigIntFilter<"staking_pools"> | bigint | number
    initialRewardPerSec?: StringFilter<"staking_pools"> | string
    verified?: BoolFilter<"staking_pools"> | boolean
    totalBoosted?: StringFilter<"staking_pools"> | string
    displayOrder?: IntNullableFilter<"staking_pools"> | number | null
    cachedApy?: StringNullableFilter<"staking_pools"> | string | null
    cachedStakerCount?: IntNullableFilter<"staking_pools"> | number | null
    cachedTvlUsd?: StringNullableFilter<"staking_pools"> | string | null
    poolType?: EnumPoolTypeFilter<"staking_pools"> | $Enums.PoolType
    totalStakedAmount?: StringFilter<"staking_pools"> | string
    boostConfigCollectionName?: StringNullableFilter<"staking_pools"> | string | null
    boostConfigCollectionOwner?: StringNullableFilter<"staking_pools"> | string | null
    boostConfigPercent?: StringNullableFilter<"staking_pools"> | string | null
  }

  export type staking_poolsUpsertWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    where: staking_poolsWhereUniqueInput
    update: XOR<staking_poolsUpdateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, staking_poolsUncheckedUpdateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
    create: XOR<staking_poolsCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, staking_poolsUncheckedCreateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
  }

  export type staking_poolsUpdateWithWhereUniqueWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    where: staking_poolsWhereUniqueInput
    data: XOR<staking_poolsUpdateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput, staking_poolsUncheckedUpdateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
  }

  export type staking_poolsUpdateManyWithWhereWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    where: staking_poolsScalarWhereInput
    data: XOR<staking_poolsUpdateManyMutationInput, staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput>
  }

  export type PoolsDBCreateWithoutTrust_poolsInput = {
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
    comments?: commentsCreateNestedManyWithoutPoolsDBInput
    holders?: token_holdersCreateNestedManyWithoutPoolInput
  }

  export type PoolsDBUncheckedCreateWithoutTrust_poolsInput = {
    id?: number
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutPoolsDBInput
    holders?: token_holdersUncheckedCreateNestedManyWithoutPoolInput
  }

  export type PoolsDBCreateOrConnectWithoutTrust_poolsInput = {
    where: PoolsDBWhereUniqueInput
    create: XOR<PoolsDBCreateWithoutTrust_poolsInput, PoolsDBUncheckedCreateWithoutTrust_poolsInput>
  }

  export type PoolsDBUpsertWithoutTrust_poolsInput = {
    update: XOR<PoolsDBUpdateWithoutTrust_poolsInput, PoolsDBUncheckedUpdateWithoutTrust_poolsInput>
    create: XOR<PoolsDBCreateWithoutTrust_poolsInput, PoolsDBUncheckedCreateWithoutTrust_poolsInput>
    where?: PoolsDBWhereInput
  }

  export type PoolsDBUpdateToOneWithWhereWithoutTrust_poolsInput = {
    where?: PoolsDBWhereInput
    data: XOR<PoolsDBUpdateWithoutTrust_poolsInput, PoolsDBUncheckedUpdateWithoutTrust_poolsInput>
  }

  export type PoolsDBUpdateWithoutTrust_poolsInput = {
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutPoolsDBNestedInput
    holders?: token_holdersUpdateManyWithoutPoolNestedInput
  }

  export type PoolsDBUncheckedUpdateWithoutTrust_poolsInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutPoolsDBNestedInput
    holders?: token_holdersUncheckedUpdateManyWithoutPoolNestedInput
  }

  export type staking_poolsCreateWithoutUser_stakesInput = {
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    users: usersCreateNestedOneWithoutStaking_poolsInput
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens: tokensCreateNestedOneWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens: tokensCreateNestedOneWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
  }

  export type staking_poolsUncheckedCreateWithoutUser_stakesInput = {
    id?: number
    creatorAddress: string
    stakeTokenAddress: string
    rewardTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorNetwork: string
    network: string
    rewardTokenNetwork: string
    stakeTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
  }

  export type staking_poolsCreateOrConnectWithoutUser_stakesInput = {
    where: staking_poolsWhereUniqueInput
    create: XOR<staking_poolsCreateWithoutUser_stakesInput, staking_poolsUncheckedCreateWithoutUser_stakesInput>
  }

  export type usersCreateWithoutUser_stakesInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutUser_stakesInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsUncheckedCreateNestedManyWithoutUsersInput
    token_balances?: token_holdersUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutUser_stakesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_stakesInput, usersUncheckedCreateWithoutUser_stakesInput>
  }

  export type staking_poolsUpsertWithoutUser_stakesInput = {
    update: XOR<staking_poolsUpdateWithoutUser_stakesInput, staking_poolsUncheckedUpdateWithoutUser_stakesInput>
    create: XOR<staking_poolsCreateWithoutUser_stakesInput, staking_poolsUncheckedCreateWithoutUser_stakesInput>
    where?: staking_poolsWhereInput
  }

  export type staking_poolsUpdateToOneWithWhereWithoutUser_stakesInput = {
    where?: staking_poolsWhereInput
    data: XOR<staking_poolsUpdateWithoutUser_stakesInput, staking_poolsUncheckedUpdateWithoutUser_stakesInput>
  }

  export type staking_poolsUpdateWithoutUser_stakesInput = {
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutStaking_poolsNestedInput
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
  }

  export type staking_poolsUncheckedUpdateWithoutUser_stakesInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorAddress?: StringFieldUpdateOperationsInput | string
    stakeTokenAddress?: StringFieldUpdateOperationsInput | string
    rewardTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorNetwork?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    rewardTokenNetwork?: StringFieldUpdateOperationsInput | string
    stakeTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUpsertWithoutUser_stakesInput = {
    update: XOR<usersUpdateWithoutUser_stakesInput, usersUncheckedUpdateWithoutUser_stakesInput>
    create: XOR<usersCreateWithoutUser_stakesInput, usersUncheckedCreateWithoutUser_stakesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_stakesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_stakesInput, usersUncheckedUpdateWithoutUser_stakesInput>
  }

  export type usersUpdateWithoutUser_stakesInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_stakesInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUncheckedUpdateManyWithoutUsersNestedInput
    token_balances?: token_holdersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type commentsCreateWithoutUsersInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    likeCount?: number
    PoolsDB: PoolsDBCreateNestedOneWithoutCommentsInput
    images?: imagesCreateNestedManyWithoutCommentsInput
    likes?: likesCreateNestedManyWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutUsersInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poolId: number
    network: string
    displayOrder?: number | null
    likeCount?: number
    poolNetwork: string
    images?: imagesUncheckedCreateNestedManyWithoutCommentsInput
    likes?: likesUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type commentsCreateOrConnectWithoutUsersInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput>
  }

  export type commentsCreateManyUsersInputEnvelope = {
    data: commentsCreateManyUsersInput | commentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type likesCreateWithoutUsersInput = {
    createdAt?: Date | string
    network: string
    comments: commentsCreateNestedOneWithoutLikesInput
  }

  export type likesUncheckedCreateWithoutUsersInput = {
    id?: number
    createdAt?: Date | string
    commentId: number
    network: string
  }

  export type likesCreateOrConnectWithoutUsersInput = {
    where: likesWhereUniqueInput
    create: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput>
  }

  export type likesCreateManyUsersInputEnvelope = {
    data: likesCreateManyUsersInput | likesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type staking_poolsCreateWithoutUsersInput = {
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens: tokensCreateNestedOneWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens: tokensCreateNestedOneWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput
    user_stakes?: user_stakesCreateNestedManyWithoutStaking_poolsInput
  }

  export type staking_poolsUncheckedCreateWithoutUsersInput = {
    id?: number
    stakeTokenAddress: string
    rewardTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    rewardTokenNetwork: string
    stakeTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutStaking_poolsInput
  }

  export type staking_poolsCreateOrConnectWithoutUsersInput = {
    where: staking_poolsWhereUniqueInput
    create: XOR<staking_poolsCreateWithoutUsersInput, staking_poolsUncheckedCreateWithoutUsersInput>
  }

  export type staking_poolsCreateManyUsersInputEnvelope = {
    data: staking_poolsCreateManyUsersInput | staking_poolsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_stakesCreateWithoutUsersInput = {
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staking_pools: staking_poolsCreateNestedOneWithoutUser_stakesInput
  }

  export type user_stakesUncheckedCreateWithoutUsersInput = {
    id?: number
    poolId: number
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_stakesCreateOrConnectWithoutUsersInput = {
    where: user_stakesWhereUniqueInput
    create: XOR<user_stakesCreateWithoutUsersInput, user_stakesUncheckedCreateWithoutUsersInput>
  }

  export type user_stakesCreateManyUsersInputEnvelope = {
    data: user_stakesCreateManyUsersInput | user_stakesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type token_holdersCreateWithoutUserInput = {
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    pool: PoolsDBCreateNestedOneWithoutHoldersInput
  }

  export type token_holdersUncheckedCreateWithoutUserInput = {
    tokenAddress: string
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type token_holdersCreateOrConnectWithoutUserInput = {
    where: token_holdersWhereUniqueInput
    create: XOR<token_holdersCreateWithoutUserInput, token_holdersUncheckedCreateWithoutUserInput>
  }

  export type token_holdersCreateManyUserInputEnvelope = {
    data: token_holdersCreateManyUserInput | token_holdersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type commentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutUsersInput, commentsUncheckedUpdateWithoutUsersInput>
    create: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutUsersInput, commentsUncheckedUpdateWithoutUsersInput>
  }

  export type commentsUpdateManyWithWhereWithoutUsersInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type likesUpsertWithWhereUniqueWithoutUsersInput = {
    where: likesWhereUniqueInput
    update: XOR<likesUpdateWithoutUsersInput, likesUncheckedUpdateWithoutUsersInput>
    create: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput>
  }

  export type likesUpdateWithWhereUniqueWithoutUsersInput = {
    where: likesWhereUniqueInput
    data: XOR<likesUpdateWithoutUsersInput, likesUncheckedUpdateWithoutUsersInput>
  }

  export type likesUpdateManyWithWhereWithoutUsersInput = {
    where: likesScalarWhereInput
    data: XOR<likesUpdateManyMutationInput, likesUncheckedUpdateManyWithoutUsersInput>
  }

  export type staking_poolsUpsertWithWhereUniqueWithoutUsersInput = {
    where: staking_poolsWhereUniqueInput
    update: XOR<staking_poolsUpdateWithoutUsersInput, staking_poolsUncheckedUpdateWithoutUsersInput>
    create: XOR<staking_poolsCreateWithoutUsersInput, staking_poolsUncheckedCreateWithoutUsersInput>
  }

  export type staking_poolsUpdateWithWhereUniqueWithoutUsersInput = {
    where: staking_poolsWhereUniqueInput
    data: XOR<staking_poolsUpdateWithoutUsersInput, staking_poolsUncheckedUpdateWithoutUsersInput>
  }

  export type staking_poolsUpdateManyWithWhereWithoutUsersInput = {
    where: staking_poolsScalarWhereInput
    data: XOR<staking_poolsUpdateManyMutationInput, staking_poolsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_stakesUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_stakesWhereUniqueInput
    update: XOR<user_stakesUpdateWithoutUsersInput, user_stakesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_stakesCreateWithoutUsersInput, user_stakesUncheckedCreateWithoutUsersInput>
  }

  export type user_stakesUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_stakesWhereUniqueInput
    data: XOR<user_stakesUpdateWithoutUsersInput, user_stakesUncheckedUpdateWithoutUsersInput>
  }

  export type user_stakesUpdateManyWithWhereWithoutUsersInput = {
    where: user_stakesScalarWhereInput
    data: XOR<user_stakesUpdateManyMutationInput, user_stakesUncheckedUpdateManyWithoutUsersInput>
  }

  export type token_holdersUpsertWithWhereUniqueWithoutUserInput = {
    where: token_holdersWhereUniqueInput
    update: XOR<token_holdersUpdateWithoutUserInput, token_holdersUncheckedUpdateWithoutUserInput>
    create: XOR<token_holdersCreateWithoutUserInput, token_holdersUncheckedCreateWithoutUserInput>
  }

  export type token_holdersUpdateWithWhereUniqueWithoutUserInput = {
    where: token_holdersWhereUniqueInput
    data: XOR<token_holdersUpdateWithoutUserInput, token_holdersUncheckedUpdateWithoutUserInput>
  }

  export type token_holdersUpdateManyWithWhereWithoutUserInput = {
    where: token_holdersScalarWhereInput
    data: XOR<token_holdersUpdateManyMutationInput, token_holdersUncheckedUpdateManyWithoutUserInput>
  }

  export type usersCreateWithoutToken_balancesInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutToken_balancesInput = {
    walletAddress: string
    username?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nonce?: number | null
    network: string
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    staking_pools?: staking_poolsUncheckedCreateNestedManyWithoutUsersInput
    user_stakes?: user_stakesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutToken_balancesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutToken_balancesInput, usersUncheckedCreateWithoutToken_balancesInput>
  }

  export type PoolsDBCreateWithoutHoldersInput = {
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
    comments?: commentsCreateNestedManyWithoutPoolsDBInput
    trust_pools?: trust_poolsCreateNestedOneWithoutPoolsDBInput
  }

  export type PoolsDBUncheckedCreateWithoutHoldersInput = {
    id?: number
    description: string
    dev: string
    initialVirtualSupraReserves: bigint | number
    initialVirtualTokenReserves: bigint | number
    name: string
    platformFee: number
    pool: string
    symbol: string
    telegram: string
    tokenAddress: string
    tokenDecimals: number
    twitter: string
    uri: string
    website: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    displayOrder?: number | null
    github?: string | null
    stream?: string | null
    unstakePeriodSeconds?: bigint | number | null
    project_type?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutPoolsDBInput
    trust_pools?: trust_poolsUncheckedCreateNestedOneWithoutPoolsDBInput
  }

  export type PoolsDBCreateOrConnectWithoutHoldersInput = {
    where: PoolsDBWhereUniqueInput
    create: XOR<PoolsDBCreateWithoutHoldersInput, PoolsDBUncheckedCreateWithoutHoldersInput>
  }

  export type usersUpsertWithoutToken_balancesInput = {
    update: XOR<usersUpdateWithoutToken_balancesInput, usersUncheckedUpdateWithoutToken_balancesInput>
    create: XOR<usersCreateWithoutToken_balancesInput, usersUncheckedCreateWithoutToken_balancesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutToken_balancesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutToken_balancesInput, usersUncheckedUpdateWithoutToken_balancesInput>
  }

  export type usersUpdateWithoutToken_balancesInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutToken_balancesInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    staking_pools?: staking_poolsUncheckedUpdateManyWithoutUsersNestedInput
    user_stakes?: user_stakesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PoolsDBUpsertWithoutHoldersInput = {
    update: XOR<PoolsDBUpdateWithoutHoldersInput, PoolsDBUncheckedUpdateWithoutHoldersInput>
    create: XOR<PoolsDBCreateWithoutHoldersInput, PoolsDBUncheckedCreateWithoutHoldersInput>
    where?: PoolsDBWhereInput
  }

  export type PoolsDBUpdateToOneWithWhereWithoutHoldersInput = {
    where?: PoolsDBWhereInput
    data: XOR<PoolsDBUpdateWithoutHoldersInput, PoolsDBUncheckedUpdateWithoutHoldersInput>
  }

  export type PoolsDBUpdateWithoutHoldersInput = {
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutPoolsDBNestedInput
    trust_pools?: trust_poolsUpdateOneWithoutPoolsDBNestedInput
  }

  export type PoolsDBUncheckedUpdateWithoutHoldersInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dev?: StringFieldUpdateOperationsInput | string
    initialVirtualSupraReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    initialVirtualTokenReserves?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    platformFee?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    tokenAddress?: StringFieldUpdateOperationsInput | string
    tokenDecimals?: IntFieldUpdateOperationsInput | number
    twitter?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    unstakePeriodSeconds?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutPoolsDBNestedInput
    trust_pools?: trust_poolsUncheckedUpdateOneWithoutPoolsDBNestedInput
  }

  export type commentsCreateManyPoolsDBInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    userNetwork: string
    userWalletAddress: string
    displayOrder?: number | null
    likeCount?: number
  }

  export type token_holdersCreateManyPoolInput = {
    userWalletAddress: string
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type commentsUpdateWithoutPoolsDBInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    users?: usersUpdateOneRequiredWithoutCommentsNestedInput
    images?: imagesUpdateManyWithoutCommentsNestedInput
    likes?: likesUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutPoolsDBInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    images?: imagesUncheckedUpdateManyWithoutCommentsNestedInput
    likes?: likesUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutPoolsDBInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
  }

  export type token_holdersUpdateWithoutPoolInput = {
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutToken_balancesNestedInput
  }

  export type token_holdersUncheckedUpdateWithoutPoolInput = {
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_holdersUncheckedUpdateManyWithoutPoolInput = {
    userWalletAddress?: StringFieldUpdateOperationsInput | string
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesCreateManyCommentsInput = {
    id?: number
    url: string
    altText?: string | null
    createdAt?: Date | string
  }

  export type likesCreateManyCommentsInput = {
    id?: number
    createdAt?: Date | string
    network: string
    userNetwork: string
    userWalletAddress: string
  }

  export type imagesUpdateWithoutCommentsInput = {
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type likesUpdateWithoutCommentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutLikesNestedInput
  }

  export type likesUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
  }

  export type likesUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    userNetwork?: StringFieldUpdateOperationsInput | string
    userWalletAddress?: StringFieldUpdateOperationsInput | string
  }

  export type user_stakesCreateManyStaking_poolsInput = {
    id?: number
    userNetwork: string
    userAddress: string
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_stakesUpdateWithoutStaking_poolsInput = {
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_stakesNestedInput
  }

  export type user_stakesUncheckedUpdateWithoutStaking_poolsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userNetwork?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_stakesUncheckedUpdateManyWithoutStaking_poolsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userNetwork?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmmpairCreateManyToken0Input = {
    id?: number
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    token1Address: string
    network: string
    token1Network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
  }

  export type AmmpairCreateManyToken1Input = {
    id?: number
    pair: string
    creator: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: $Enums.AmmVersion
    token0Address: string
    network: string
    token0Network: string
    verified?: boolean
    displayOrder?: number | null
    apr24h?: string | null
    apr7d?: string | null
    apyCalculated?: string | null
    lastStatsUpdate?: Date | string | null
    lpFeePercent?: string | null
    reserve0?: string | null
    reserve1?: string | null
    tvlUsd?: string | null
    volumeToken0_24h?: string | null
    volumeToken1_24h?: string | null
    volumeUsd24h?: string | null
    volumeUsd7d?: string | null
    volumeUsd30d?: string | null
    feesUsd24h?: string | null
    feesUsd7d?: string | null
    feesUsd30d?: string | null
  }

  export type staking_poolsCreateManyTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    id?: number
    creatorAddress: string
    stakeTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorNetwork: string
    network: string
    stakeTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
  }

  export type staking_poolsCreateManyTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    id?: number
    creatorAddress: string
    rewardTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorNetwork: string
    network: string
    rewardTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
  }

  export type AmmpairUpdateWithoutToken0Input = {
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    token1?: tokensUpdateOneRequiredWithoutAmmpairsAsToken1NestedInput
  }

  export type AmmpairUncheckedUpdateWithoutToken0Input = {
    id?: IntFieldUpdateOperationsInput | number
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    token1Address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    token1Network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmmpairUncheckedUpdateManyWithoutToken0Input = {
    id?: IntFieldUpdateOperationsInput | number
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    token1Address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    token1Network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmmpairUpdateWithoutToken1Input = {
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    token0?: tokensUpdateOneRequiredWithoutAmmpairsAsToken0NestedInput
  }

  export type AmmpairUncheckedUpdateWithoutToken1Input = {
    id?: IntFieldUpdateOperationsInput | number
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    token0Address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    token0Network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmmpairUncheckedUpdateManyWithoutToken1Input = {
    id?: IntFieldUpdateOperationsInput | number
    pair?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: EnumAmmVersionFieldUpdateOperationsInput | $Enums.AmmVersion
    token0Address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    token0Network?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    apr24h?: NullableStringFieldUpdateOperationsInput | string | null
    apr7d?: NullableStringFieldUpdateOperationsInput | string | null
    apyCalculated?: NullableStringFieldUpdateOperationsInput | string | null
    lastStatsUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lpFeePercent?: NullableStringFieldUpdateOperationsInput | string | null
    reserve0?: NullableStringFieldUpdateOperationsInput | string | null
    reserve1?: NullableStringFieldUpdateOperationsInput | string | null
    tvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken0_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeToken1_24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    volumeUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd24h?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd7d?: NullableStringFieldUpdateOperationsInput | string | null
    feesUsd30d?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staking_poolsUpdateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutStaking_poolsNestedInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
    user_stakes?: user_stakesUpdateManyWithoutStaking_poolsNestedInput
  }

  export type staking_poolsUncheckedUpdateWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorAddress?: StringFieldUpdateOperationsInput | string
    stakeTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorNetwork?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    stakeTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    user_stakes?: user_stakesUncheckedUpdateManyWithoutStaking_poolsNestedInput
  }

  export type staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorAddress?: StringFieldUpdateOperationsInput | string
    stakeTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorNetwork?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    stakeTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staking_poolsUpdateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutStaking_poolsNestedInput
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    user_stakes?: user_stakesUpdateManyWithoutStaking_poolsNestedInput
  }

  export type staking_poolsUncheckedUpdateWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorAddress?: StringFieldUpdateOperationsInput | string
    rewardTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorNetwork?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    rewardTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    user_stakes?: user_stakesUncheckedUpdateManyWithoutStaking_poolsNestedInput
  }

  export type staking_poolsUncheckedUpdateManyWithoutTokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorAddress?: StringFieldUpdateOperationsInput | string
    rewardTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorNetwork?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    rewardTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentsCreateManyUsersInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poolId: number
    network: string
    displayOrder?: number | null
    likeCount?: number
    poolNetwork: string
  }

  export type likesCreateManyUsersInput = {
    id?: number
    createdAt?: Date | string
    commentId: number
    network: string
  }

  export type staking_poolsCreateManyUsersInput = {
    id?: number
    stakeTokenAddress: string
    rewardTokenAddress: string
    isDynamicPool: boolean
    rewardPerSec: string
    accumReward?: string
    lastUpdatedTimestamp: bigint | number
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    emergencyLocked?: boolean
    stakesClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    network: string
    rewardTokenNetwork: string
    stakeTokenNetwork: string
    boostEnabled: boolean
    initialEndTimestamp: bigint | number
    initialRewardPerSec: string
    verified?: boolean
    totalBoosted?: string
    displayOrder?: number | null
    cachedApy?: string | null
    cachedStakerCount?: number | null
    cachedTvlUsd?: string | null
    poolType?: $Enums.PoolType
    totalStakedAmount?: string
    boostConfigCollectionName?: string | null
    boostConfigCollectionOwner?: string | null
    boostConfigPercent?: string | null
  }

  export type user_stakesCreateManyUsersInput = {
    id?: number
    poolId: number
    stakedAmount: string
    rewardDebt?: string
    lastClaimTimestamp?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type token_holdersCreateManyUserInput = {
    tokenAddress: string
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type commentsUpdateWithoutUsersInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    PoolsDB?: PoolsDBUpdateOneRequiredWithoutCommentsNestedInput
    images?: imagesUpdateManyWithoutCommentsNestedInput
    likes?: likesUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poolId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    poolNetwork?: StringFieldUpdateOperationsInput | string
    images?: imagesUncheckedUpdateManyWithoutCommentsNestedInput
    likes?: likesUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poolId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: IntFieldUpdateOperationsInput | number
    poolNetwork?: StringFieldUpdateOperationsInput | string
  }

  export type likesUpdateWithoutUsersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    comments?: commentsUpdateOneRequiredWithoutLikesNestedInput
  }

  export type likesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
  }

  export type likesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: IntFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
  }

  export type staking_poolsUpdateWithoutUsersInput = {
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokens?: tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_rewardTokenNetwork_rewardTokenAddressTotokensNestedInput
    tokens_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokens?: tokensUpdateOneRequiredWithoutStaking_pools_staking_pools_stakeTokenNetwork_stakeTokenAddressTotokensNestedInput
    user_stakes?: user_stakesUpdateManyWithoutStaking_poolsNestedInput
  }

  export type staking_poolsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    stakeTokenAddress?: StringFieldUpdateOperationsInput | string
    rewardTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    rewardTokenNetwork?: StringFieldUpdateOperationsInput | string
    stakeTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
    user_stakes?: user_stakesUncheckedUpdateManyWithoutStaking_poolsNestedInput
  }

  export type staking_poolsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    stakeTokenAddress?: StringFieldUpdateOperationsInput | string
    rewardTokenAddress?: StringFieldUpdateOperationsInput | string
    isDynamicPool?: BoolFieldUpdateOperationsInput | boolean
    rewardPerSec?: StringFieldUpdateOperationsInput | string
    accumReward?: StringFieldUpdateOperationsInput | string
    lastUpdatedTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    emergencyLocked?: BoolFieldUpdateOperationsInput | boolean
    stakesClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: StringFieldUpdateOperationsInput | string
    rewardTokenNetwork?: StringFieldUpdateOperationsInput | string
    stakeTokenNetwork?: StringFieldUpdateOperationsInput | string
    boostEnabled?: BoolFieldUpdateOperationsInput | boolean
    initialEndTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    initialRewardPerSec?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalBoosted?: StringFieldUpdateOperationsInput | string
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    cachedApy?: NullableStringFieldUpdateOperationsInput | string | null
    cachedStakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    cachedTvlUsd?: NullableStringFieldUpdateOperationsInput | string | null
    poolType?: EnumPoolTypeFieldUpdateOperationsInput | $Enums.PoolType
    totalStakedAmount?: StringFieldUpdateOperationsInput | string
    boostConfigCollectionName?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigCollectionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    boostConfigPercent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_stakesUpdateWithoutUsersInput = {
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staking_pools?: staking_poolsUpdateOneRequiredWithoutUser_stakesNestedInput
  }

  export type user_stakesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    poolId?: IntFieldUpdateOperationsInput | number
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_stakesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    poolId?: IntFieldUpdateOperationsInput | number
    stakedAmount?: StringFieldUpdateOperationsInput | string
    rewardDebt?: StringFieldUpdateOperationsInput | string
    lastClaimTimestamp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_holdersUpdateWithoutUserInput = {
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pool?: PoolsDBUpdateOneRequiredWithoutHoldersNestedInput
  }

  export type token_holdersUncheckedUpdateWithoutUserInput = {
    tokenAddress?: StringFieldUpdateOperationsInput | string
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type token_holdersUncheckedUpdateManyWithoutUserInput = {
    tokenAddress?: StringFieldUpdateOperationsInput | string
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}